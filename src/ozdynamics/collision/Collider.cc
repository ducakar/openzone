/*
 * libozdynamics - OpenZone Dynamics Library.
 *
 * Copyright © 2002-2012 Davorin Učakar
 *
 * This software is provided 'as-is', without any express or implied warranty.
 * In no event will the authors be held liable for any damages arising from
 * the use of this software.
 *
 * Permission is granted to anyone to use this software for any purpose,
 * including commercial applications, and to alter it and redistribute it
 * freely, subject to the following restrictions:
 *
 * 1. The origin of this software must not be misrepresented; you must not
 *    claim that you wrote the original software. If you use this software in
 *    a product, an acknowledgement in the product documentation would be
 *    appreciated but is not required.
 * 2. Altered source versions must be plainly marked as such, and must not be
 *    misrepresented as being the original software.
 * 3. This notice may not be removed or altered from any source distribution.
 */

/**
 * @file ozdynamics/collision/Collider.cc
 */

#include "Collider.hh"

#include "Box.hh"

namespace oz
{

Collider::OverlapFunc* const Collider::dispatchMatrix[Shape::MAX][Shape::MAX] = {
  { Collider::boxBox, Collider::boxCapsule,     Collider::boxMesh,     Collider::boxCompound      },
  { nullptr,          Collider::capsuleCapsule, Collider::capsuleMesh, Collider::capsuleCompound  },
  { nullptr,          nullptr,                  Collider::meshMesh,    Collider::meshCompound     },
  { nullptr,          nullptr,                  nullptr,               Collider::compoundCompound }
};

bool Collider::boxBox( const Mat33& rot0, const Shape* box0,
                       const Mat33& rot1, const Shape* box1,
                       const Vec3& relPos, Result* result )
{
  Vec3  ext0 = static_cast<const Box*>( box0 )->ext;
  Vec3  ext1 = static_cast<const Box*>( box1 )->ext;
  Mat33 c    = ~rot0 * rot1;                                // rot1 = rot0 * c
  Mat33 d    = Mat33( abs( c.x ), abs( c.y ), abs( c.z ) ); // d = abs( c )

  // Separating axes for faces of `box0`.
  for( int j = 0; j < 3; ++j ) {
    float r0    = ext0[j];
    float r1    = ext1 * d.row( j );
    float dist  = rot0[j] * relPos;
    float depth = r0 + r1 - dist;

    if( depth >= 0.0f ) {
      if( result != nullptr && result->depth < depth ) {
        result->axis  = rot0[j];
        result->depth = depth;
      }
      return true;
    }
  }

  // Separating axes for faces of `box1`.
  for( int j = 0; j < 3; ++j ) {
    float r0    = ext0 * d[j];
    float r1    = ext1[j];
    float dist  = rot1[j] * relPos;
    float depth = r0 + r1 - dist;

    if( depth >= 0.0f ) {
      if( result != nullptr && result->depth < depth ) {
        result->axis  = rot1[j];
        result->depth = depth;
      }
      return true;
    }
  }

  // Separating axes generated by edges.
  const int INDICES[3][2] = { { 1, 2 }, { 2, 0 }, { 0, 1 } };

  for( int i = 0; i < 3; ++i ) {
    int ia0 = INDICES[i][0];
    int ia1 = INDICES[i][1];

    for( int j = 0; j < 3; ++j ) {
      int ib0     = INDICES[j][0];
      int ib1     = INDICES[j][1];

      float ca0   = d[j][ia1];
      float ca1   = d[j][ia0];
      float cb0   = d[ib1][i];
      float cb1   = d[ib0][i];

      float r0    = ext0[ia0] * ca0 + ext0[ia1] * ca1;
      float r1    = ext1[ib0] * cb0 + ext1[ib1] * cb1;
      float dist  = abs( ca0 * ( rot0[ia0] * relPos ) - ca1 * ( rot0[ia1] * relPos ) );
      float depth = r0 + r1 - dist;

      if( depth >= 0.0f ) {
        if( result != nullptr && result->depth < depth ) {
          result->axis  = rot0[i] ^ rot1[j];
          result->depth = depth;
        }
        return true;
      }
    }
  }

  return false;
}

bool Collider::overlaps( const Mat33& rot0, const Shape* shape0,
                         const Mat33& rot1, const Shape* shape1,
                         const Vec3& relPos, Result* result )
{
  Shape::Type type0 = shape0->type;
  Shape::Type type1 = shape1->type;

  if( result != nullptr ) {
    result->depth = 0.0f;
  }

  if( type0 <= type1 ) {
    return dispatchMatrix[type0][type1]( rot0, shape0, rot1, shape1, relPos, result );
  }
  else {
    return dispatchMatrix[type1][type0]( rot1, shape1, rot0, shape0, relPos, result );
  }
}

}
