/*
 * OpenZone - simple cross-platform FPS/RTS game engine.
 *
 * Copyright © 2002-2012 Davorin Učakar
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

/**
 * @file client/Input.cc
 */

#include "stable.hh"

#include "client/Input.hh"

#include "client/Window.hh"
#include "client/NaCl.hh"

namespace oz
{
namespace client
{

Input input;

void Input::readEvent( SDL_Event* event )
{
  switch( event->type ) {
    case SDL_MOUSEBUTTONUP: {
      currButtons &= char( ~SDL_BUTTON( event->button.button ) );
      break;
    }
    case SDL_MOUSEBUTTONDOWN: {
      buttons     |= char( SDL_BUTTON( event->button.button ) );
      currButtons |= char( SDL_BUTTON( event->button.button ) );

#if SDL_MAJOR_VERSION < 2
      if( buttons & SDL_BUTTON( SDL_BUTTON_WHEELUP ) ) {
        ++mouseW;
      }
      if( buttons & SDL_BUTTON( SDL_BUTTON_WHEELDOWN ) ) {
        --mouseW;
      }
#endif
      break;
    }
#if SDL_MAJOR_VERSION >= 2
    case SDL_MOUSEWHEEL: {
      mouseW -= event->wheel.y;
      break;
    }
#endif
    case SDL_KEYDOWN: {
      keys[event->key.keysym.sym] |= SDL_PRESSED;
      break;
    }
    default: {
      hard_assert( false );
      break;
    }
  }
}

void Input::reset()
{
#ifdef __native_client__

  NaCl::moveX = 0;
  NaCl::moveY = 0;
  NaCl::moveZ = 0;
  NaCl::moveW = 0;

#else

#if SDL_VERSION_MAJOR < 2
  SDL_WarpMouse( ushort( window.width / 2 ), ushort( window.height / 2 ) );
#else
  SDL_WarpMouseInWindow( window.descriptor, window.width / 2, window.height / 2 );
#endif
  // Suppress mouse motion event generated by SDL_WarpMouse().
  SDL_PumpEvents();
  SDL_GetRelativeMouseState( null, null );

#endif
}

void Input::prepare()
{
  mouseX     = 0;
  mouseY     = 0;
  mouseZ     = 0;
  mouseW     = 0;

  oldButtons = buttons;
  buttons    = currButtons;

  memcpy( oldKeys, keys, SDLK_LAST );
  memcpy( keys, currKeys, SDLK_LAST );
}

void Input::update()
{
  if( !hasFocus ) {
    return;
  }

  int inputX, inputY;

#ifdef __native_client__
  inputX = NaCl::moveX;
  inputY = NaCl::moveY;
#else
  SDL_GetRelativeMouseState( &inputX, &inputY );
#endif

  mouseX = +inputX;
  mouseY = -inputY;

  int clickedButtons = input.buttons & ~input.oldButtons;

  leftClick   = clickedButtons & Input::LEFT_BUTTON;
  middleClick = clickedButtons & Input::MIDDLE_BUTTON;
  rightClick  = clickedButtons & Input::RIGHT_BUTTON;
  wheelUp     = input.mouseW > 0;
  wheelDown   = input.mouseW < 0;

  // If input is not grabbed we must centre mouse so it cannot move out of the window.
  if( isLocked ) {
    reset();
  }
}

void Input::init()
{
  mouseX      = 0;
  mouseY      = 0;
  mouseZ      = 0;
  mouseW      = 0;

  buttons     = 0;
  oldButtons  = 0;
  currButtons = 0;

  leftClick   = false;
  middleClick = false;
  rightClick  = false;
  wheelUp     = false;
  wheelDown   = false;

  hasFocus    = true;
  isLocked    = true;

  memset( keys, 0, SDLK_LAST );
  memset( oldKeys, 0, SDLK_LAST );
  currKeys = SDL_GetKeyState( null );
}

void Input::free()
{}

}
}
