/*
 *  Audio.cpp
 *
 *  [description]
 *
 *  Copyright (C) 2002-2009, Davorin Uƒçakar <davorin.ucakar@gmail.com>
 */

#include "precompiled.h"

#include "Audio.h"

#include "Camera.h"

namespace oz
{
namespace client
{

  Audio audio;

  const float Audio::DMAX = 100.0f;
  const float Audio::DMAX_SQ = DMAX * DMAX;

  bool Audio::init()
  {
    logFile.print( "Initializing OpenAL audio device ..." );

    alutInit( null, null );

    isMusicPlaying = false;

    if( alutGetError() != ALUT_ERROR_NO_ERROR ) {
      logFile.printEnd( " Failed" );
      return false;
    }
    else {
      logFile.printEnd( " OK" );
    }

    logFile.println( "OpenAL vendor: %s", alGetString( AL_VENDOR ) );
    logFile.println( "OpenAL version: %s", alGetString( AL_VERSION ) );
    logFile.println( "OpenAL renderer: %s", alGetString( AL_RENDERER ) );
    logFile.println( "OpenAL extensions: %s", alGetString( AL_EXTENSIONS ) );

    logFile.println( "ALUT version: %d.%d", alutGetMajorVersion(), alutGetMinorVersion() );
    logFile.println( "ALUT suppored formats: %s", alutGetMIMETypes( ALUT_LOADER_MEMORY ) );

    alGenSources( 1, &musicSource );

    alSourcei( musicSource, AL_SOURCE_RELATIVE, AL_TRUE );
    alSourcei( musicSource, AL_ROLLOFF_FACTOR, 0 );

    setVolume( config.get( "sound.volume.effects", 1.0f ) );
    setMusicVolume( config.get( "sound.music.effects", 1.0f ) );

    return true;
  }

  void Audio::free()
  {
    for( Source *src = sources.first(); src != null; src = src->next[0] ) {
      alSourceStop( src->source );
      alDeleteSources( 1, &src->source );
    }
    sources.free();

    foreach( i, contSources.iterator() ) {
      ContSource &src = *i;

      alSourceStop( src.source );
      alDeleteSources( 1, &src.source );
    }
    contSources.clear();
    contSources.deallocate();

    alDeleteBuffers( MAX_BUFFERS, buffers );
    freeMusic();
    alutExit();
  }

  bool Audio::load( int sample, const char *file )
  {
    logFile.print( "Loading sound '%s' ...", file );

    FILE *oggFile = fopen( file, "rb" );
    OggVorbis_File oggStream;

    if( oggFile == null ) {
      logFile.printEnd( " Failed" );
      return false;
    }
    if( ov_open( oggFile, &oggStream, null, 0 ) < 0 ) {
      fclose( oggFile );
      logFile.printEnd( " Failed" );
      return false;
    }

    vorbis_info *vorbisInfo = ov_info( &oggStream, -1 );
    ALenum format = ( vorbisInfo->channels == 1 ? AL_FORMAT_MONO16 : AL_FORMAT_STEREO16 );
    int size = oggStream.end - oggStream.offset;

    logFile.println( "%d %d", size, vorbisInfo->rate );

    char data[size];
    int section;
    ov_read( &oggStream, data, size, 0, 2, 1, &section );
    ov_clear( &oggStream );

    alBufferData( buffers[sample], format, data, size, vorbisInfo->rate );

    logFile.printEnd( " OK" );
    return true;

//     buffers[sample] = alutCreateBufferFromFile( file );
//
//     if( buffers[sample] == AL_NONE ) {
//       logFile.printEnd( " Failed" );
//       return false;
//     }
//     else {
//       logFile.printEnd( " OK" );
//       return true;
//     }
  }

  void Audio::playSector( int sectorX, int sectorY )
  {
    Sector &sector = world.sectors[sectorX][sectorY];

    foreach( obj, sector.objects.iterator() ) {
      // TODO sound player
//       if( ( !obj->sounds.isEmpty() || !obj->contSounds.isEmpty() ) &&
//           ( camera.p - obj->p ).sqL() < DMAX_SQ )
//       {
//         // non-continous
//         foreach( snd, obj->effects.iterator() ) {
//           Source *src = new Source();
//
//           alGenSources( 1, &src->source );
//           alSourcei( src->source, AL_BUFFER, buffers[ snd->sample ] );
//           alSourcef( src->source, AL_REFERENCE_DISTANCE, 2.0f );
//
//           // If the object moves since source starts playing and source stands still, it's usually
//           // not noticable for short-time source. After all, sound source many times does't move
//           // together with the object in many cases (e.g. the sound when an objects hits something).
//           //
//           // However, when the sound is generated by player (e.g. cries, talk) it is often annoying
//           // if the sound source doesn't move with the player. That's why we position the sounds
//           // generated by the player at the origin of the coordinate system relative to player.
//           if( obj == camera.player ) {
//             alSourcei( src->source, AL_SOURCE_RELATIVE, AL_TRUE );
//             alSourcefv( src->source, AL_POSITION, Vec3::zero() );
//           }
//           else {
//             alSourcefv( src->source, AL_POSITION, obj->p );
//           }
//           alSourcePlay( src->source );
//
//           sources << src;
//         }
//         // continous
//         for( Sound *snd = obj->contSounds.first(); snd != null; snd = snd->next[0] ) {
//           if( contSources.contains( (uint) snd ) ) {
//             ContSource &src = contSources.cachedValue();
//
//             src.state = ContSource::UPDATED;
//
//             alSourcefv( src.source, AL_POSITION, obj->p );
//           }
//           else {
//             ContSource src;
//
//             src.state = ContSource::UPDATED;
//
//             alGenSources( 1, &src.source );
//             alSourcei( src.source, AL_BUFFER, buffers[ snd->sample ] );
//             alSourcefv( src.source, AL_POSITION, obj->p );
//             alSourcei( src.source, AL_LOOPING, AL_TRUE );
//             alSourcePlay( src.source );
//
//             contSources.add( (uint) snd, src );
//           }
//         }
//       }
    }
  }

  void Audio::update()
  {
    // add new sounds
//     alListenerfv( AL_ORIENTATION, camera.at );
//     alListenerfv( AL_POSITION, camera.p );
//
//     world.getInters( camera.p, DMAX );
//
//     for( int x = world.minSectX ; x <= world.maxSectX; x++ ) {
//       for( int y = world.minSectY; y <= world.maxSectY; y++ ) {
//         playSector( x, y );
//       }
//     }
//
//     // remove continous sounds that are not played any more
//     for( HashIndex<ContSource, HASHTABLE_SIZE>::Iterator i( contSources );
//          !i.isPassed(); )
//     {
//       ContSource *src = i;
//       uint key = i.key();
//
//       // we should advance now, so that we don't remove the element the iterator is pointing at
//       i++;
//
//       if( src->state == ContSource::NOT_UPDATED ) {
//         alSourceStop( src->source );
//         alDeleteSources( 1, &src->source );
//         contSources.remove( key );
//       }
//       else {
//         src->state = ContSource::NOT_UPDATED;
//       }
//     }
//
//     // remove stopped sources of non-continous sounds
//     if( clearCount >= CLEAR_INTERVAL ) {
//       Source *src = sources.first();
//
//       while( src != null ) {
//         Source *next = src->next[0];
//         ALint value = AL_STOPPED;
//
//         alGetSourcei( src->source, AL_SOURCE_STATE, &value );
//
//         if( value != AL_PLAYING ) {
//           alDeleteSources( 1, &src->source );
//
//           sources.remove( src );
//           delete src;
//         }
//         src = next;
//       }
//       clearCount -= CLEAR_INTERVAL;
//     }
//     clearCount += timer.frameMillis;

    updateMusic();
  }

  bool Audio::loadMusic( const char *file )
  {
    logFile.print( "Loading music '%s' ...", file );

    FILE *oggFile = fopen( file, "rb" );

    if( oggFile == null ) {
      logFile.printEnd( " Failed" );
      return false;
    }
    if( ov_open( oggFile, &oggStream, null, 0 ) < 0 ) {
      fclose( oggFile );
      logFile.printEnd( " Failed" );
      return false;
    }

    isMusicLoaded = true;

    vorbisInfo = ov_info( &oggStream, -1 );
    musicFormat = vorbisInfo->channels == 1 ? AL_FORMAT_MONO16 : AL_FORMAT_STEREO16;
    isMusicPlaying = true;

    alGenBuffers( 2, musicBuffers );
    loadMusicBuffer( musicBuffers[0] );
    loadMusicBuffer( musicBuffers[1] );
    alSourceQueueBuffers( musicSource, 2, &musicBuffers[0] );
    alSourcePlay( musicSource );

    logFile.printEnd( " OK" );
    return true;
  }

  void Audio::freeMusic()
  {
    if( isMusicLoaded ) {
      alSourceStop( musicSource );
      alDeleteSources( 1, &musicSource );
      alDeleteBuffers( 2, musicBuffers );

      ov_clear( &oggStream );

      isMusicLoaded = false;
    }
  }

  void Audio::loadMusicBuffer( ALuint buffer )
  {
    char data[MUSIC_BUFFER_SIZE];
    int  section;
    int  size = 0;
    int  result;

    do {
      result = ov_read( &oggStream, &data[size], MUSIC_BUFFER_SIZE - size, 0, 2, 1, &section );
      size += result;
      if( result < 0 ) {
        isMusicPlaying = false;
        return;
      }
    }
    while( result > 0 && size < MUSIC_BUFFER_SIZE );

    alBufferData( buffer, musicFormat, data, size, vorbisInfo->rate );
  }

  void Audio::updateMusic()
  {
    if( !isMusicPlaying ) {
      return;
    }

    int processed;
    alGetSourcei( musicSource, AL_BUFFERS_PROCESSED, &processed );

    while( processed > 0 ) {
      ALuint buffer;
      alSourceUnqueueBuffers( musicSource, 1, &buffer );
      loadMusicBuffer( buffer );
      alSourceQueueBuffers( musicSource, 1, &buffer );
      processed--;
    }
  }

  void Audio::setVolume( float volume )
  {
    alListenerf( AL_GAIN, volume );
  }

  void Audio::setMusicVolume( float volume )
  {
    alSourcef( musicSource, AL_GAIN, volume );
  }

}
}
