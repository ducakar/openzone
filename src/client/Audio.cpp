/*
 *  Audio.cpp
 *
 *  [description]
 *
 *  Copyright (C) 2002-2009, Davorin Uƒçakar <davorin.ucakar@gmail.com>
 */

#include "precompiled.h"

#include "Audio.h"

#include "Camera.h"
#include "Context.h"
#include "SoundManager.h"

namespace oz
{
namespace client
{

  void Audio::playSoundEvent( int sample ) const
  {
    ALuint srcId;

    alGenSources( 1, &srcId );
    alSourcei( srcId, AL_BUFFER, context.sounds[sample].id );
    alSourcef( srcId, AL_REFERENCE_DISTANCE, 2.0f );

    // If the object moves since source starts playing and source stands still, it's usually
    // not noticable for short-time source. After all, sound source many times does't move
    // together with the object in many cases (e.g. the sound when an objects hits something).
    //
    // However, when the sound is generated by player (e.g. cries, talk) it is often annoying
    // if the sound source doesn't move with the player. That's why we position the sounds
    // generated by the player at the origin of the coordinate system relative to player.
    if( &*object == camera.bot ) {
      alSourcei( srcId, AL_SOURCE_RELATIVE, AL_TRUE );
      alSourcefv( srcId, AL_POSITION, Vec3::zero() );
    }
    else {
      alSourcefv( srcId, AL_POSITION, object->p );
    }
    alSourcePlay( srcId );

    soundManager.addSource( srcId );
  }

  void Audio::playSoundEffect( int sample, uint key ) const
  {
    if( soundManager.updateContSource( key ) ) {
      alSourcefv( soundManager.getCachedContSourceId(), AL_POSITION, object->p );
    }
    else {
      ALuint srcId;

      alGenSources( 1, &srcId );
      alSourcei( srcId, AL_BUFFER, context.sounds[sample].id );
      alSourcefv( srcId, AL_POSITION, object->p );
      alSourcei( srcId, AL_LOOPING, AL_TRUE );
      alSourcePlay( srcId );

      soundManager.addContSource( key, srcId );
    }
  }

  void Audio::requestSounds() const
  {
    int *samples = object->type->audioSamples;

    for( int i = 0; i < ObjectClass::AUDIO_SAMPLES; i++ ) {
      if( samples[i] >= 0 ) {
        context.requestSound( samples[i] );
      }
    }
  }

  inline void Audio::releaseSounds() const
  {
    int *samples = object->type->audioSamples;

    for( int i = 0; i < ObjectClass::AUDIO_SAMPLES; i++ ) {
      if( samples[i] >= 0 ) {
        context.releaseSound( samples[i] );
      }
    }
  }

  Audio::~Audio()
  {
    releaseSounds();
  }

}
}
