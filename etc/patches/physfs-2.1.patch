diff -r e0dbcd5e50b9 CMakeLists.txt
--- a/CMakeLists.txt	Fri Nov 30 14:37:37 2012 -0500
+++ b/CMakeLists.txt	Sat Jun 15 20:56:00 2013 +0200
@@ -50,7 +50,7 @@
 # Add some gcc-specific command lines.
 if(CMAKE_COMPILER_IS_GNUCC)
     # Always build with debug symbols...you can strip it later.
-    add_definitions(-g -pipe -Werror -fsigned-char)
+    add_definitions(-g -fsigned-char)
 
     # Stupid BeOS generates warnings in the system headers.
     if(NOT BEOS)
@@ -124,6 +124,7 @@
     src/platform_unix.c
     src/platform_macosx.c
     src/platform_windows.c
+    src/platform_nacl.c
     src/archiver_dir.c
     src/archiver_unpacked.c
     src/archiver_grp.c
@@ -142,7 +143,15 @@
 # platform layers ...
 
 if(UNIX)
-    if(BEOS)
+    if(ANDROID)
+        set(PHYSFS_HAVE_CDROM_SUPPORT FALSE)
+        set(PHYSFS_HAVE_THREAD_SUPPORT TRUE)
+        set(HAVE_PTHREAD_H TRUE)
+    elseif(NACL)
+        set(PHYSFS_HAVE_CDROM_SUPPORT FALSE)
+        set(PHYSFS_HAVE_THREAD_SUPPORT TRUE)
+        set(HAVE_PTHREAD_H TRUE)
+    elseif(BEOS)
         set(PHYSFS_HAVE_CDROM_SUPPORT TRUE)
         set(PHYSFS_HAVE_THREAD_SUPPORT TRUE)
         set(HAVE_PTHREAD_H TRUE)
diff -r e0dbcd5e50b9 src/lzma/C/Archive/7z/7zDecode.c
--- a/src/lzma/C/Archive/7z/7zDecode.c	Fri Nov 30 14:37:37 2012 -0500
+++ b/src/lzma/C/Archive/7z/7zDecode.c	Sat Jun 15 20:56:00 2013 +0200
@@ -1,6 +1,10 @@
 /* 7zDecode.c */
 
-#include <memory.h>
+#ifdef __native_client__
+# include <string.h>
+#else
+# include <memory.h>
+#endif
 
 /* BEGIN PHYSFS CHANGE */
 #include <string.h>
diff -r e0dbcd5e50b9 src/physfs.c
--- a/src/physfs.c	Fri Nov 30 14:37:37 2012 -0500
+++ b/src/physfs.c	Sat Jun 15 20:56:00 2013 +0200
@@ -1268,8 +1268,7 @@
 {
     while (numArchivers > 0)
     {
-        const int rc = doDeregisterArchiver(numArchivers - 1);
-        assert(rc);  /* nothing should be mounted during shutdown. */
+        assert(doDeregisterArchiver(numArchivers - 1));  /* nothing should be mounted during shutdown. */
     } /* while */
 
     allocator.Free(archivers);
diff -r e0dbcd5e50b9 src/physfs.h
--- a/src/physfs.h	Fri Nov 30 14:37:37 2012 -0500
+++ b/src/physfs.h	Sat Jun 15 20:56:00 2013 +0200
@@ -229,7 +229,7 @@
 #define PHYSFS_DECL __declspec(dllexport)
 #elif (defined __SUNPRO_C)
 #define PHYSFS_DECL __global
-#elif ((__GNUC__ >= 3) && (!__EMX__) && (!sun))
+#elif ((__GNUC__ >= 3) && (!defined __EMX__) && (!defined sun))
 #define PHYSFS_DECL __attribute__((visibility("default")))
 #else
 #define PHYSFS_DECL
diff -r e0dbcd5e50b9 src/physfs_platforms.h
--- a/src/physfs_platforms.h	Fri Nov 30 14:37:37 2012 -0500
+++ b/src/physfs_platforms.h	Sat Jun 15 20:56:00 2013 +0200
@@ -40,6 +40,8 @@
 #  define PHYSFS_PLATFORM_UNIX 1
 #  define PHYSFS_PLATFORM_POSIX 1
 #  define PHYSFS_NO_CDROM_SUPPORT 1
+#elif defined(__native_client__)
+#  define PHYSFS_PLATFORM_NACL 1
 #elif defined(__linux)
 #  define PHYSFS_PLATFORM_LINUX 1
 #  define PHYSFS_PLATFORM_UNIX 1
diff -r e0dbcd5e50b9 src/platform_nacl.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/platform_nacl.c	Sat Jun 15 20:56:00 2013 +0200
@@ -0,0 +1,479 @@
+/*
+ * Native Client support routines for PhysicsFS.
+ *
+ * Please see the file LICENSE.txt in the source's root directory.
+ *
+ *  This file is written by Davorin Uƒçakar.
+ */
+
+#define __PHYSICSFS_INTERNAL__
+#include "physfs_platforms.h"
+
+#ifdef PHYSFS_PLATFORM_NACL
+
+#include <pthread.h>
+#include <string.h>
+
+#include <ppapi/c/pp_completion_callback.h>
+#include <ppapi/c/pp_errors.h>
+#include <ppapi/c/pp_file_info.h>
+#include <ppapi/c/ppb.h>
+#include <ppapi/c/ppb_core.h>
+#include <ppapi/c/ppb_file_system.h>
+#include <ppapi/c/ppb_file_ref.h>
+#include <ppapi/c/ppb_file_io.h>
+
+#include "physfs_internal.h"
+
+/* NaCl file I/O does not support appending or moving file cursor. In order to
+   support PHYSFS_openAppend, PHYSFS_seek etc. file is copied to a memory buffer
+   when opened, and all file I/O operations are performed on that buffer. */
+typedef struct FileDesc
+{
+    PP_Resource        fileIO;
+    struct PP_FileInfo fileInfo;
+    PP_FileOpenFlags   openFlags;
+    PHYSFS_uint64      offset;
+    char               path[256];
+} FileDesc;
+
+
+static PPB_GetInterface  getInterface;
+static PP_Instance       instance;
+static PP_FileSystemType fileSystemType;
+static PHYSFS_sint64     fileSystemSize = 0;
+static PP_Resource       fileSystem     = 0;
+
+
+/* Interfaces */
+static PPB_Core       *iCore       = NULL;
+static PPB_FileSystem *iFileSystem = NULL;
+static PPB_FileRef    *iFileRef    = NULL;
+static PPB_FileIO     *iFileIO     = NULL;
+
+
+int PHYSFS_NACL_init(PP_Instance instance_, PPB_GetInterface getInterface_,
+                     PP_FileSystemType type, PHYSFS_sint64 size)
+{
+    BAIL_IF_MACRO(!instance_, PHYSFS_ERR_ARGV0_IS_NULL, 0);
+    BAIL_IF_MACRO(!getInterface_, PHYSFS_ERR_ARGV0_IS_NULL, 0);
+
+    getInterface   = getInterface_;
+    instance       = instance_;
+    fileSystemType = type;
+    fileSystemSize = size;
+
+    return 1;
+} /* PHYSFS_NACL_init */
+
+
+int __PHYSFS_platformInit(void)
+{
+    iCore       = (PPB_Core *)       getInterface(PPB_CORE_INTERFACE);
+    iFileSystem = (PPB_FileSystem *) getInterface(PPB_FILESYSTEM_INTERFACE);
+    iFileRef    = (PPB_FileRef *)    getInterface(PPB_FILEREF_INTERFACE);
+    iFileIO     = (PPB_FileIO *)     getInterface(PPB_FILEIO_INTERFACE);
+
+    BAIL_IF_MACRO(!iCore || !iFileSystem || !iFileRef || !iFileIO, PHYSFS_ERR_OS_ERROR, 0);
+    BAIL_IF_MACRO(iCore->IsMainThread(), PHYSFS_ERR_BUSY, 0);
+
+    fileSystem = iFileSystem->Create(instance, fileSystemType);
+    BAIL_IF_MACRO(!fileSystem, PHYSFS_ERR_OS_ERROR, 0);
+    iCore->AddRefResource(fileSystem);
+
+    int retval = iFileSystem->Open(fileSystem, fileSystemSize, PP_BlockUntilComplete());
+    if (retval != PP_OK)
+    {
+        iCore->ReleaseResource(fileSystem);
+        fileSystem = 0;
+
+        BAIL_MACRO(PHYSFS_ERR_OS_ERROR, 0);
+    } /* if */
+
+    return 1;
+} /* __PHYSFS_platformInit */
+
+
+int __PHYSFS_platformDeinit(void)
+{
+    if (!fileSystem)
+    {
+        return 1;
+    } /* if */
+
+    iCore->ReleaseResource(fileSystem);
+    fileSystem = 0;
+
+    return 1;
+} /* __PHYSFS_platformDeinit */
+
+
+static void* openFile(const char* fileName, PP_FileOpenFlags openFlags)
+{
+    BAIL_IF_MACRO(iCore->IsMainThread(), PHYSFS_ERR_BUSY, 0);
+
+    FileDesc *file = (FileDesc *) allocator.Malloc(sizeof (FileDesc));
+    BAIL_IF_MACRO(!file, PHYSFS_ERR_OUT_OF_MEMORY, NULL);
+
+    file->openFlags = openFlags;
+    file->offset    = 0;
+    file->path[255] = '\0';
+    strncpy( file->path, fileName, 255 );
+
+    file->fileIO = iFileIO->Create(instance);
+    if (!file->fileIO)
+    {
+        allocator.Free(file);
+
+        BAIL_MACRO(PHYSFS_ERR_OS_ERROR, NULL);
+    } /* if */
+    iCore->AddRefResource(file->fileIO);
+
+    PP_Resource fileRef = iFileRef->Create(fileSystem, fileName);
+    if (!fileRef)
+    {
+        iCore->ReleaseResource(file->fileIO);
+        allocator.Free(file);
+
+        BAIL_MACRO(PHYSFS_ERR_OS_ERROR, NULL);
+    } /* if */
+    iCore->AddRefResource(fileRef);
+
+    int retval = iFileIO->Open(file->fileIO, fileRef, file->openFlags, PP_BlockUntilComplete());
+    if (retval != PP_OK)
+    {
+        iCore->ReleaseResource(fileRef);
+        iCore->ReleaseResource(file->fileIO);
+        allocator.Free(file);
+
+        printf( "%d\n", retval );
+
+        BAIL_MACRO(PHYSFS_ERR_IO, NULL);
+    } /* if */
+
+    retval = iFileIO->Query(file->fileIO, &file->fileInfo, PP_BlockUntilComplete());
+    if (retval != PP_OK)
+    {
+        iCore->ReleaseResource(fileRef);
+        iCore->ReleaseResource(file->fileIO);
+        allocator.Free(file);
+
+        BAIL_MACRO(PHYSFS_ERR_IO, NULL);
+    } /* if */
+
+    iCore->ReleaseResource(fileRef);
+    return file;
+} /* openFile */
+
+
+void *__PHYSFS_platformOpenRead(const char *filename)
+{
+    return openFile(filename, PP_FILEOPENFLAG_READ);
+} /* __PHYSFS_platformOpenRead */
+
+
+void *__PHYSFS_platformOpenWrite(const char *filename)
+{
+    return NULL;
+} /* __PHYSFS_platformOpenWrite */
+
+
+void *__PHYSFS_platformOpenAppend(const char *filename)
+{
+    return NULL;
+} /* __PHYSFS_platformOpenAppend */
+
+
+PHYSFS_sint64 __PHYSFS_platformRead(void *opaque, void *buffer,
+                                    PHYSFS_uint64 len)
+{
+    FileDesc* file = (FileDesc* ) opaque;
+    BAIL_IF_MACRO(iCore->IsMainThread(), PHYSFS_ERR_BUSY, 0);
+    BAIL_IF_MACRO(file->openFlags != PP_FILEOPENFLAG_READ, PHYSFS_ERR_OPEN_FOR_WRITING, 0);
+
+    int32_t bytesRead = 0;
+    int32_t bytesLeft = (int32_t) len;
+    int32_t retval    = 1;
+
+    while (bytesLeft && retval > 0)
+    {
+        retval = iFileIO->Read(file->fileIO, file->offset, buffer + bytesRead, bytesLeft,
+                               PP_BlockUntilComplete());
+
+        BAIL_IF_MACRO(retval < 0, PHYSFS_ERR_IO, bytesRead);
+
+        file->offset += retval;
+        bytesRead    += retval;
+        bytesLeft    -= retval;
+    } /* while */
+
+    return bytesRead;
+} /* __PHYSFS_platformRead */
+
+
+PHYSFS_sint64 __PHYSFS_platformWrite(void *opaque, const void *buffer,
+                                     PHYSFS_uint64 len)
+{
+    return 0;
+} /* __PHYSFS_platformWrite */
+
+
+int __PHYSFS_platformSeek(void *opaque, PHYSFS_uint64 pos)
+{
+    FileDesc *file = (FileDesc *) opaque;
+
+    PHYSFS_uint64 len = file->fileInfo.size;
+    BAIL_IF_MACRO(pos > len, PHYSFS_ERR_PAST_EOF, 0);
+
+    file->offset = pos;
+    return 1;
+} /* __PHYSFS_platformSeek */
+
+
+PHYSFS_sint64 __PHYSFS_platformTell(void *opaque)
+{
+    FileDesc *file = (FileDesc *) opaque;
+    return file->offset;
+} /* __PHYSFS_platformTell */
+
+
+PHYSFS_sint64 __PHYSFS_platformFileLength(void *opaque)
+{
+    FileDesc *file = (FileDesc *) opaque;
+    return file->fileInfo.size;
+} /* __PHYSFS_platformFileLength */
+
+
+int __PHYSFS_platformStat(const char *filename, PHYSFS_Stat *st)
+{
+    BAIL_IF_MACRO(iCore->IsMainThread(), PHYSFS_ERR_BUSY, 0);
+
+    /* Root must be handled as a special case as querying it always fails. */
+    if (filename[0] == '\0' || (filename[0] == '/' && filename[1] == '\0'))
+    {
+        st->createtime = 0;
+        st->modtime    = 0;
+        st->accesstime = 0;
+        st->readonly   = 0;
+        st->filesize   = 0;
+        st->filetype   = PHYSFS_FILETYPE_DIRECTORY;
+
+        return 1;
+    } /* if */
+
+    PP_Resource fileIO = iFileIO->Create(instance);
+    BAIL_IF_MACRO(!fileIO, PHYSFS_ERR_OS_ERROR, 0);
+    iCore->AddRefResource(fileIO);
+
+    PP_Resource fileRef = iFileRef->Create(fileSystem, filename);
+    if (!fileRef)
+    {
+        iCore->ReleaseResource(fileIO);
+        BAIL_MACRO(PHYSFS_ERR_OS_ERROR, 0);
+    } /* if */
+    iCore->AddRefResource(fileRef);
+
+    int retval = iFileIO->Open(fileIO, fileRef, 0, PP_BlockUntilComplete());
+    if (retval != PP_OK)
+    {
+        iCore->ReleaseResource(fileRef);
+        iCore->ReleaseResource(fileIO);
+
+        BAIL_MACRO(PHYSFS_ERR_OPEN_FOR_READING, 0);
+    } /* if */
+
+    struct PP_FileInfo fileInfo;
+    retval = iFileIO->Query(fileIO, &fileInfo, PP_BlockUntilComplete());
+
+    iFileIO->Close(fileIO);
+    iCore->ReleaseResource(fileRef);
+    iCore->ReleaseResource(fileIO);
+
+    BAIL_IF_MACRO(retval != PP_OK, PHYSFS_ERR_IO, 0);
+
+    st->createtime = fileInfo.creation_time;
+    st->modtime    = fileInfo.last_modified_time;
+    st->accesstime = fileInfo.last_access_time;
+    st->readonly   = 0;
+    st->filesize   = fileInfo.size;
+
+    switch (fileInfo.type)
+    {
+        case PP_FILETYPE_REGULAR:
+            st->filetype = PHYSFS_FILETYPE_REGULAR;
+            break;
+        case PP_FILETYPE_DIRECTORY:
+            st->filetype = PHYSFS_FILETYPE_DIRECTORY;
+            break;
+        default:
+            st->filetype = PHYSFS_FILETYPE_OTHER;
+            break;
+    } /* switch */
+
+    return 1;
+} /* __PHYSFS_platformStat */
+
+
+int __PHYSFS_platformFlush(void *opaque)
+{
+    return 1;
+} /* __PHYSFS_platformFlush */
+
+
+void __PHYSFS_platformClose(void *opaque)
+{
+    FileDesc *file = (FileDesc *) opaque;
+
+    iCore->ReleaseResource(file->fileIO);
+    allocator.Free(file);
+} /* __PHYSFS_platformClose */
+
+
+void __PHYSFS_platformDetectAvailableCDs(PHYSFS_StringCallback cb, void *data)
+{
+    /* CDs are not supported on NaCl. */
+} /* __PHYSFS_platformDetectAvailableCDs */
+
+
+char *__PHYSFS_platformCalcBaseDir(const char *argv0)
+{
+    char *retval = (char *) allocator.Malloc(2);
+    BAIL_IF_MACRO(!retval, PHYSFS_ERR_OUT_OF_MEMORY, NULL);
+
+    retval[0] = '/';
+    retval[1] = '\0';
+
+    return retval;
+} /* __PHYSFS_platformCalcBaseDir */
+
+
+char *__PHYSFS_platformCalcUserDir(void)
+{
+    char *retval = (char *) allocator.Malloc(2);
+    BAIL_IF_MACRO(!retval, PHYSFS_ERR_OUT_OF_MEMORY, NULL);
+
+    retval[0] = '/';
+    retval[1] = '\0';
+
+    return retval;
+} /* __PHYSFS_platformCalcUserDir */
+
+
+char *__PHYSFS_platformCalcPrefDir(const char *org, const char *app)
+{
+    char *retval = (char *) allocator.Malloc(2);
+    BAIL_IF_MACRO(!retval, PHYSFS_ERR_OUT_OF_MEMORY, NULL);
+
+    retval[0] = '/';
+    retval[1] = '\0';
+
+    return retval;
+} /* __PHYSFS_platformCalcPrefDir */
+
+
+void *__PHYSFS_platformGetThreadID(void)
+{
+    return ( (void *) ((size_t) pthread_self()) );
+} /* __PHYSFS_platformGetThreadID */
+
+
+/* Directory listing is not supported on NaCl. */
+void __PHYSFS_platformEnumerateFiles(const char *dirname,
+                                     PHYSFS_EnumFilesCallback callback,
+                                     const char *origdir,
+                                     void *callbackdata)
+{
+} /* __PHYSFS_platformEnumerateFiles */
+
+
+int __PHYSFS_platformMkDir(const char *path)
+{
+    return 0;
+} /* __PHYSFS_platformMkDir */
+
+
+int __PHYSFS_platformDelete(const char *path)
+{
+    return 0;
+} /* __PHYSFS_platformDelete */
+
+
+typedef struct
+{
+    pthread_mutex_t mutex;
+    pthread_t owner;
+    PHYSFS_uint32 count;
+} PthreadMutex;
+
+
+void *__PHYSFS_platformCreateMutex(void)
+{
+    int rc;
+    PthreadMutex *m = (PthreadMutex *) allocator.Malloc(sizeof (PthreadMutex));
+    BAIL_IF_MACRO(!m, PHYSFS_ERR_OUT_OF_MEMORY, NULL);
+    rc = pthread_mutex_init(&m->mutex, NULL);
+    if (rc != 0)
+    {
+        allocator.Free(m);
+        BAIL_MACRO(PHYSFS_ERR_OS_ERROR, NULL);
+    } /* if */
+
+    m->count = 0;
+    m->owner = (pthread_t) 0xDEADBEEF;
+    return ((void *) m);
+} /* __PHYSFS_platformCreateMutex */
+
+
+void __PHYSFS_platformDestroyMutex(void *mutex)
+{
+    PthreadMutex *m = (PthreadMutex *) mutex;
+
+    /* Destroying a locked mutex is a bug, but we'll try to be helpful. */
+    if ((m->owner == pthread_self()) && (m->count > 0))
+        pthread_mutex_unlock(&m->mutex);
+
+    pthread_mutex_destroy(&m->mutex);
+    allocator.Free(m);
+} /* __PHYSFS_platformDestroyMutex */
+
+
+int __PHYSFS_platformGrabMutex(void *mutex)
+{
+    PthreadMutex *m = (PthreadMutex *) mutex;
+    pthread_t tid = pthread_self();
+    if (m->owner != tid)
+    {
+        if (pthread_mutex_lock(&m->mutex) != 0)
+            return 0;
+        m->owner = tid;
+    } /* if */
+
+    m->count++;
+    return 1;
+} /* __PHYSFS_platformGrabMutex */
+
+
+void __PHYSFS_platformReleaseMutex(void *mutex)
+{
+    PthreadMutex *m = (PthreadMutex *) mutex;
+    assert(m->owner == pthread_self());  /* catch programming errors. */
+    assert(m->count > 0);  /* catch programming errors. */
+    if (m->owner == pthread_self())
+    {
+        if (--m->count == 0)
+        {
+            m->owner = (pthread_t) 0xDEADBEEF;
+            pthread_mutex_unlock(&m->mutex);
+        } /* if */
+    } /* if */
+} /* __PHYSFS_platformReleaseMutex */
+
+int __PHYSFS_platformSetDefaultAllocator(PHYSFS_Allocator *a)
+{
+    return 0;  /* just use malloc() and friends. */
+} /* __PHYSFS_platformSetDefaultAllocator */
+
+#endif  /* PHYSFS_PLATFORM_NACL */
+
+/* end of platorm_nacl.c ... */
+
