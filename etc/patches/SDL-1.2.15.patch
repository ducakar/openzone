diff -Naur SDL-1.2.15.orig/build-scripts/config.sub SDL-1.2.15/build-scripts/config.sub
--- SDL-1.2.15.orig/build-scripts/config.sub	2012-01-19 07:30:05.000000000 +0100
+++ SDL-1.2.15/build-scripts/config.sub	2014-05-06 18:00:14.346894596 +0200
@@ -311,6 +311,14 @@
 	ms1)
 		basic_machine=mt-unknown
 		;;
+	nacl64*)
+		basic_machine=x86_64-pc
+		os=-nacl
+		;;
+	nacl*)
+		basic_machine=i686-pc
+		os=-nacl
+		;;
 
 	# We use `pc' rather than `unknown'
 	# because (1) that's what they normally are, and
@@ -1309,6 +1317,9 @@
 			;;
 		esac
 		;;
+	-nacl*)
+		os=-nacl
+		;;
 	-nto-qnx*)
 		;;
 	-nto*)
diff -Naur SDL-1.2.15.orig/configure.in SDL-1.2.15/configure.in
--- SDL-1.2.15.orig/configure.in	2012-01-19 07:30:05.000000000 +0100
+++ SDL-1.2.15/configure.in	2014-05-06 18:00:14.346894596 +0200
@@ -910,6 +910,50 @@
     fi
 }
 
+dnl Check for Native Client stuff
+CheckNativeClient()
+{
+    AC_ARG_ENABLE(naclvideo,
+AC_HELP_STRING([--enable-naclvideo], [enable the nacl video driver [[default=yes]]]),
+                  , enable_naclvideo=yes)
+    if test x$enable_video = xyes -a x$enable_naclvideo = xyes; then
+        AC_DEFINE(SDL_VIDEO_DRIVER_NACL)
+        SOURCES="$SOURCES $srcdir/src/video/nacl/*.cc"
+        EXTRA_LDFLAGS="-lnacl_io -l${NACL_CPP_LIB:-stdc++} $EXTRA_LDFLAGS"
+        SDL_LIBS="$SDL_LIBS -lppapi -lSDLmain"
+    fi
+
+    AC_ARG_ENABLE(naclaudio,
+AC_HELP_STRING([--enable-naclaudio], [enable the nacl audio driver [[default=yes]]]),
+                  , enable_naclaudio=yes)
+    if test x$enable_audio = xyes -a x$enable_naclaudio = xyes; then
+        AC_DEFINE(SDL_AUDIO_DRIVER_NACL)
+        SOURCES="$SOURCES $srcdir/src/audio/nacl/*.cc"
+    fi
+}
+
+dnl Find Regal OpenGL library
+CheckOpenGLRegal()
+{
+    if test x$enable_video = xyes -a x$enable_video_opengl = xyes; then
+        AC_MSG_CHECKING(for OpenGL (Regal) support)
+        video_opengl=no
+        AC_TRY_COMPILE([
+         #include <GL/Regal.h>
+        ],[
+        ],[
+        video_opengl=yes
+        ])
+        AC_MSG_RESULT($video_opengl)
+        if test x$video_opengl = xyes; then
+            AC_DEFINE(SDL_VIDEO_OPENGL)
+            AC_DEFINE(SDL_VIDEO_OPENGL_REGAL)
+            EXTRA_LDFLAGS="-lRegal -lppapi_gles2 ${EXTRA_LDFLAGS}"
+            SDL_LIBS="-lRegal -lppapi_gles2 ${SDL_LIBS}"
+        fi
+    fi
+}
+
 
 dnl Do the iPod thing
 CheckIPod()
@@ -2325,6 +2369,22 @@
             have_timers=yes
         fi
         ;;
+    *-nacl)
+        ARCH=nacl
+        CheckNativeClient
+        CheckOpenGLRegal
+        CheckDummyAudio
+        CheckDummyVideo
+        CheckInputEvents
+        # Set up files for the timer library
+        if test x$enable_timers = xyes; then
+            AC_DEFINE(SDL_TIMER_UNIX)
+            SOURCES="$SOURCES $srcdir/src/timer/unix/*.c"
+            have_timers=yes
+        fi
+        CheckPTHREAD
+        SDLMAIN_SOURCES="$srcdir/src/main/nacl/*.c"
+        ;;
     *-*-linux*|*-*-uclinux*|*-*-gnu*|*-*-k*bsd*-gnu|*-*-bsdi*|*-*-freebsd*|*-*-dragonfly*|*-*-netbsd*|*-*-openbsd*|*-*-sysv5*|*-*-solaris*|*-*-hpux*|*-*-irix*|*-*-aix*|*-*-osf*)
         case "$host" in
             *-*-linux*)         ARCH=linux ;;
@@ -2914,6 +2974,9 @@
     # Evil hack to allow static linking on Mac OS X
     SDL_STATIC_LIBS="\${libdir}/libSDLmain.a \${libdir}/libSDL.a $EXTRA_LDFLAGS"
     ;;
+  nacl)
+    SDL_STATIC_LIBS=""
+    ;;
   *)
     SDL_STATIC_LIBS="$SDL_LIBS $EXTRA_LDFLAGS"
     ;;
diff -Naur SDL-1.2.15.orig/include/SDL_config.h.in SDL-1.2.15/include/SDL_config.h.in
--- SDL-1.2.15.orig/include/SDL_config.h.in	2012-01-19 07:30:05.000000000 +0100
+++ SDL-1.2.15/include/SDL_config.h.in	2014-05-06 18:00:14.346894596 +0200
@@ -176,6 +176,7 @@
 #undef SDL_AUDIO_DRIVER_ESD_DYNAMIC
 #undef SDL_AUDIO_DRIVER_MINT
 #undef SDL_AUDIO_DRIVER_MMEAUDIO
+#undef SDL_AUDIO_DRIVER_NACL
 #undef SDL_AUDIO_DRIVER_NAS
 #undef SDL_AUDIO_DRIVER_NAS_DYNAMIC
 #undef SDL_AUDIO_DRIVER_OSS
@@ -267,6 +268,7 @@
 #undef SDL_VIDEO_DRIVER_GEM
 #undef SDL_VIDEO_DRIVER_GGI
 #undef SDL_VIDEO_DRIVER_IPOD
+#undef SDL_VIDEO_DRIVER_NACL
 #undef SDL_VIDEO_DRIVER_NANOX
 #undef SDL_VIDEO_DRIVER_OS2FS
 #undef SDL_VIDEO_DRIVER_PHOTON
@@ -297,6 +299,7 @@
 /* Enable OpenGL support */
 #undef SDL_VIDEO_OPENGL
 #undef SDL_VIDEO_OPENGL_GLX
+#undef SDL_VIDEO_OPENGL_REGAL
 #undef SDL_VIDEO_OPENGL_WGL
 #undef SDL_VIDEO_OPENGL_OSMESA
 #undef SDL_VIDEO_OPENGL_OSMESA_DYNAMIC
diff -Naur SDL-1.2.15.orig/include/SDL_main.h SDL-1.2.15/include/SDL_main.h
--- SDL-1.2.15.orig/include/SDL_main.h	2012-01-19 07:30:05.000000000 +0100
+++ SDL-1.2.15/include/SDL_main.h	2014-05-06 18:00:14.346894596 +0200
@@ -32,7 +32,7 @@
 #if defined(__WIN32__) || \
     (defined(__MWERKS__) && !defined(__BEOS__)) || \
     defined(__MACOS__) || defined(__MACOSX__) || \
-    defined(__SYMBIAN32__) || defined(QWS)
+    defined(__SYMBIAN32__) || defined(QWS) || defined(__native_client__)
 
 #ifdef __cplusplus
 #define C_LINKAGE	"C"
diff -Naur SDL-1.2.15.orig/include/SDL_nacl.h SDL-1.2.15/include/SDL_nacl.h
--- SDL-1.2.15.orig/include/SDL_nacl.h	1970-01-01 01:00:00.000000000 +0100
+++ SDL-1.2.15/include/SDL_nacl.h	2014-05-06 18:00:14.346894596 +0200
@@ -0,0 +1,26 @@
+#ifndef _SDL_nacl_h
+#define _SDL_nacl_h
+
+#include "begin_code.h"
+#include <ppapi/c/pp_instance.h>
+#include <ppapi/c/pp_resource.h>
+#include <ppapi/c/ppb.h>
+
+/* Set up for C function definitions, even when using C++ */
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+void SDL_NACL_SetInstance(PP_Instance instance, PPB_GetInterface get_interface,
+                          int width, int height);
+void SDL_NACL_PushEvent(PP_Resource input_event);
+void SDL_NACL_SetHasFocus(int has_focus);
+void SDL_NACL_SetPageVisible(int is_visible);
+
+/* Ends C function definitions when using C++ */
+#ifdef __cplusplus
+}
+#endif
+#include "close_code.h"
+
+#endif /* _SDL_nacl_h */
diff -Naur SDL-1.2.15.orig/include/SDL_opengl.h SDL-1.2.15/include/SDL_opengl.h
--- SDL-1.2.15.orig/include/SDL_opengl.h	2012-01-19 07:30:05.000000000 +0100
+++ SDL-1.2.15/include/SDL_opengl.h	2014-05-06 18:00:14.350227929 +0200
@@ -33,7 +33,7 @@
 #endif
 #include <windows.h>
 #endif
-#ifndef NO_SDL_GLEXT
+#if !defined(NO_SDL_GLEXT) && !defined(__native_client__)
 #define __glext_h_  /* Don't let gl.h include glext.h */
 #endif
 #if defined(__MACOSX__)
@@ -42,6 +42,10 @@
 #elif defined(__MACOS__)
 #include <gl.h>		/* Header File For The OpenGL Library */
 #include <glu.h>	/* Header File For The GLU Library */
+#elif defined(__native_client__)
+#include <GL/Regal.h>
+#define APIENTRY
+#define APIENTRYP APIENTRY *
 #else
 #include <GL/gl.h>	/* Header File For The OpenGL Library */
 #include <GL/glu.h>	/* Header File For The GLU Library */
diff -Naur SDL-1.2.15.orig/include/SDL_platform.h SDL-1.2.15/include/SDL_platform.h
--- SDL-1.2.15.orig/include/SDL_platform.h	2012-01-19 07:30:05.000000000 +0100
+++ SDL-1.2.15/include/SDL_platform.h	2014-05-06 18:00:14.350227929 +0200
@@ -63,10 +63,14 @@
 #undef __IRIX__
 #define __IRIX__	1
 #endif
-#if defined(linux) || defined(__linux) || defined(__linux__)
+#if defined(linux) || defined(__linux) || defined(__linux__) && !defined(__native_client__)
 #undef __LINUX__
 #define __LINUX__	1
 #endif
+#if defined(__native_client__)
+#undef __NACL__
+#define __NACL__ 1
+#endif
 #if defined(__APPLE__)
 #undef __MACOSX__
 #define __MACOSX__	1
diff -Naur SDL-1.2.15.orig/Makefile.in SDL-1.2.15/Makefile.in
--- SDL-1.2.15.orig/Makefile.in	2012-01-19 07:30:05.000000000 +0100
+++ SDL-1.2.15/Makefile.in	2014-05-06 18:00:14.350227929 +0200
@@ -43,7 +43,7 @@
 
 DIST = acinclude autogen.sh Borland.html Borland.zip BUGS build-scripts configure configure.in COPYING CREDITS CWprojects.sea.bin docs docs.html include INSTALL Makefile.dc Makefile.minimal Makefile.in MPWmake.sea.bin README* sdl-config.in sdl.m4 sdl.pc.in SDL.qpg.in SDL.spec SDL.spec.in src test TODO VisualCE VisualC.html VisualC Watcom-OS2.zip Watcom-Win32.zip symbian.zip WhatsNew Xcode
 
-HDRS = SDL.h SDL_active.h SDL_audio.h SDL_byteorder.h SDL_cdrom.h SDL_cpuinfo.h SDL_endian.h SDL_error.h SDL_events.h SDL_getenv.h SDL_joystick.h SDL_keyboard.h SDL_keysym.h SDL_loadso.h SDL_main.h SDL_mouse.h SDL_mutex.h SDL_name.h SDL_opengl.h SDL_platform.h SDL_quit.h SDL_rwops.h SDL_stdinc.h SDL_syswm.h SDL_thread.h SDL_timer.h SDL_types.h SDL_version.h SDL_video.h begin_code.h close_code.h
+HDRS = SDL.h SDL_active.h SDL_audio.h SDL_byteorder.h SDL_cdrom.h SDL_cpuinfo.h SDL_endian.h SDL_error.h SDL_events.h SDL_getenv.h SDL_joystick.h SDL_keyboard.h SDL_keysym.h SDL_loadso.h SDL_main.h SDL_mouse.h SDL_mutex.h SDL_name.h SDL_nacl.h SDL_opengl.h SDL_platform.h SDL_quit.h SDL_rwops.h SDL_stdinc.h SDL_syswm.h SDL_thread.h SDL_timer.h SDL_types.h SDL_version.h SDL_video.h begin_code.h close_code.h
 
 LT_AGE      = @LT_AGE@
 LT_CURRENT  = @LT_CURRENT@
diff -Naur SDL-1.2.15.orig/src/audio/nacl/SDL_naclaudio.cc SDL-1.2.15/src/audio/nacl/SDL_naclaudio.cc
--- SDL-1.2.15.orig/src/audio/nacl/SDL_naclaudio.cc	1970-01-01 01:00:00.000000000 +0100
+++ SDL-1.2.15/src/audio/nacl/SDL_naclaudio.cc	2014-05-06 18:00:14.350227929 +0200
@@ -0,0 +1,150 @@
+#include "SDL_config.h"
+#include "SDL_naclaudio.h"
+
+#include <assert.h>
+
+#include <ppapi/c/pp_instance.h>
+#include <ppapi/c/ppb.h>
+#include <ppapi/c/ppb_audio.h>
+#include <ppapi/c/ppb_audio_config.h>
+#include <ppapi/c/ppb_core.h>
+
+extern PP_Instance g_nacl_pp_instance;
+extern PPB_GetInterface g_nacl_get_interface;
+extern const PPB_Core_1_0* g_nacl_core_interface;
+
+const PPB_Audio_1_1* g_nacl_audio_interface;
+const PPB_AudioConfig_1_1* g_nacl_audio_config_interface;
+
+extern "C" {
+
+#include "SDL_rwops.h"
+#include "SDL_timer.h"
+#include "SDL_audio.h"
+#include "SDL_mutex.h"
+#include "../SDL_audiomem.h"
+#include "../SDL_audio_c.h"
+#include "../SDL_audiodev_c.h"
+
+/* The tag name used by NACL audio */
+#define NACLAUD_DRIVER_NAME "nacl"
+
+const uint32_t kSampleFrameCount = 4096u;
+
+/* Audio driver functions */
+static int NACLAUD_OpenAudio(_THIS, SDL_AudioSpec* spec);
+static void NACLAUD_CloseAudio(_THIS);
+
+static void AudioCallback(void* samples, uint32_t buffer_size, PP_TimeDelta,
+                          void* data);
+
+/* Audio driver bootstrap functions */
+static int NACLAUD_Available(void) {
+  return g_nacl_pp_instance && g_nacl_get_interface;
+}
+
+static void NACLAUD_DeleteDevice(SDL_AudioDevice* device) {
+  if (device->hidden->audio) {
+    g_nacl_audio_interface->StopPlayback(device->hidden->audio);
+    g_nacl_core_interface->ReleaseResource(device->hidden->audio);
+    device->hidden->audio = 0;
+  }
+}
+
+static SDL_AudioDevice* NACLAUD_CreateDevice(int devindex) {
+  SDL_AudioDevice* _this;
+
+  /* Initialize all variables that we clean on shutdown */
+  _this = (SDL_AudioDevice*)SDL_malloc(sizeof(SDL_AudioDevice));
+  if (_this) {
+    SDL_memset(_this, 0, (sizeof *_this));
+    _this->hidden =
+        (struct SDL_PrivateAudioData*)SDL_malloc((sizeof *_this->hidden));
+  }
+  if ((_this == NULL) || (_this->hidden == NULL)) {
+    SDL_OutOfMemory();
+    if (_this) {
+      SDL_free(_this);
+    }
+    return (0);
+  }
+  SDL_memset(_this->hidden, 0, (sizeof *_this->hidden));
+
+  _this->hidden->mutex = SDL_CreateMutex();
+
+  _this->hidden->opened = false;
+
+  // TODO: Move audio device creation to NACLAUD_OpenAudio.
+  const PPB_Audio_1_1* g_nacl_audio_interface =
+      (const PPB_Audio_1_1*)g_nacl_get_interface(PPB_AUDIO_INTERFACE_1_1);
+  const PPB_AudioConfig_1_1* g_nacl_audio_config_interface =
+      (const PPB_AudioConfig_1_1*)g_nacl_get_interface(
+          PPB_AUDIO_CONFIG_INTERFACE_1_1);
+
+  _this->hidden->sample_frame_count =
+      g_nacl_audio_config_interface->RecommendSampleFrameCount(
+          g_nacl_pp_instance, PP_AUDIOSAMPLERATE_44100, kSampleFrameCount);
+
+  PP_Resource audio_config = g_nacl_audio_config_interface->CreateStereo16Bit(
+      g_nacl_pp_instance, PP_AUDIOSAMPLERATE_44100,
+      _this->hidden->sample_frame_count);
+  _this->hidden->audio = g_nacl_audio_interface->Create(
+      g_nacl_pp_instance, audio_config, AudioCallback, _this);
+
+  // Start audio playback while we are still on the main thread.
+  g_nacl_audio_interface->StartPlayback(_this->hidden->audio);
+
+  /* Set the function pointers */
+  _this->OpenAudio = NACLAUD_OpenAudio;
+  _this->CloseAudio = NACLAUD_CloseAudio;
+
+  _this->free = NACLAUD_DeleteDevice;
+
+  return _this;
+}
+
+AudioBootStrap NACLAUD_bootstrap = {
+    NACLAUD_DRIVER_NAME, "SDL nacl audio driver",
+    NACLAUD_Available, NACLAUD_CreateDevice
+};
+
+static void NACLAUD_CloseAudio(_THIS) {
+  SDL_LockMutex(_this->hidden->mutex);
+  _this->hidden->opened = 0;
+  SDL_UnlockMutex(_this->hidden->mutex);
+}
+
+static void AudioCallback(void* samples, uint32_t buffer_size, PP_TimeDelta,
+                          void* data) {
+  SDL_AudioDevice* _this = reinterpret_cast<SDL_AudioDevice*>(data);
+
+  SDL_LockMutex(_this->hidden->mutex);
+  if (_this->hidden->opened) {
+    SDL_memset(samples, _this->spec.silence, buffer_size);
+    SDL_LockMutex(_this->mixer_lock);
+    (*_this->spec.callback)(_this->spec.userdata, (Uint8*)samples, buffer_size);
+    SDL_UnlockMutex(_this->mixer_lock);
+  } else {
+    SDL_memset(samples, 0, buffer_size);
+  }
+  SDL_UnlockMutex(_this->hidden->mutex);
+
+  return;
+}
+
+static int NACLAUD_OpenAudio(_THIS, SDL_AudioSpec* spec) {
+  // We don't care what the user wants.
+  spec->freq = 44100;
+  spec->format = AUDIO_S16LSB;
+  spec->channels = 2;
+  spec->samples = _this->hidden->sample_frame_count;
+
+  SDL_LockMutex(_this->hidden->mutex);
+  _this->hidden->opened = 1;
+  SDL_UnlockMutex(_this->hidden->mutex);
+
+  // Do not create an audio thread.
+  return 1;
+}
+
+}  // extern "C"
diff -Naur SDL-1.2.15.orig/src/audio/nacl/SDL_naclaudio.h SDL-1.2.15/src/audio/nacl/SDL_naclaudio.h
--- SDL-1.2.15.orig/src/audio/nacl/SDL_naclaudio.h	1970-01-01 01:00:00.000000000 +0100
+++ SDL-1.2.15/src/audio/nacl/SDL_naclaudio.h	2014-05-06 18:00:14.350227929 +0200
@@ -0,0 +1,30 @@
+#include "SDL_config.h"
+
+#ifndef _SDL_naclaudio_h
+#define _SDL_naclaudio_h
+
+extern "C" {
+#include "SDL_audio.h"
+#include "../SDL_sysaudio.h"
+#include "SDL_mutex.h"
+}
+
+#include <ppapi/c/ppb_audio.h>
+
+/* Hidden "this" pointer for the video functions */
+#define _THIS	SDL_AudioDevice *_this
+
+struct SDL_PrivateAudioData {
+
+  SDL_mutex* mutex;
+  // This flag is use to determine when the audio is opened and we can start
+  // serving audio data instead of silence. This is needed because current
+  // Pepper2 can only be used from the main thread; Therefore, we start the
+  // audio thread very early.
+  bool opened;
+
+  int sample_frame_count;
+  PP_Resource audio;
+};
+
+#endif /* _SDL_naclaudio_h */
diff -Naur SDL-1.2.15.orig/src/audio/SDL_audio.c SDL-1.2.15/src/audio/SDL_audio.c
--- SDL-1.2.15.orig/src/audio/SDL_audio.c	2012-01-19 07:30:06.000000000 +0100
+++ SDL-1.2.15/src/audio/SDL_audio.c	2014-05-06 18:00:14.350227929 +0200
@@ -36,6 +36,9 @@
 
 /* Available audio drivers */
 static AudioBootStrap *bootstrap[] = {
+#if SDL_AUDIO_DRIVER_NACL
+	&NACLAUD_bootstrap,
+#endif
 #if SDL_AUDIO_DRIVER_PULSE
 	&PULSE_bootstrap,
 #endif
diff -Naur SDL-1.2.15.orig/src/audio/SDL_sysaudio.h SDL-1.2.15/src/audio/SDL_sysaudio.h
--- SDL-1.2.15.orig/src/audio/SDL_sysaudio.h	2012-01-19 07:30:06.000000000 +0100
+++ SDL-1.2.15/src/audio/SDL_sysaudio.h	2014-05-06 18:00:14.350227929 +0200
@@ -158,6 +158,9 @@
 extern AudioBootStrap MINTAUDIO_XBIOS_bootstrap;
 extern AudioBootStrap MINTAUDIO_DMA8_bootstrap;
 #endif
+#if SDL_AUDIO_DRIVER_NACL
+extern AudioBootStrap NACLAUD_bootstrap;
+#endif
 #if SDL_AUDIO_DRIVER_DISK
 extern AudioBootStrap DISKAUD_bootstrap;
 #endif
diff -Naur SDL-1.2.15.orig/src/cpuinfo/SDL_cpuinfo.c SDL-1.2.15/src/cpuinfo/SDL_cpuinfo.c
--- SDL-1.2.15.orig/src/cpuinfo/SDL_cpuinfo.c	2012-01-19 07:30:06.000000000 +0100
+++ SDL-1.2.15/src/cpuinfo/SDL_cpuinfo.c	2014-05-06 18:00:14.353561261 +0200
@@ -53,6 +53,8 @@
 }
 #endif /* HAVE_SETJMP */
 
+
+#if SDL_ASSEMBLY_ROUTINES
 static __inline__ int CPU_haveCPUID(void)
 {
 	int has_CPUID = 0;
@@ -300,6 +302,15 @@
 	return features;
 }
 
+#else // SDL_ASSEMBLY_ROUTINES
+
+static __inline__ int CPU_haveCPUID(void) { return 0; }
+static __inline__ int CPU_getCPUIDFeaturesExt(void) { return 0; }
+static __inline__ int CPU_getCPUIDFeatures(void) { return 0; }
+
+#endif // SDL_ASSEMBLY_ROUTINES
+
+
 static __inline__ int CPU_haveRDTSC(void)
 {
 	if ( CPU_haveCPUID() ) {
diff -Naur SDL-1.2.15.orig/src/main/nacl/pepper_instance.c SDL-1.2.15/src/main/nacl/pepper_instance.c
--- SDL-1.2.15.orig/src/main/nacl/pepper_instance.c	1970-01-01 01:00:00.000000000 +0100
+++ SDL-1.2.15/src/main/nacl/pepper_instance.c	2014-05-06 18:00:42.206895631 +0200
@@ -0,0 +1,219 @@
+/*
+ * Copyright (c) 2011 The Native Client Authors. All rights reserved.
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+#include <assert.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <pthread.h>
+#include <stdio.h>
+#include <string.h>
+#include <sys/mount.h>
+#include <unistd.h>
+
+#include <SDL.h>
+#include <SDL_nacl.h>
+#include <SDL_video.h>
+#include <SDL_main.h>
+
+#include <ppapi/c/pp_errors.h>
+#include <ppapi/c/pp_instance.h>
+#include <ppapi/c/ppb.h>
+#include <ppapi/c/ppb_input_event.h>
+#include <ppapi/c/ppb_view.h>
+#include <ppapi/c/ppp.h>
+#include <ppapi/c/ppp_input_event.h>
+#include <ppapi/c/ppp_instance.h>
+#include <ppapi/c/pp_rect.h>
+
+#include "nacl_io/nacl_io.h"
+
+static PP_Instance g_instance;
+static PPB_GetInterface g_get_browser_interface;
+static struct PPB_InputEvent_1_0* g_input_event_interface;
+static struct PPB_View_1_1* g_view_interface;
+static int g_width = 0;
+static int g_height = 0;
+static int g_argc;
+static const char** g_argn;
+static const char** g_argv;
+static pthread_t g_sdl_thread;
+
+static void* sdl_thread_start(void*);
+static void ProcessArgs();
+
+static PP_Bool Instance_DidCreate(PP_Instance instance, uint32_t argc,
+                                  const char* argn[], const char* argv[]) {
+  int i;
+
+  g_instance = instance;
+  g_input_event_interface->RequestInputEvents(instance,
+                                              PP_INPUTEVENT_CLASS_MOUSE);
+  g_input_event_interface->RequestFilteringInputEvents(
+      instance, PP_INPUTEVENT_CLASS_KEYBOARD);
+
+  nacl_io_init_ppapi(instance, g_get_browser_interface);
+
+  // Copy args so they can be processed later by the SDL thread.
+  g_argc = argc;
+  g_argn = (const char**)malloc(argc * sizeof(char*));
+  g_argv = (const char**)malloc(argc * sizeof(char*));
+  memset(g_argn, 0, argc * sizeof(char*));
+  memset(g_argv, 0, argc * sizeof(char*));
+
+  for (i = 0; i < argc; i++) {
+    if (argn[i]) g_argn[i] = strdup(argn[i]);
+    if (argv[i]) g_argv[i] = strdup(argv[i]);
+  }
+
+  return PP_TRUE;
+}
+
+static void Instance_DidDestroy(PP_Instance instance) {}
+
+static void Instance_DidChangeView(PP_Instance instance,
+                                   PP_Resource view_resource) {
+  struct PP_Rect view_rect;
+  if (g_width && g_height) return;
+
+  if (g_view_interface->GetRect(view_resource, &view_rect) == PP_FALSE) {
+    fprintf(stderr, "SDL: Unable to get view rect!\n");
+    return;
+  }
+
+  if (view_rect.size.width == g_width && view_rect.size.height == g_height)
+    return;  // Size didn't change, no need to update anything.
+
+  g_width = view_rect.size.width;
+  g_height = view_rect.size.height;
+
+  SDL_NACL_SetInstance(g_instance, g_get_browser_interface, g_width, g_height);
+  pthread_create(&g_sdl_thread, NULL, sdl_thread_start, NULL);
+}
+
+/*
+ * Entry point for the main SDL thread.  The job of this thread is to
+ * run SDL_main, which in most cases is the application's main() function
+ * re-defined by the pre-processor in SDL_main.h.
+ */
+static void* sdl_thread_start(void* arg) {
+  char* argv[2];
+  int rtn;
+
+  ProcessArgs();
+  fprintf(stderr, "SDL: calling SDL_main\n");
+  argv[0] = (char*)"SDL applicaiton";
+  argv[1] = NULL;
+  rtn = SDL_main(1, argv);
+  fprintf(stderr, "SDL: SDL_main returned: %d\n", rtn);
+  exit(rtn);
+  return NULL;
+}
+
+static void ProcessArgs() {
+  int i;
+  int rtn;
+  int mount_default = 1;
+  fprintf(stderr, "SDL: ProcessArgs %d\n", g_argc);
+
+  umount("/");
+
+  for (i = 0; i < g_argc; i++) {
+    if (!strcmp(g_argn[i], "ps_stdout")) {
+      int fd1 = open(g_argv[i], O_WRONLY);
+      dup2(fd1, 1);
+    } else if (!strcmp(g_argn[i], "ps_stderr")) {
+      int fd2 = open(g_argv[i], O_WRONLY);
+      dup2(fd2, 2);
+    } else if (!strcmp(g_argn[i], "sdl_mount_http")) {
+      const char* source;
+      const char* target = "/";
+      char* sep;
+      char buf[64];
+      int n;
+
+      const char* q, *p = g_argv[i];
+      while (*p) {
+        while (*p && isspace(*p)) ++p;
+        if (!*p) break;
+        q = p;
+        while (*p && !isspace(*p)) ++p;
+
+        n = sizeof(buf) - 1;
+        if (p - q < n) n = p - q;
+        strncpy(buf, q, n);
+        buf[n] = '\0';
+
+        sep = strchr(buf, ':');
+        source = buf;
+        if (sep) {
+          target = sep + 1;
+          *sep = '\0';
+        }
+
+        mount_default = 0;
+        fprintf(stderr, "SDL: adding http mount '%s' -> '%s'\n", source,
+                target);
+        rtn = mount(source, target, "httpfs", 0, "");
+        if (rtn != 0)
+          fprintf(stderr, "SDL: mount failed: %s\n", strerror(errno));
+      }
+    }
+  }
+
+  if (mount_default) {
+    // Create an http mount by default
+    fprintf(stderr, "SDL: creating default http mount\n");
+    rtn = mount("", "/", "httpfs", 0, "");
+    if (rtn != 0) fprintf(stderr, "SDL: mount failed: %s\n", strerror(errno));
+  } else {
+    // This could fail if the sdl_mount_http attributes
+    // about created a mount on "/".
+    fprintf(stderr, "SDL: creating memfs on root\n");
+    mount("", "/", "memfs", 0, "");
+  }
+}
+
+static void Instance_DidChangeFocus(PP_Instance instance, PP_Bool has_focus) {}
+
+static PP_Bool Instance_HandleDocumentLoad(PP_Instance instance,
+                                           PP_Resource url_loader) {
+  return PP_FALSE;
+}
+
+static PP_Bool InputEvent_HandleInputEvent(PP_Instance instance,
+                                           PP_Resource input_event) {
+  SDL_NACL_PushEvent(input_event);
+  return PP_TRUE;
+}
+
+PP_EXPORT int32_t
+PPP_InitializeModule(PP_Module module, PPB_GetInterface get_browser) {
+  g_get_browser_interface = get_browser;
+  g_input_event_interface =
+      (struct PPB_InputEvent_1_0*)get_browser(PPB_INPUT_EVENT_INTERFACE_1_0);
+  g_view_interface = (struct PPB_View_1_1*)get_browser(PPB_VIEW_INTERFACE_1_1);
+  return PP_OK;
+}
+
+PP_EXPORT const void* PPP_GetInterface(const char* interface_name) {
+  if (strcmp(interface_name, PPP_INSTANCE_INTERFACE) == 0) {
+    static struct PPP_Instance_1_1 instance_interface = {
+        &Instance_DidCreate,
+        &Instance_DidDestroy,
+        &Instance_DidChangeView,
+        &Instance_DidChangeFocus,
+        &Instance_HandleDocumentLoad,
+    };
+    return &instance_interface;
+  } else if (strcmp(interface_name, PPP_INPUT_EVENT_INTERFACE_0_1) == 0) {
+    static struct PPP_InputEvent_0_1 input_event_interface = {
+        &InputEvent_HandleInputEvent,
+    };
+    return &input_event_interface;
+  }
+  return NULL;
+}
+
+PP_EXPORT void PPP_ShutdownModule() {}
diff -Naur SDL-1.2.15.orig/src/SDL_fatal.c SDL-1.2.15/src/SDL_fatal.c
--- SDL-1.2.15.orig/src/SDL_fatal.c	2012-01-19 07:30:06.000000000 +0100
+++ SDL-1.2.15/src/SDL_fatal.c	2014-05-06 18:00:14.353561261 +0200
@@ -39,7 +39,11 @@
 {
 	signal(sig, SIG_DFL);
 	SDL_Quit();
+#ifdef __native_client__
+	exit(sig);
+#else
 	raise(sig);
+#endif
 }
 
 static int SDL_fatal_signals[] = {
diff -Naur SDL-1.2.15.orig/src/thread/pthread/SDL_systhread.c SDL-1.2.15/src/thread/pthread/SDL_systhread.c
--- SDL-1.2.15.orig/src/thread/pthread/SDL_systhread.c	2012-01-19 07:30:06.000000000 +0100
+++ SDL-1.2.15/src/thread/pthread/SDL_systhread.c	2014-05-06 18:00:14.353561261 +0200
@@ -81,12 +81,15 @@
 	int i;
 	sigset_t mask;
 
+	// NativeClient does not yet support signals.
+#ifndef __NACL__
 	/* Mask asynchronous signals for this thread */
 	sigemptyset(&mask);
 	for ( i=0; sig_list[i]; ++i ) {
 		sigaddset(&mask, sig_list[i]);
 	}
 	pthread_sigmask(SIG_BLOCK, &mask, 0);
+#endif
 
 #ifdef PTHREAD_CANCEL_ASYNCHRONOUS
 	/* Allow ourselves to be asynchronously cancelled */
diff -Naur SDL-1.2.15.orig/src/video/nacl/eventqueue.h SDL-1.2.15/src/video/nacl/eventqueue.h
--- SDL-1.2.15.orig/src/video/nacl/eventqueue.h	1970-01-01 01:00:00.000000000 +0100
+++ SDL-1.2.15/src/video/nacl/eventqueue.h	2014-05-06 18:00:14.353561261 +0200
@@ -0,0 +1,40 @@
+#ifndef _SDL_nacl_eventqueue_h
+#define _SDL_nacl_eventqueue_h
+
+#include "SDL_mutex.h"
+
+#include <queue>
+
+class EventQueue {
+public:
+  EventQueue() {
+    mu_ = SDL_CreateMutex();
+  }
+
+  ~EventQueue() {
+    SDL_DestroyMutex(mu_);
+  }
+
+  SDL_Event* PopEvent() {
+    SDL_LockMutex(mu_);
+    SDL_Event* event = NULL;
+    if (!queue_.empty()) {
+      event = queue_.front();
+      queue_.pop();
+    }
+    SDL_UnlockMutex(mu_);
+    return event;
+  }
+
+   void PushEvent(SDL_Event* event) {
+    SDL_LockMutex(mu_);
+    queue_.push(event);
+    SDL_UnlockMutex(mu_);
+   } 
+
+private:
+  std::queue<SDL_Event*> queue_;
+  SDL_mutex* mu_;
+};
+
+#endif // _SDL_nacl_eventqueue_h
diff -Naur SDL-1.2.15.orig/src/video/nacl/SDL_naclevents.cc SDL-1.2.15/src/video/nacl/SDL_naclevents.cc
--- SDL-1.2.15.orig/src/video/nacl/SDL_naclevents.cc	1970-01-01 01:00:00.000000000 +0100
+++ SDL-1.2.15/src/video/nacl/SDL_naclevents.cc	2014-05-06 18:00:14.353561261 +0200
@@ -0,0 +1,320 @@
+#include "SDL_config.h"
+
+#include "SDL_nacl.h"
+
+extern "C" {
+#include "SDL.h"
+#include "../../events/SDL_sysevents.h"
+#include "../../events/SDL_events_c.h"
+}
+
+#include "SDL_naclevents_c.h"
+#include "eventqueue.h"
+#include <ppapi/c/pp_point.h>
+#include <ppapi/c/pp_var.h>
+#include <ppapi/c/ppb_input_event.h>
+#include <ppapi/c/ppb_var.h>
+
+#include <math.h>
+
+extern const PPB_InputEvent_1_0 *g_nacl_input_event_interface;
+extern const PPB_MouseInputEvent_1_1 *g_nacl_mouse_input_event_interface;
+extern const PPB_WheelInputEvent_1_0 *g_nacl_wheel_input_event_interface;
+extern const PPB_KeyboardInputEvent_1_0 *g_nacl_keyboard_input_event_interface;
+extern const PPB_Var_1_1 *g_nacl_var_interface;
+
+static EventQueue event_queue;
+
+static Uint8 translateButton(int32_t button) {
+  switch (button) {
+    case PP_INPUTEVENT_MOUSEBUTTON_LEFT:
+      return SDL_BUTTON_LEFT;
+    case PP_INPUTEVENT_MOUSEBUTTON_MIDDLE:
+      return SDL_BUTTON_MIDDLE;
+    case PP_INPUTEVENT_MOUSEBUTTON_RIGHT:
+      return SDL_BUTTON_RIGHT;
+    case PP_INPUTEVENT_MOUSEBUTTON_NONE:
+    default:
+      return 0;
+  }
+}
+
+// Translate ASCII code to browser keycode
+static uint8_t translateAscii(uint8_t ascii) {
+  if ('A' <= ascii && ascii <= 'Z') {
+    return ascii;
+  } else if ('a' <= ascii && ascii <= 'z') {
+    return toupper(ascii);
+  } else if ('0' <= ascii && ascii <= '9') {
+    return ascii;
+  } else if (' ' == ascii || '\r' == ascii || '\t' == ascii ||
+             '\x1b' == ascii || '\b' == ascii) {
+    return ascii;
+  } else {
+    switch (ascii) {
+      case '!': return '1';
+      case '@': return '2';
+      case '#': return '3';
+      case '$': return '4';
+      case '%': return '5';
+      case '^': return '6';
+      case '&': return '7';
+      case '*': return '8';
+      case '(': return '9';
+      case ')': return '0';
+      case ';': case ':': return 186;
+      case '=': case '+': return 187;
+      case ',': case '<': return 188;
+      case '-': case '_': return 189;
+      case '.': case '>': return 190;
+      case '/': case '?': return 191;
+      case '`': case '~': return 192;
+      case '[': case '{': return 219;
+      case '\\': case '|': return 220;
+      case ']': case '}': return 221;
+      case '\'': case '"': return 222;
+      default:
+        break;
+    }
+  }
+  return 0;
+}
+
+// Translate browser keycode to SDLKey
+static SDLKey translateKey(uint32_t code) {
+  if (code >= 'A' && code <= 'Z')
+    return (SDLKey)(code - 'A' + SDLK_a);
+  if (code >= SDLK_0 && code <= SDLK_9)
+    return (SDLKey)code;
+  const uint32_t f1_code = 112;
+  if (code >= f1_code && code < f1_code + 12)
+    return (SDLKey)(code - f1_code + SDLK_F1);
+  const uint32_t kp0_code = 96;
+  if (code >= kp0_code && code < kp0_code + 10)
+    return (SDLKey)(code - kp0_code + SDLK_KP0);
+  switch (code) {
+    case SDLK_BACKSPACE:
+      return SDLK_BACKSPACE;
+    case SDLK_TAB:
+      return SDLK_TAB;
+    case SDLK_RETURN:
+      return SDLK_RETURN;
+    case SDLK_PAUSE:
+      return SDLK_PAUSE;
+    case SDLK_ESCAPE:
+      return SDLK_ESCAPE;
+    case 16:
+      return SDLK_LSHIFT;
+    case 17:
+      return SDLK_LCTRL;
+    case 18:
+      return SDLK_LALT;
+    case 32:
+      return SDLK_SPACE;
+    case 37:
+      return SDLK_LEFT;
+    case 38:
+      return SDLK_UP;
+    case 39:
+      return SDLK_RIGHT;
+    case 40:
+      return SDLK_DOWN;
+    case 106:
+      return SDLK_KP_MULTIPLY;
+    case 107:
+      return SDLK_KP_PLUS;
+    case 109:
+      return SDLK_KP_MINUS;
+    case 110:
+      return SDLK_KP_PERIOD;
+    case 111:
+      return SDLK_KP_DIVIDE;
+    case 45:
+      return SDLK_INSERT;
+    case 46:
+      return SDLK_DELETE;
+    case 36:
+      return SDLK_HOME;
+    case 35:
+      return SDLK_END;
+    case 33:
+      return SDLK_PAGEUP;
+    case 34:
+      return SDLK_PAGEDOWN;
+    case 189:
+      return SDLK_MINUS;
+    case 187:
+      return SDLK_EQUALS;
+    case 219:
+      return SDLK_LEFTBRACKET;
+    case 221:
+      return SDLK_RIGHTBRACKET;
+    case 186:
+      return SDLK_SEMICOLON;
+    case 222:
+      return SDLK_QUOTE;
+    case 220:
+      return SDLK_BACKSLASH;
+    case 188:
+      return SDLK_COMMA;
+    case 190:
+      return SDLK_PERIOD;
+    case 191:
+      return SDLK_SLASH;
+    case 192:
+      return SDLK_BACKQUOTE;
+    default:
+      return SDLK_UNKNOWN;
+  }
+}
+
+static SDL_Event *copyEvent(SDL_Event *event) {
+  SDL_Event *event_copy = (SDL_Event*)malloc(sizeof(SDL_Event));
+  *event_copy = *event;
+  return event_copy;
+}
+
+void SDL_NACL_PushEvent(PP_Resource input_event) {
+  static Uint8 last_scancode = 0;
+  SDL_keysym keysym;
+  static double wheel_clicks_x;
+  static double wheel_clicks_y;
+  SDL_Event event;
+  PP_InputEvent_Type type = g_nacl_input_event_interface->GetType(input_event);
+
+  if (type == PP_INPUTEVENT_TYPE_MOUSEDOWN ||
+      type == PP_INPUTEVENT_TYPE_MOUSEUP) {
+    event.type = (type == PP_INPUTEVENT_TYPE_MOUSEUP) ? SDL_MOUSEBUTTONUP
+                                                      : SDL_MOUSEBUTTONDOWN;
+    event.button.button = translateButton(
+        g_nacl_mouse_input_event_interface->GetButton(input_event));
+    PP_Point point =
+        g_nacl_mouse_input_event_interface->GetPosition(input_event);
+    event.button.x = point.x;
+    event.button.y = point.y;
+    event_queue.PushEvent(copyEvent(&event));
+  } else if (type == PP_INPUTEVENT_TYPE_WHEEL) {
+    PP_FloatPoint ticks =
+        g_nacl_wheel_input_event_interface->GetTicks(input_event);
+    wheel_clicks_x += ticks.x;
+    wheel_clicks_y += ticks.y;
+    int sdl_wheel_clicks_x = trunc(wheel_clicks_x);
+    int sdl_wheel_clicks_y = trunc(wheel_clicks_y);
+    event.button.x = event.button.y = 0;
+    event.button.button =
+        (sdl_wheel_clicks_x > 0) ? SDL_BUTTON_X1 : SDL_BUTTON_X2;
+    for (int i = 0; i < abs(sdl_wheel_clicks_x); i++) {
+      event.type = SDL_MOUSEBUTTONDOWN;
+      event_queue.PushEvent(copyEvent(&event));
+      event.type = SDL_MOUSEBUTTONUP;
+      event_queue.PushEvent(copyEvent(&event));
+    }
+    event.button.button =
+        (sdl_wheel_clicks_y > 0) ? SDL_BUTTON_WHEELUP : SDL_BUTTON_WHEELDOWN;
+    for (int i = 0; i < abs(sdl_wheel_clicks_y); i++) {
+      event.type = SDL_MOUSEBUTTONDOWN;
+      event_queue.PushEvent(copyEvent(&event));
+      event.type = SDL_MOUSEBUTTONUP;
+      event_queue.PushEvent(copyEvent(&event));
+    }
+    wheel_clicks_x -= sdl_wheel_clicks_x;
+    wheel_clicks_y -= sdl_wheel_clicks_y;
+  } else if (type == PP_INPUTEVENT_TYPE_MOUSEMOVE) {
+    event.type = SDL_MOUSEMOTION;
+    PP_Point point =
+        g_nacl_mouse_input_event_interface->GetPosition(input_event);
+    event.motion.x = point.x;
+    event.motion.y = point.y;
+    event_queue.PushEvent(copyEvent(&event));
+  } else if (type == PP_INPUTEVENT_TYPE_KEYDOWN ||
+             type == PP_INPUTEVENT_TYPE_KEYUP ||
+             type == PP_INPUTEVENT_TYPE_CHAR) {
+    // PPAPI sends us separate events for KEYDOWN and CHAR; the first one
+    // contains only the keycode, the second one - only the unicode text.
+    // SDL wants both in SDL_PRESSED event :(
+    // For now, ignore the keydown event for printable ascii (32-126) as we
+    // know we'll get a char event and can set sym directly. For everything
+    // else, risk sending an extra SDL_PRESSED with unicode text and zero
+    // keycode for scancode / sym.
+    // It seems that SDL 1.3 is better in this regard.
+    keysym.scancode =
+        g_nacl_keyboard_input_event_interface->GetKeyCode(input_event);
+    PP_Var unicode_var =
+        g_nacl_keyboard_input_event_interface->GetCharacterText(input_event);
+    uint32_t unicode_var_len;
+    keysym.unicode =
+        g_nacl_var_interface->VarToUtf8(unicode_var, &unicode_var_len)[0];
+    g_nacl_var_interface->Release(unicode_var);
+    keysym.sym = translateKey(keysym.scancode);
+    if (type == PP_INPUTEVENT_TYPE_KEYDOWN) {
+      event.type = SDL_KEYDOWN;
+      last_scancode = keysym.scancode;
+      if (keysym.sym >= ' ' &&  keysym.sym <= 126) {
+        return;
+      }
+    } else if (type == PP_INPUTEVENT_TYPE_CHAR) {
+      event.type = SDL_KEYDOWN;
+      if (keysym.sym >= ' ' &&  keysym.sym <= 126) {
+        keysym.scancode = translateAscii(keysym.unicode);
+        keysym.sym = translateKey(keysym.scancode);
+      } else if (last_scancode) {
+        keysym.scancode = last_scancode;
+        keysym.sym = translateKey(keysym.scancode);
+      }
+    } else {  // event->type == PP_INPUTEVENT_TYPE_KEYUP
+      event.type = SDL_KEYUP;
+      last_scancode = 0;
+    }
+    keysym.mod = KMOD_NONE;
+    event.key.keysym = keysym;
+    event_queue.PushEvent(copyEvent(&event));
+  } else if (type == PP_INPUTEVENT_TYPE_MOUSEENTER ||
+             type == PP_INPUTEVENT_TYPE_MOUSELEAVE) {
+    event.type = SDL_ACTIVEEVENT;
+    event.active.gain = (type == PP_INPUTEVENT_TYPE_MOUSEENTER) ? 1 : 0;
+    event.active.state = SDL_APPMOUSEFOCUS;
+    event_queue.PushEvent(copyEvent(&event));
+  }
+}
+
+void SDL_NACL_SetHasFocus(int has_focus) {
+  SDL_Event event;
+  event.type = SDL_ACTIVEEVENT;
+  event.active.gain = has_focus ? 1 : 0;
+  event.active.state = SDL_APPINPUTFOCUS;
+  event_queue.PushEvent(copyEvent(&event));
+}
+
+void SDL_NACL_SetPageVisible(int is_visible) {
+  SDL_Event event;
+  event.type = SDL_ACTIVEEVENT;
+  event.active.gain = is_visible ? 1 : 0;
+  event.active.state = SDL_APPACTIVE;
+  event_queue.PushEvent(copyEvent(&event));
+}
+
+void NACL_PumpEvents(_THIS) {
+  SDL_Event* event;
+  while (event = event_queue.PopEvent()) {
+    if (event->type == SDL_MOUSEBUTTONDOWN) {
+      SDL_PrivateMouseButton(SDL_PRESSED, event->button.button,
+                             event->button.x, event->button.y);
+    } else if (event->type == SDL_MOUSEBUTTONUP) {
+      SDL_PrivateMouseButton(SDL_RELEASED, event->button.button,
+                             event->button.x, event->button.y);
+    } else if (event->type == SDL_MOUSEMOTION) {
+      SDL_PrivateMouseMotion(0, 0, event->motion.x, event->motion.y);
+    } else if (event->type == SDL_KEYDOWN) {
+      SDL_PrivateKeyboard(SDL_PRESSED, &event->key.keysym);
+    } else if (event->type == SDL_KEYUP) {
+      SDL_PrivateKeyboard(SDL_RELEASED, &event->key.keysym);
+    } else if (event->type == SDL_ACTIVEEVENT) {
+      SDL_PrivateAppActive(event->active.gain, event->active.state);
+    }
+    free(event);
+  }
+}
+
+void NACL_InitOSKeymap(_THIS) {
+  /* do nothing. */
+}
diff -Naur SDL-1.2.15.orig/src/video/nacl/SDL_naclevents_c.h SDL-1.2.15/src/video/nacl/SDL_naclevents_c.h
--- SDL-1.2.15.orig/src/video/nacl/SDL_naclevents_c.h	1970-01-01 01:00:00.000000000 +0100
+++ SDL-1.2.15/src/video/nacl/SDL_naclevents_c.h	2014-05-06 18:00:14.353561261 +0200
@@ -0,0 +1,7 @@
+#include "SDL_config.h"
+
+#include "SDL_naclvideo.h"
+#include "SDL_nacl.h"
+
+extern void NACL_InitOSKeymap(_THIS);
+extern void NACL_PumpEvents(_THIS);
diff -Naur SDL-1.2.15.orig/src/video/nacl/SDL_naclvideo.cc SDL-1.2.15/src/video/nacl/SDL_naclvideo.cc
--- SDL-1.2.15.orig/src/video/nacl/SDL_naclvideo.cc	1970-01-01 01:00:00.000000000 +0100
+++ SDL-1.2.15/src/video/nacl/SDL_naclvideo.cc	2014-05-06 18:00:14.353561261 +0200
@@ -0,0 +1,465 @@
+#include "SDL_config.h"
+
+#include <assert.h>
+
+#include "SDL_naclvideo.h"
+#include "SDL_naclevents_c.h"
+
+#include <ppapi/c/pp_completion_callback.h>
+#include <ppapi/c/pp_errors.h>
+#include <ppapi/c/pp_instance.h>
+#include <ppapi/c/pp_point.h>
+#include <ppapi/c/pp_rect.h>
+#include <ppapi/c/pp_size.h>
+#include <ppapi/c/pp_var.h>
+#include <ppapi/c/ppb_core.h>
+#include <ppapi/c/ppb_graphics_2d.h>
+#include <ppapi/c/ppb_graphics_3d.h>
+#include <ppapi/c/ppb_image_data.h>
+#include <ppapi/c/ppb_input_event.h>
+#include <ppapi/c/ppb_instance.h>
+#include <ppapi/c/ppb_opengles2.h>
+#include <ppapi/c/ppb_var.h>
+#include <ppapi/gles2/gl2ext_ppapi.h>
+
+PP_Instance g_nacl_pp_instance;
+PPB_GetInterface g_nacl_get_interface;
+const PPB_Core_1_0 *g_nacl_core_interface;
+const PPB_Instance_1_0 *g_nacl_instance_interface;
+const PPB_ImageData_1_0 *g_nacl_image_data_interface;
+const PPB_Graphics2D_1_1 *g_nacl_graphics2d_interface;
+const PPB_Graphics3D_1_0 *g_nacl_graphics3d_interface;
+const PPB_OpenGLES2 *g_nacl_opengles2_interface;
+
+const PPB_InputEvent_1_0 *g_nacl_input_event_interface;
+const PPB_MouseInputEvent_1_1 *g_nacl_mouse_input_event_interface;
+const PPB_WheelInputEvent_1_0 *g_nacl_wheel_input_event_interface;
+const PPB_KeyboardInputEvent_1_0 *g_nacl_keyboard_input_event_interface;
+const PPB_Var_1_1 *g_nacl_var_interface;
+
+static int g_nacl_video_width;
+static int g_nacl_video_height;
+
+static int kNaClFlushDelayMs = 20;
+
+#include "SDL_nacl.h"
+
+extern "C" {
+
+#ifdef SDL_VIDEO_OPENGL_REGAL
+#include "SDL_opengl.h"
+#endif
+#include "SDL_video.h"
+#include "SDL_mouse.h"
+#include "../SDL_sysvideo.h"
+#include "../SDL_pixels_c.h"
+#include "../../events/SDL_events_c.h"
+
+#define NACLVID_DRIVER_NAME "nacl"
+
+void SDL_NACL_SetInstance(PP_Instance instance, PPB_GetInterface get_interface,
+                          int width, int height) {
+  bool is_resize = g_nacl_pp_instance && (width != g_nacl_video_width ||
+                                          height != g_nacl_video_height);
+
+  g_nacl_pp_instance = instance;
+  g_nacl_get_interface = get_interface;
+  g_nacl_core_interface =
+      (const PPB_Core_1_0 *)get_interface(PPB_CORE_INTERFACE_1_0);
+  g_nacl_instance_interface =
+      (const PPB_Instance_1_0 *)get_interface(PPB_INSTANCE_INTERFACE_1_0);
+  g_nacl_image_data_interface =
+      (const PPB_ImageData_1_0 *)get_interface(PPB_IMAGEDATA_INTERFACE_1_0);
+  g_nacl_graphics2d_interface =
+      (const PPB_Graphics2D_1_1 *)get_interface(PPB_GRAPHICS_2D_INTERFACE_1_1);
+  g_nacl_graphics3d_interface =
+      (const PPB_Graphics3D_1_0 *)get_interface(PPB_GRAPHICS_3D_INTERFACE_1_0);
+  g_nacl_opengles2_interface =
+      (const PPB_OpenGLES2 *)get_interface(PPB_OPENGLES2_INTERFACE_1_0);
+  g_nacl_input_event_interface =
+      (const PPB_InputEvent_1_0 *)get_interface(PPB_INPUT_EVENT_INTERFACE_1_0);
+  g_nacl_mouse_input_event_interface =
+      (const PPB_MouseInputEvent_1_1 *)get_interface(
+          PPB_MOUSE_INPUT_EVENT_INTERFACE_1_1);
+  g_nacl_wheel_input_event_interface =
+      (const PPB_WheelInputEvent_1_0 *)get_interface(
+          PPB_WHEEL_INPUT_EVENT_INTERFACE_1_0);
+  g_nacl_keyboard_input_event_interface =
+      (const PPB_KeyboardInputEvent_1_0 *)get_interface(
+          PPB_KEYBOARD_INPUT_EVENT_INTERFACE_1_0);
+  g_nacl_var_interface =
+      (const PPB_Var_1_1 *)get_interface(PPB_VAR_INTERFACE_1_1);
+  g_nacl_video_width = width;
+  g_nacl_video_height = height;
+  if (is_resize && current_video) {
+    current_video->hidden->ow = width;
+    current_video->hidden->oh = height;
+    SDL_PrivateResize(width, height);
+  }
+}
+
+static void flush(void *data, int32_t unused);
+
+/* Initialization/Query functions */
+static int NACL_VideoInit(_THIS, SDL_PixelFormat *vformat);
+static SDL_Rect **NACL_ListModes(_THIS, SDL_PixelFormat *format, Uint32 flags);
+static SDL_Surface *NACL_SetVideoMode(_THIS, SDL_Surface *current, int width,
+                                      int height, int bpp, Uint32 flags);
+static void NACL_VideoQuit(_THIS);
+static void NACL_UpdateRects(_THIS, int numrects, SDL_Rect *rects);
+
+#ifdef SDL_VIDEO_OPENGL_REGAL
+static int NACL_GL_GetAttribute(_THIS, SDL_GLattr attrib, int *value);
+static int NACL_GL_MakeCurrent(_THIS);
+static void NACL_GL_SwapBuffers(_THIS);
+#endif
+
+/* The implementation dependent data for the window manager cursor */
+struct WMcursor {
+  // Fake cursor data to fool SDL into not using its broken (as it seems)
+  // software cursor emulation.
+};
+
+static void NACL_FreeWMCursor(_THIS, WMcursor *cursor);
+static WMcursor *NACL_CreateWMCursor(_THIS, Uint8 *data, Uint8 *mask, int w,
+                                     int h, int hot_x, int hot_y);
+static int NACL_ShowWMCursor(_THIS, WMcursor *cursor);
+static void NACL_WarpWMCursor(_THIS, Uint16 x, Uint16 y);
+
+static int NACL_Available(void) {
+  return g_nacl_pp_instance != 0;
+}
+
+static void NACL_DeleteDevice(SDL_VideoDevice *device) {
+  SDL_free(device->hidden);
+  SDL_free(device);
+}
+
+static SDL_VideoDevice *NACL_CreateDevice(int devindex) {
+  SDL_VideoDevice *device;
+
+  assert(g_nacl_pp_instance);
+
+  /* Initialize all variables that we clean on shutdown */
+  device = (SDL_VideoDevice *)SDL_malloc(sizeof(SDL_VideoDevice));
+  if (device) {
+    SDL_memset(device, 0, (sizeof *device));
+    device->hidden =
+        (struct SDL_PrivateVideoData *)SDL_malloc((sizeof *device->hidden));
+  }
+  if (device == NULL || device->hidden == NULL) {
+    SDL_OutOfMemory();
+    if (device) {
+      SDL_free(device);
+    }
+    return 0;
+  }
+  SDL_memset(device->hidden, 0, (sizeof *device->hidden));
+
+  device->hidden->ow = g_nacl_video_width;
+  device->hidden->oh = g_nacl_video_height;
+
+  // TODO: query the fullscreen size
+
+  /* Set the function pointers */
+  device->VideoInit = NACL_VideoInit;
+  device->ListModes = NACL_ListModes;
+  device->SetVideoMode = NACL_SetVideoMode;
+  device->UpdateRects = NACL_UpdateRects;
+  device->VideoQuit = NACL_VideoQuit;
+  device->InitOSKeymap = NACL_InitOSKeymap;
+  device->PumpEvents = NACL_PumpEvents;
+
+  device->FreeWMCursor = NACL_FreeWMCursor;
+  device->CreateWMCursor = NACL_CreateWMCursor;
+  device->ShowWMCursor = NACL_ShowWMCursor;
+  device->WarpWMCursor = NACL_WarpWMCursor;
+
+#ifdef SDL_VIDEO_OPENGL_REGAL
+  device->GL_GetAttribute = NACL_GL_GetAttribute;
+  device->GL_MakeCurrent = NACL_GL_MakeCurrent;
+  device->GL_SwapBuffers = NACL_GL_SwapBuffers;
+#endif
+
+  device->free = NACL_DeleteDevice;
+
+  return device;
+}
+
+VideoBootStrap NACL_bootstrap = {
+    NACLVID_DRIVER_NAME, "SDL Native Client video driver",
+    NACL_Available, NACL_CreateDevice
+};
+
+int NACL_VideoInit(_THIS, SDL_PixelFormat *vformat) {
+  fprintf(stderr,
+          "SDL: Congratulations you are using the SDL nacl video driver!\n");
+
+  /* Determine the screen depth (use default 8-bit depth) */
+  /* we change this during the SDL_SetVideoMode implementation... */
+  vformat->BitsPerPixel = 32;
+  vformat->BytesPerPixel = 4;
+
+  _this->info.current_w = g_nacl_video_width;
+  _this->info.current_h = g_nacl_video_height;
+
+  /* We're done! */
+  return 0;
+}
+
+SDL_Rect **NACL_ListModes(_THIS, SDL_PixelFormat *format, Uint32 flags) {
+  // TODO: list modes
+  return (SDL_Rect **)-1;
+}
+
+SDL_Surface *NACL_SetVideoMode(_THIS, SDL_Surface *current, int width,
+                               int height, int bpp, Uint32 flags) {
+
+  fprintf(stderr, "SDL: setvideomode %dx%d bpp=%d opengl=%d flags=%u\n", width,
+          height, bpp, flags & SDL_OPENGL ? 1 : 0, flags);
+  fflush(stderr);
+
+  if (width > _this->hidden->ow || height > _this->hidden->oh) return NULL;
+  _this->hidden->bpp = bpp = 32;  // Let SDL handle pixel format conversion.
+  _this->hidden->w = width;
+  _this->hidden->h = height;
+
+  if (_this->hidden->context2d) {
+    g_nacl_core_interface->ReleaseResource(_this->hidden->context2d);
+    _this->hidden->context2d = 0;
+  }
+
+  if (_this->hidden->context3d) {
+    g_nacl_core_interface->ReleaseResource(_this->hidden->context3d);
+    _this->hidden->context3d = 0;
+  }
+
+  if (flags & SDL_OPENGL) {
+    int32_t attribs[] = {
+      PP_GRAPHICS3DATTRIB_ALPHA_SIZE, 8,
+      PP_GRAPHICS3DATTRIB_DEPTH_SIZE, 24,
+      PP_GRAPHICS3DATTRIB_STENCIL_SIZE, 8,
+      PP_GRAPHICS3DATTRIB_SAMPLES, 0,
+      PP_GRAPHICS3DATTRIB_SAMPLE_BUFFERS, 0,
+      PP_GRAPHICS3DATTRIB_WIDTH, width,
+      PP_GRAPHICS3DATTRIB_HEIGHT, height,
+      PP_GRAPHICS3DATTRIB_NONE
+    };
+    _this->hidden->context3d =
+        g_nacl_graphics3d_interface->Create(g_nacl_pp_instance, 0, attribs);
+
+    if (!g_nacl_instance_interface->BindGraphics(g_nacl_pp_instance,
+                                                 _this->hidden->context3d)) {
+      fprintf(stderr, "***** Couldn't bind the graphic3d context *****\n");
+      return NULL;
+    }
+  } else {
+    PP_Size size = PP_MakeSize(width, height);
+    _this->hidden->context2d = g_nacl_graphics2d_interface->Create(
+        g_nacl_pp_instance, &size, PP_FALSE /* is_always_opaque */);
+    assert(_this->hidden->context2d != 0);
+
+    if (!g_nacl_instance_interface->BindGraphics(g_nacl_pp_instance,
+                                                 _this->hidden->context2d)) {
+      fprintf(stderr, "***** Couldn't bind the graphic2d context *****\n");
+      return NULL;
+    }
+
+    if (_this->hidden->image_data) {
+      g_nacl_core_interface->ReleaseResource(_this->hidden->image_data);
+    }
+
+    _this->hidden->image_data = g_nacl_image_data_interface->Create(
+        g_nacl_pp_instance, PP_IMAGEDATAFORMAT_BGRA_PREMUL, &size,
+        PP_FALSE /* init_to_zero */);
+    assert(_this->hidden->image_data != 0);
+
+    current->pixels =
+        g_nacl_image_data_interface->Map(_this->hidden->image_data);
+  }
+
+  /* Allocate the new pixel format for the screen */
+  if (!SDL_ReallocFormat(current, bpp, 0xFF0000, 0xFF00, 0xFF, 0)) {
+    SDL_SetError("Couldn't allocate new pixel format for requested mode");
+    return NULL;
+  }
+
+  /* Set up the new mode framebuffer */
+  current->flags = flags & (SDL_FULLSCREEN | SDL_OPENGL);
+  _this->hidden->bpp = bpp;
+  _this->hidden->w = current->w = width;
+  _this->hidden->h = current->h = height;
+  current->pitch = current->w * (bpp / 8);
+
+  /* We're done */
+  return current;
+}
+
+static void NACL_UpdateRects(_THIS, int numrects, SDL_Rect *rects) {
+  if (_this->hidden->context2d == 0)  // not initialized
+    return;
+
+  assert(_this->hidden->image_data);
+  assert(_this->hidden->w > 0);
+  assert(_this->hidden->h > 0);
+
+  // Clear alpha channel in the ImageData.
+  unsigned char *start = (unsigned char*)_this->screen->pixels;
+  unsigned char *end =
+      start + (_this->hidden->w * _this->hidden->h * _this->hidden->bpp / 8);
+  for (unsigned char *p = start + 3; p < end; p += 4) *p = 0xFF;
+
+  // Flush on the main thread.
+  for (int i = 0; i < numrects; ++i) {
+    SDL_Rect &r = rects[i];
+    PP_Point top_left = PP_MakePoint(0, 0);
+    PP_Rect src_rect = PP_MakeRectFromXYWH(r.x, r.y, r.w, r.h);
+    g_nacl_graphics2d_interface->PaintImageData(_this->hidden->context2d,
+                                                _this->hidden->image_data,
+                                                &top_left, &src_rect);
+  }
+
+  g_nacl_graphics2d_interface->Flush(_this->hidden->context2d,
+                                     PP_BlockUntilComplete());
+}
+
+static void NACL_FreeWMCursor(_THIS, WMcursor *cursor) {
+  delete cursor;
+}
+
+static WMcursor *NACL_CreateWMCursor(_THIS, Uint8 *data, Uint8 *mask, int w,
+                                     int h, int hot_x, int hot_y) {
+  return new WMcursor();
+}
+
+static int NACL_ShowWMCursor(_THIS, WMcursor *cursor) {
+  return 1;  // Success!
+}
+
+static void NACL_WarpWMCursor(_THIS, Uint16 x, Uint16 y) {}
+
+/* Note:  If we are terminated, this could be called in the middle of
+   another SDL video routine -- notably UpdateRects.
+*/
+void NACL_VideoQuit(_THIS) {
+  if (_this->hidden->context2d) {
+    g_nacl_core_interface->ReleaseResource(_this->hidden->context2d);
+    _this->hidden->context2d = 0;
+  }
+
+  if (_this->hidden->context3d) {
+    g_nacl_core_interface->ReleaseResource(_this->hidden->context3d);
+    _this->hidden->context3d = 0;
+  }
+
+  if (_this->hidden->image_data) {
+    g_nacl_image_data_interface->Unmap(_this->hidden->image_data);
+    g_nacl_core_interface->ReleaseResource(_this->hidden->image_data);
+    _this->hidden->image_data = 0;
+  }
+
+  // No need to free pixels as this is a pointer directly to
+  // the pixel data within the image_data.
+  _this->screen->pixels = NULL;
+}
+
+#ifdef SDL_VIDEO_OPENGL_REGAL
+static void regalLogCallback(GLenum stream, GLsizei length,
+                             const GLchar *message, GLvoid *context) {
+  fprintf(stderr, "regal: %s\n", message);
+}
+
+static int NACL_GL_GetAttribute(_THIS, SDL_GLattr attrib, int *value) {
+  int unsupported = 0;
+  int nacl_attrib = 0;
+
+  switch (attrib) {
+    case SDL_GL_RED_SIZE:
+      nacl_attrib = PP_GRAPHICS3DATTRIB_RED_SIZE;
+      break;
+    case SDL_GL_GREEN_SIZE:
+      nacl_attrib = PP_GRAPHICS3DATTRIB_GREEN_SIZE;
+      break;
+    case SDL_GL_BLUE_SIZE:
+      nacl_attrib = PP_GRAPHICS3DATTRIB_BLUE_SIZE;
+      break;
+    case SDL_GL_ALPHA_SIZE:
+      nacl_attrib = PP_GRAPHICS3DATTRIB_ALPHA_SIZE;
+      break;
+    case SDL_GL_DEPTH_SIZE:
+      nacl_attrib = PP_GRAPHICS3DATTRIB_DEPTH_SIZE;
+      break;
+    case SDL_GL_STENCIL_SIZE:
+      nacl_attrib = PP_GRAPHICS3DATTRIB_STENCIL_SIZE;
+      break;
+    case SDL_GL_MULTISAMPLEBUFFERS:
+      nacl_attrib = PP_GRAPHICS3DATTRIB_SAMPLE_BUFFERS;
+      break;
+    case SDL_GL_MULTISAMPLESAMPLES:
+      nacl_attrib = PP_GRAPHICS3DATTRIB_SAMPLES;
+      break;
+    // The rest of the these attributes are not part of PPAPI
+    case SDL_GL_DOUBLEBUFFER:
+    case SDL_GL_BUFFER_SIZE:
+    case SDL_GL_ACCUM_RED_SIZE:
+    case SDL_GL_ACCUM_GREEN_SIZE:
+    case SDL_GL_ACCUM_BLUE_SIZE:
+    case SDL_GL_ACCUM_ALPHA_SIZE:
+    case SDL_GL_STEREO:
+    case SDL_GL_ACCELERATED_VISUAL:
+    case SDL_GL_SWAP_CONTROL:
+    default:
+      unsupported = 1;
+      break;
+  }
+
+  if (unsupported) {
+    SDL_SetError("OpenGL attribute is unsupported by NaCl: %d", attrib);
+    return -1;
+  }
+
+  int32_t attribs[] = {nacl_attrib, 0, PP_GRAPHICS3DATTRIB_NONE, };
+
+  int retval = g_nacl_graphics3d_interface->GetAttribs(_this->hidden->context3d,
+                                                       attribs);
+  if (retval != PP_OK) {
+    // TODO(sbc): GetAttribs seems to always return PP_ERROR_FAILED(-2).
+    // fprintf(stderr, "SDL: GetAttribs failed %#x -> %d\n", nacl_attrib,
+    // retval);
+    SDL_SetError("Error getting OpenGL attribute (%d) from NaCl: %d", attrib,
+                 retval);
+    return -1;
+  }
+
+  *value = attribs[1];
+  return 0;
+}
+
+static int NACL_GL_MakeCurrent(_THIS) {
+  if (!_this->hidden->context3d) {
+    assert(_this->hidden->context3d);
+    SDL_SetError("GL_MakeCurrent called without an OpenGL video mode set");
+    return -1;
+  }
+  fprintf(stderr, "SDL: making GL context current\n");
+  glSetCurrentContextPPAPI(_this->hidden->context3d);
+
+  RegalMakeCurrent(_this->hidden->context3d,
+                   (PPB_OpenGLES2 *)g_nacl_opengles2_interface);
+  glLogMessageCallbackREGAL(regalLogCallback);
+  return 0;
+}
+
+static void NACL_GL_SwapBuffers(_THIS) {
+  if (!_this->hidden->context3d) {
+    assert(_this->hidden->context3d);
+    fprintf(stderr,
+            "SDL: GL_SwapBuffers called without an OpenGL video mode set\n");
+    return;
+  }
+  g_nacl_graphics3d_interface->SwapBuffers(_this->hidden->context3d,
+                                           PP_BlockUntilComplete());
+}
+#endif
+
+}  // extern "C"
diff -Naur SDL-1.2.15.orig/src/video/nacl/SDL_naclvideo.h SDL-1.2.15/src/video/nacl/SDL_naclvideo.h
--- SDL-1.2.15.orig/src/video/nacl/SDL_naclvideo.h	1970-01-01 01:00:00.000000000 +0100
+++ SDL-1.2.15/src/video/nacl/SDL_naclvideo.h	2014-05-06 18:00:14.353561261 +0200
@@ -0,0 +1,36 @@
+#include "SDL_config.h"
+
+#ifndef _SDL_naclvideo_h
+#define _SDL_naclvideo_h
+
+extern "C" {
+#include "../SDL_sysvideo.h"
+#include "SDL_mutex.h"
+}
+
+#include <ppapi/cpp/instance.h>
+#include <ppapi/cpp/graphics_2d.h>
+#include <ppapi/cpp/graphics_3d.h>
+#include <vector>
+
+
+/* Hidden "this" pointer for the video functions */
+#define _THIS	SDL_VideoDevice *_this
+
+
+/* Private display data */
+
+struct SDL_PrivateVideoData {
+  int bpp;
+  int w, h;
+  void *buffer;
+
+  int ow, oh; // plugin output dimensions
+  int fsw, fsh; // fullscreen dimensions
+
+  PP_Resource image_data;
+  PP_Resource context2d;  // The PPAPI 2D drawing context.
+  PP_Resource context3d;  // The PPAPI 3D drawing context.
+};
+
+#endif /* _SDL_naclvideo_h */
diff -Naur SDL-1.2.15.orig/src/video/SDL_sysvideo.h SDL-1.2.15/src/video/SDL_sysvideo.h
--- SDL-1.2.15.orig/src/video/SDL_sysvideo.h	2012-01-19 07:30:06.000000000 +0100
+++ SDL-1.2.15/src/video/SDL_sysvideo.h	2014-05-06 18:00:14.353561261 +0200
@@ -317,6 +317,9 @@
 	SDL_VideoDevice *(*create)(int devindex);
 } VideoBootStrap;
 
+#if SDL_VIDEO_DRIVER_NACL
+extern VideoBootStrap NACL_bootstrap;
+#endif
 #if SDL_VIDEO_DRIVER_QUARTZ
 extern VideoBootStrap QZ_bootstrap;
 #endif
diff -Naur SDL-1.2.15.orig/src/video/SDL_video.c SDL-1.2.15/src/video/SDL_video.c
--- SDL-1.2.15.orig/src/video/SDL_video.c	2012-01-19 07:30:06.000000000 +0100
+++ SDL-1.2.15/src/video/SDL_video.c	2014-05-06 18:00:14.356894594 +0200
@@ -33,6 +33,9 @@
 
 /* Available video drivers */
 static VideoBootStrap *bootstrap[] = {
+#if SDL_VIDEO_DRIVER_NACL
+	&NACL_bootstrap,
+#endif
 #if SDL_VIDEO_DRIVER_QUARTZ
 	&QZ_bootstrap,
 #endif
@@ -772,6 +775,8 @@
 #define __SDL_NOGETPROCADDR__
 #elif defined(__MINT__)
 #define __SDL_NOGETPROCADDR__
+#elif defined(__native_client__)
+#define __SDL_NOGETPROCADDR__
 #endif
 #ifdef __SDL_NOGETPROCADDR__
     #define SDL_PROC(ret,func,params) video->func=func;
