diff -Naur openal-soft-1.16.0.orig/Alc/ALc.c openal-soft-1.16.0/Alc/ALc.c
--- openal-soft-1.16.0.orig/Alc/ALc.c	2014-08-15 09:06:59.000000000 +0200
+++ openal-soft-1.16.0/Alc/ALc.c	2014-12-07 04:16:28.814302855 +0100
@@ -23,7 +23,7 @@
 #include <math.h>
 #include <stdlib.h>
 #include <stdio.h>
-#include <memory.h>
+#include <string.h>
 #include <ctype.h>
 #include <signal.h>
 
@@ -97,6 +97,9 @@
 #ifdef HAVE_OPENSL
     { "opensl", NULL, alc_opensl_init, alc_opensl_deinit, alc_opensl_probe, EmptyFuncs },
 #endif
+#ifdef HAVE_PPAPI
+    { "ppapi", NULL, alc_ppapi_init, alc_ppapi_deinit, alc_ppapi_probe, EmptyFuncs },
+#endif
 
     { "null", ALCnullBackendFactory_getFactory, NULL, NULL, NULL, EmptyFuncs },
 #ifdef HAVE_WAVE
diff -Naur openal-soft-1.16.0.orig/Alc/ALu.c openal-soft-1.16.0/Alc/ALu.c
--- openal-soft-1.16.0.orig/Alc/ALu.c	2014-08-15 09:06:59.000000000 +0200
+++ openal-soft-1.16.0/Alc/ALu.c	2014-12-07 16:23:03.787207305 +0100
@@ -216,7 +216,7 @@
     };
 
     ALCdevice *Device = ALContext->Device;
-    const ALsource *ALSource = src->Source;
+    ALsource *ALSource = src->Source;
     ALfloat SourceVolume,ListenerGain,MinVolume,MaxVolume;
     ALbufferlistitem *BufferListItem;
     enum FmtChannels Channels;
@@ -566,7 +566,7 @@
 ALvoid CalcSourceParams(ALactivesource *src, const ALCcontext *ALContext)
 {
     ALCdevice *Device = ALContext->Device;
-    const ALsource *ALSource = src->Source;
+    ALsource *ALSource = src->Source;
     ALfloat Velocity[3],Direction[3],Position[3],SourceToListener[3];
     ALfloat InnerAngle,OuterAngle,Angle,Distance,ClampedDist;
     ALfloat MinVolume,MaxVolume,MinDist,MaxDist,Rolloff;
diff -Naur openal-soft-1.16.0.orig/Alc/backends/ppapi.c openal-soft-1.16.0/Alc/backends/ppapi.c
--- openal-soft-1.16.0.orig/Alc/backends/ppapi.c	1970-01-01 01:00:00.000000000 +0100
+++ openal-soft-1.16.0/Alc/backends/ppapi.c	2014-12-07 04:16:28.814302855 +0100
@@ -0,0 +1,320 @@
+/**
+ * OpenAL cross platform audio library
+ * Copyright (C) 2012
+ * This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Library General Public
+ *  License as published by the Free Software Foundation; either
+ *  version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ *  License along with this library; if not, write to the
+ *  Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ *  Boston, MA  02111-1307, USA.
+ * Or go to http://www.gnu.org/copyleft/lgpl.html
+ */
+
+#include "config.h"
+
+#include <stdlib.h>
+#include <time.h>
+#include "alMain.h"
+#include "alu.h"
+
+#include "ppapi/c/pp_completion_callback.h"
+#include "ppapi/c/pp_instance.h"
+#include "ppapi/c/ppb.h"
+#include "ppapi/c/ppb_audio.h"
+#include "ppapi/c/ppb_audio_config.h"
+#include "ppapi/c/ppb_core.h"
+
+/* The output buffer will be this multiple of the OpenAL device update size.
+ * This needs to be at least 2 or we can't buffer output properly.
+ */
+const ALuint kBufferPadMult = 4;
+/* How many samples for each frame will be buffered to Pepper.
+ * Keep this low for low latency, but not too low or we will be CPU bound.
+ */
+const ALuint kRequestedFrameCount = 1024;
+/* 4 is 2-channels, 2-bytes per sample. */
+const ALuint kFrameSizeInBytes = 4;
+
+const struct timespec kMillisecond = { 0, 1000000 };
+
+typedef struct {
+    /* Simple circular buffer (single producer/consumer) to buffer data output
+     * from OpenAL before it's handed off to PPAPI.
+     */
+    ALvoid *buffer;
+    ALuint size;
+
+    PPB_AudioConfig* audio_config;
+    PPB_Audio* audio;
+    PPB_Core* core;
+
+    PP_Resource audio_config_resource;
+    PP_Resource audio_resource;
+    ALuint sample_frame_count;
+
+    ALCdevice *device;
+
+    volatile ALint main_thread_init_status;
+    ALuint buffer_ready;
+} ppapi_data;
+
+static PP_Instance gInstance;
+static PPB_GetInterface gGetInterface;
+
+AL_API void AL_APIENTRY alSetPpapiInfo(PP_Instance instance, PPB_GetInterface get_interface)
+{
+    gInstance = instance;
+    gGetInterface = get_interface;
+}
+
+/* This is the callback from PPAPI to fill in the audio buffer. */
+void PPAPI_Audio_Callback(void *buffer,
+                          uint32_t size,
+                          PP_TimeDelta latency,
+                          void* user_data)
+{
+  ppapi_data *data = (ppapi_data*)user_data;
+  (void)size;
+  (void)latency;
+
+  if(data->buffer_ready)
+      aluMixData(data->device, buffer, data->sample_frame_count);
+}
+
+static const ALCchar ppapiDevice[] = "PPAPI Output";
+
+/* This needs to be called on the main PPAPI thread. */
+static void ppapi_open_playback_main_thread(void* user_data, int32_t result)
+{
+    ppapi_data *data = (ppapi_data*)user_data;
+    (void)result;
+
+    PP_AudioSampleRate rate = PP_AUDIOSAMPLERATE_44100;
+    if (data->device->Frequency == 48000)
+        rate = PP_AUDIOSAMPLERATE_48000;
+
+    data->sample_frame_count =
+        data->audio_config->RecommendSampleFrameCount(gInstance,
+                                                      rate,
+                                                      kRequestedFrameCount);
+
+    data->audio_config_resource =
+        data->audio_config->CreateStereo16Bit(gInstance,
+                                              rate,
+                                              data->sample_frame_count);
+
+    if (PP_FALSE == data->audio_config->IsAudioConfig(data->audio_config_resource)) {
+        ERR("PPAPI initialization: audio config creation failed.\n");
+        data->main_thread_init_status = -1;
+        return;
+    }
+
+    data->audio_resource = data->audio->Create(gInstance,
+                                               data->audio_config_resource,
+                                               PPAPI_Audio_Callback,
+                                               (void*)data);
+
+    if (PP_FALSE == data->audio->IsAudio(data->audio_resource)) {
+        ERR("PPAPI initialization: audio resource creation failed.\n");
+        data->main_thread_init_status = -1;
+        return;
+    }
+
+    if (PP_FALSE == data->audio->StartPlayback(data->audio_resource)) {
+        ERR("PPAPI initialization: start playback failed.\n");
+        data->main_thread_init_status = -1;
+        return;
+    }
+
+    data->main_thread_init_status = 1;
+}
+
+static ALCenum ppapi_open_playback(ALCdevice *device, const ALCchar *deviceName)
+{
+    ppapi_data *data;
+
+    if(!deviceName)
+        deviceName = ppapiDevice;
+    else if(strcmp(deviceName, ppapiDevice) != 0)
+        return ALC_INVALID_VALUE;
+
+    ALuint channels = ChannelsFromDevFmt(device->FmtChans);
+    ALuint bytes = BytesFromDevFmt(device->FmtType);
+
+    if (channels != 2)
+    {
+        ERR("PPAPI only supports 2 channel output\n");
+        return ALC_INVALID_VALUE;
+    }
+    if (bytes != 2)
+    {
+        ERR("PPAPI only supports 16-bit output\n");
+        return ALC_INVALID_VALUE;
+    }
+    if (device->Frequency != 44100 && device->Frequency != 48000)
+    {
+        ERR("PPAPI only supports 44100 and 48000 sample frequencies\n");
+        return ALC_INVALID_VALUE;
+    }
+
+    data = (ppapi_data*)calloc(1, sizeof(*data));
+    if (!data)
+      return ALC_OUT_OF_MEMORY;
+
+    al_string_copy_cstr(&device->DeviceName, deviceName);
+    device->ExtraData = data;
+    data->device = device;
+
+    data->audio_config =
+        (PPB_AudioConfig*)gGetInterface(PPB_AUDIO_CONFIG_INTERFACE);
+    if (!data->audio_config)
+    {
+        free(data);
+        return ALC_INVALID_VALUE;
+    }
+
+    data->audio = (PPB_Audio*)gGetInterface(PPB_AUDIO_INTERFACE);
+    if (!data->audio)
+    {
+        free(data);
+        return ALC_INVALID_VALUE;
+    }
+
+    data->core = (PPB_Core*)gGetInterface(PPB_CORE_INTERFACE);
+    if (!data->core)
+    {
+        free(data);
+        return ALC_INVALID_VALUE;
+    }
+
+    if (data->core->IsMainThread()) {
+        ppapi_open_playback_main_thread(data, 0);
+    } else {
+        struct PP_CompletionCallback cb =
+            PP_MakeCompletionCallback(ppapi_open_playback_main_thread, data);
+        data->core->CallOnMainThread(0, cb, 0);
+
+        while (data->main_thread_init_status == 0)
+            nanosleep(&kMillisecond, NULL);
+    }
+
+    if (data->main_thread_init_status < 0) {
+        free(data);
+        return ALC_INVALID_VALUE;
+    }
+    return ALC_NO_ERROR;
+}
+
+/* This needs to be called on the main PPAPI thread. */
+static void ppapi_close_playback_main_thread(void* user_data, int32_t result)
+{
+    ppapi_data *data = (ppapi_data*)user_data;
+    (void)result;
+
+    data->audio->StopPlayback(data->audio_resource);
+
+    data->core->ReleaseResource(data->audio_resource);
+    data->core->ReleaseResource(data->audio_config_resource);
+
+    if (data->buffer)
+      free(data->buffer);
+    free(data);
+}
+
+static void ppapi_close_playback(ALCdevice *device)
+{
+    ppapi_data *data = (ppapi_data*)device->ExtraData;
+
+    if (data->core->IsMainThread()) {
+        ppapi_close_playback_main_thread(data, 0);
+    } else {
+        struct PP_CompletionCallback cb =
+            PP_MakeCompletionCallback(ppapi_close_playback_main_thread, data);
+        data->core->CallOnMainThread(0, cb, 0);
+    }
+
+    device->ExtraData = NULL;
+}
+
+static ALCboolean ppapi_reset_playback(ALCdevice *device)
+{
+    ppapi_data *data = (ppapi_data*)device->ExtraData;
+
+    ALuint UpdateSizeInBytes = device->UpdateSize * kFrameSizeInBytes;
+    /* kBufferPadMult is added to protect against buffer underruns. */
+    data->size = UpdateSizeInBytes * kBufferPadMult;
+    /* Extra UpdateSize added so we can read off the end of the buffer in one
+     * shot from aluMixData, but treat the buffer like it's of size data->size.
+     */
+    data->buffer = calloc(1, data->size + UpdateSizeInBytes);
+    if(!data->buffer)
+    {
+        ERR("buffer malloc failed\n");
+        return ALC_FALSE;
+    }
+    SetDefaultWFXChannelOrder(device);
+
+    data->buffer_ready = 1;
+    return ALC_TRUE;
+}
+
+static ALCboolean ppapi_start_playback(ALCdevice *device)
+{
+  (void) device;
+  return ALC_TRUE;
+}
+
+static void ppapi_stop_playback(ALCdevice *device)
+{
+    ppapi_data *data = (ppapi_data*)device->ExtraData;
+
+    data->buffer_ready = 0;
+    free(data->buffer);
+    data->buffer = NULL;
+}
+
+static ALCenum ppapi_open_capture(ALCdevice *device, const ALCchar *deviceName)
+{
+    (void)device;
+    (void)deviceName;
+    return ALC_INVALID_VALUE;
+}
+
+static const BackendFuncs ppapi_funcs = {
+    ppapi_open_playback,
+    ppapi_close_playback,
+    ppapi_reset_playback,
+    ppapi_start_playback,
+    ppapi_stop_playback,
+    ppapi_open_capture,
+    NULL,
+    NULL,
+    NULL,
+    NULL,
+    NULL,
+    ALCdevice_GetLatencyDefault
+};
+
+ALCboolean alc_ppapi_init(BackendFuncs *func_list)
+{
+    *func_list = ppapi_funcs;
+    return 1;
+}
+
+void alc_ppapi_deinit(void)
+{
+}
+
+void alc_ppapi_probe(enum DevProbe type)
+{
+    if(type == ALL_DEVICE_PROBE)
+        AppendAllDevicesList(ppapiDevice);
+}
diff -Naur openal-soft-1.16.0.orig/Alc/backends/wave.c openal-soft-1.16.0/Alc/backends/wave.c
--- openal-soft-1.16.0.orig/Alc/backends/wave.c	2014-08-15 09:06:59.000000000 +0200
+++ openal-soft-1.16.0/Alc/backends/wave.c	2014-12-07 04:16:28.814302855 +0100
@@ -22,7 +22,7 @@
 
 #include <stdlib.h>
 #include <stdio.h>
-#include <memory.h>
+#include <string.h>
 #include <errno.h>
 #ifdef HAVE_WINDOWS_H
 #include <windows.h>
diff -Naur openal-soft-1.16.0.orig/CMakeLists.txt openal-soft-1.16.0/CMakeLists.txt
--- openal-soft-1.16.0.orig/CMakeLists.txt	2014-08-15 09:06:59.000000000 +0200
+++ openal-soft-1.16.0/CMakeLists.txt	2014-12-07 04:16:28.814302855 +0100
@@ -613,6 +613,7 @@
 SET(HAVE_PULSEAUDIO 0)
 SET(HAVE_COREAUDIO  0)
 SET(HAVE_OPENSL     0)
+SET(HAVE_PPAPI      0)
 SET(HAVE_WAVE       0)
 
 # Check for SSE support
@@ -976,6 +977,22 @@
     MESSAGE(FATAL_ERROR "Failed to enabled required OpenSL backend")
 ENDIF()
 
+# Check PPAPI backend
+OPTION(ALSOFT_REQUIRE_PPAPI "Require PPAPI backend" OFF)
+CHECK_INCLUDE_FILE("ppapi/c/ppb_audio.h" HAVE_PPAPI_PPB_AUDIO_H)
+IF (HAVE_PPAPI_PPB_AUDIO_H)
+    OPTION(ALSOFT_BACKEND_PPAPI "Enable PPAPI backend" ON)
+    IF(ALSOFT_BACKEND_PPAPI)
+      SET(HAVE_PPAPI 1)
+      SET(ALC_OBJS ${ALC_OBJS} Alc/backends/ppapi.c)
+      SET(BACKENDS "${BACKENDS} PPAPI,")
+      SET(EXTRA_LIBS ppapi ${EXTRA_LIBS})
+    ENDIF()
+ENDIF()
+IF(ALSOFT_REQUIRE_PPAPI AND NOT HAVE_PPAPI)
+    MESSAGE(FATAL_ERROR "Failed to enabled required PPAPI backend")
+ENDIF()
+
 # Optionally enable the Wave Writer backend
 OPTION(ALSOFT_BACKEND_WAVE "Enable Wave Writer backend" ON)
 IF(ALSOFT_BACKEND_WAVE)
@@ -1030,7 +1047,7 @@
 ADD_LIBRARY(common STATIC ${COMMON_OBJS})
 
 # Build main library
-ADD_LIBRARY(${LIBNAME} ${LIBTYPE} ${OPENAL_OBJS} ${ALC_OBJS})
+ADD_LIBRARY(${LIBNAME} ${LIBTYPE} ${OPENAL_OBJS} ${ALC_OBJS} ${COMMON_OBJS})
 SET_PROPERTY(TARGET ${LIBNAME} APPEND PROPERTY COMPILE_DEFINITIONS AL_BUILD_LIBRARY AL_ALEXT_PROTOTYPES)
 IF(WIN32 AND ALSOFT_NO_UID_DEFS)
     SET_PROPERTY(TARGET ${LIBNAME} APPEND PROPERTY COMPILE_DEFINITIONS AL_NO_UID_DEFS)
diff -Naur openal-soft-1.16.0.orig/common/atomic.c openal-soft-1.16.0/common/atomic.c
--- openal-soft-1.16.0.orig/common/atomic.c	2014-08-15 09:06:59.000000000 +0200
+++ openal-soft-1.16.0/common/atomic.c	2014-12-07 16:17:28.244652049 +0100
@@ -9,5 +9,5 @@
 extern inline uint IncrementRef(RefCount *ptr);
 extern inline uint DecrementRef(RefCount *ptr);
 
-extern inline int ExchangeInt(volatile int *ptr, int newval);
+extern inline int ExchangeInt(_Atomic int *ptr, int newval);
 extern inline void *ExchangePtr(XchgPtr *ptr, void *newval);
diff -Naur openal-soft-1.16.0.orig/config.h.in openal-soft-1.16.0/config.h.in
--- openal-soft-1.16.0.orig/config.h.in	2014-08-15 09:06:59.000000000 +0200
+++ openal-soft-1.16.0/config.h.in	2014-12-07 04:16:28.814302855 +0100
@@ -70,6 +70,9 @@
 /* Define if we have the OpenSL backend */
 #cmakedefine HAVE_OPENSL
 
+/* Define if we have the PPAPI backend */
+#cmakedefine HAVE_PPAPI
+
 /* Define if we have the Wave Writer backend */
 #cmakedefine HAVE_WAVE
 
diff -Naur openal-soft-1.16.0.orig/include/atomic.h openal-soft-1.16.0/include/atomic.h
--- openal-soft-1.16.0.orig/include/atomic.h	2014-08-15 09:06:59.000000000 +0200
+++ openal-soft-1.16.0/include/atomic.h	2014-12-07 16:27:28.013326214 +0100
@@ -8,14 +8,14 @@
 extern "C" {
 #endif
 
-typedef void *volatile XchgPtr;
+typedef void *_Atomic XchgPtr;
 
 /* Atomics using C11 */
 #ifdef HAVE_C11_ATOMIC
 
 #include <stdatomic.h>
 
-inline int ExchangeInt(volatile int *ptr, int newval)
+inline int ExchangeInt(_Atomic int *ptr, int newval)
 { return atomic_exchange(ptr, newval); }
 inline void *ExchangePtr(XchgPtr *ptr, void *newval)
 { return atomic_exchange(ptr, newval); }
diff -Naur openal-soft-1.16.0.orig/OpenAL32/alSource.c openal-soft-1.16.0/OpenAL32/alSource.c
--- openal-soft-1.16.0.orig/OpenAL32/alSource.c	2014-08-15 09:06:59.000000000 +0200
+++ openal-soft-1.16.0/OpenAL32/alSource.c	2014-12-07 16:24:42.703662445 +0100
@@ -53,9 +53,9 @@
 extern inline struct ALsource *RemoveSource(ALCcontext *context, ALuint id);
 
 static ALvoid InitSourceParams(ALsource *Source);
-static ALint64 GetSourceOffset(const ALsource *Source);
-static ALdouble GetSourceSecOffset(const ALsource *Source);
-static ALvoid GetSourceOffsets(const ALsource *Source, ALenum name, ALdouble *offsets, ALdouble updateLen);
+static ALint64 GetSourceOffset(ALsource *Source);
+static ALdouble GetSourceSecOffset(ALsource *Source);
+static ALvoid GetSourceOffsets(ALsource *Source, ALenum name, ALdouble *offsets, ALdouble updateLen);
 static ALint GetSampleOffset(ALsource *Source);
 
 typedef enum SrcFloatProp {
@@ -2574,7 +2574,7 @@
  * samples. The offset is relative to the start of the queue (not the start of
  * the current buffer).
  */
-static ALint64 GetSourceOffset(const ALsource *Source)
+static ALint64 GetSourceOffset(ALsource *Source)
 {
     const ALbufferlistitem *BufferList;
     const ALbufferlistitem *Current;
@@ -2604,7 +2604,7 @@
  * Gets the current read offset for the given Source, in seconds. The offset is
  * relative to the start of the queue (not the start of the current buffer).
  */
-static ALdouble GetSourceSecOffset(const ALsource *Source)
+static ALdouble GetSourceSecOffset(ALsource *Source)
 {
     const ALbufferlistitem *BufferList;
     const ALbufferlistitem *Current;
@@ -2647,7 +2647,7 @@
  * appropriate format (Bytes, Samples or Seconds). The offsets are relative to
  * the start of the queue (not the start of the current buffer).
  */
-static ALvoid GetSourceOffsets(const ALsource *Source, ALenum name, ALdouble *offset, ALdouble updateLen)
+static ALvoid GetSourceOffsets(ALsource *Source, ALenum name, ALdouble *offset, ALdouble updateLen)
 {
     const ALbufferlistitem *BufferList;
     const ALbufferlistitem *Current;
diff -Naur openal-soft-1.16.0.orig/OpenAL32/Include/alMain.h openal-soft-1.16.0/OpenAL32/Include/alMain.h
--- openal-soft-1.16.0.orig/OpenAL32/Include/alMain.h	2014-08-15 09:06:59.000000000 +0200
+++ openal-soft-1.16.0/OpenAL32/Include/alMain.h	2014-12-07 04:16:28.817636196 +0100
@@ -271,7 +271,7 @@
 #define U64(x) ((ALuint64)(x##ui64))
 #elif SIZEOF_LONG == 8
 #define U64(x) ((ALuint64)(x##ul))
-#elif SIZEOF_LONG_LONG == 8
+#elif SIZEOF_LONG_LONG == 8 || defined(__native_client__)
 #define U64(x) ((ALuint64)(x##ull))
 #endif
 #endif
@@ -497,6 +497,9 @@
 ALCboolean alc_opensl_init(BackendFuncs *func_list);
 void alc_opensl_deinit(void);
 void alc_opensl_probe(enum DevProbe type);
+ALCboolean alc_ppapi_init(BackendFuncs *func_list);
+void alc_ppapi_deinit(void);
+void alc_ppapi_probe(enum DevProbe type);
 ALCboolean alc_qsa_init(BackendFuncs *func_list);
 void alc_qsa_deinit(void);
 void alc_qsa_probe(enum DevProbe type);
@@ -549,7 +552,11 @@
     DevFmtUInt   = ALC_UNSIGNED_INT_SOFT,
     DevFmtFloat  = ALC_FLOAT_SOFT,
 
+#ifdef __native_client__
+    DevFmtTypeDefault = DevFmtShort
+#else
     DevFmtTypeDefault = DevFmtFloat
+#endif
 };
 enum DevFmtChannels {
     DevFmtMono   = ALC_MONO_SOFT,
