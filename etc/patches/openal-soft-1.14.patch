diff -Naur openal-soft-1.14/Alc/ALc.c openal-soft-1.14-nacl/Alc/ALc.c
--- openal-soft-1.14/Alc/ALc.c	2012-03-28 17:55:17.000000000 +0200
+++ openal-soft-1.14-nacl/Alc/ALc.c	2012-10-13 21:31:49.310818518 +0200
@@ -23,7 +23,7 @@
 #include <math.h>
 #include <stdlib.h>
 #include <stdio.h>
-#include <memory.h>
+#include <string.h>
 #include <ctype.h>
 #include <signal.h>
 
@@ -75,7 +75,9 @@
 #ifdef HAVE_OPENSL
     { "opensl", alc_opensl_init, alc_opensl_deinit, alc_opensl_probe, EmptyFuncs },
 #endif
-
+#ifdef HAVE_PPAPI
+    { "ppapi", alc_ppapi_init, alc_ppapi_deinit, alc_ppapi_probe, EmptyFuncs },
+#endif
     { "null", alc_null_init, alc_null_deinit, alc_null_probe, EmptyFuncs },
 #ifdef HAVE_WAVE
     { "wave", alc_wave_init, alc_wave_deinit, alc_wave_probe, EmptyFuncs },
diff -Naur openal-soft-1.14/Alc/backends/opensl.c openal-soft-1.14-nacl/Alc/backends/opensl.c
--- openal-soft-1.14/Alc/backends/opensl.c	2012-03-28 17:55:17.000000000 +0200
+++ openal-soft-1.14-nacl/Alc/backends/opensl.c	2012-10-13 21:41:19.173844577 +0200
@@ -152,9 +152,11 @@
         case SL_RESULT_UNKNOWN_ERROR: return "Unknown error";
         case SL_RESULT_OPERATION_ABORTED: return "Operation aborted";
         case SL_RESULT_CONTROL_LOST: return "Control lost";
+#ifndef __ANDROID__
         case SL_RESULT_READONLY: return "ReadOnly";
         case SL_RESULT_ENGINEOPTION_UNSUPPORTED: return "Engine option unsupported";
         case SL_RESULT_SOURCE_SINK_INCOMPATIBLE: return "Source/Sink incompatible";
+#endif
     }
     return "Unknown error code";
 }
@@ -293,7 +295,13 @@
     format_pcm.bitsPerSample = BytesFromDevFmt(Device->FmtType) * 8;
     format_pcm.containerSize = format_pcm.bitsPerSample;
     format_pcm.channelMask = GetChannelMask(Device->FmtChans);
+#if defined( __ANDROID__ ) && __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
+    format_pcm.endianness = SL_BYTEORDER_BIGENDIAN;
+#elif defined( __ANDROID__ ) && __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
+    format_pcm.endianness = SL_BYTEORDER_LITTLEENDIAN;
+#else
     format_pcm.endianness = SL_BYTEORDER_NATIVE;
+#endif
 
     audioSrc.pLocator = &loc_bufq;
     audioSrc.pFormat = &format_pcm;
diff -Naur openal-soft-1.14/Alc/backends/ppapi.c openal-soft-1.14-nacl/Alc/backends/ppapi.c
--- openal-soft-1.14/Alc/backends/ppapi.c	1970-01-01 01:00:00.000000000 +0100
+++ openal-soft-1.14-nacl/Alc/backends/ppapi.c	2012-10-13 21:31:49.310818518 +0200
@@ -0,0 +1,317 @@
+/**
+ * OpenAL cross platform audio library
+ * Copyright (C) 2012
+ * This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Library General Public
+ *  License as published by the Free Software Foundation; either
+ *  version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ *  License along with this library; if not, write to the
+ *  Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ *  Boston, MA  02111-1307, USA.
+ * Or go to http://www.gnu.org/copyleft/lgpl.html
+ */
+
+#include "config.h"
+
+#include <stdlib.h>
+#include "alMain.h"
+#include "AL/al.h"
+#include "AL/alc.h"
+
+#include "ppapi/c/pp_completion_callback.h"
+#include "ppapi/c/pp_instance.h"
+#include "ppapi/c/ppb.h"
+#include "ppapi/c/ppb_audio.h"
+#include "ppapi/c/ppb_audio_config.h"
+#include "ppapi/c/ppb_core.h"
+
+/* The output buffer will be this multiple of the OpenAL device update size.
+ * This needs to be at least 2 or we can't buffer output properly.
+ */
+const ALuint kBufferPadMult = 4;
+/* How many samples for each frame will be buffered to Pepper.
+ * Keep this low for low latency, but not too low or we will be CPU bound.
+ */
+const ALuint kRequestedFrameCount = 1024;
+/* 4 is 2-channels, 2-bytes per sample. */
+const ALuint kFrameSizeInBytes = 4;
+
+typedef struct {
+    /* Simple circular buffer (single producer/consumer) to buffer data output
+     * from OpenAL before it's handed off to PPAPI.
+     */
+    ALvoid *buffer;
+    ALuint size;
+
+    PPB_AudioConfig* audio_config;
+    PPB_Audio* audio;
+    PPB_Core* core;
+
+    PP_Resource audio_config_resource;
+    PP_Resource audio_resource;
+    ALuint sample_frame_count;
+
+    ALCdevice *device;
+
+    volatile ALint main_thread_init_status;
+    ALuint buffer_ready;
+} ppapi_data;
+
+static PP_Instance gInstance;
+static PPB_GetInterface gGetInterface;
+
+AL_API void AL_APIENTRY alSetPpapiInfo(PP_Instance instance, PPB_GetInterface get_interface)
+{
+    gInstance = instance;
+    gGetInterface = get_interface;
+}
+
+/* This is the callback from PPAPI to fill in the audio buffer. */
+void PPAPI_Audio_Callback(void *buffer,
+                          uint32_t size,
+                          void* user_data)
+{
+  ppapi_data *data = (ppapi_data*)user_data;
+  (void)size;
+
+  if(data->buffer_ready)
+      aluMixData(data->device, buffer, data->sample_frame_count);
+}
+
+static const ALCchar ppapiDevice[] = "PPAPI Output";
+
+/* This needs to be called on the main PPAPI thread. */
+static void ppapi_open_playback_main_thread(void* user_data, int32_t result)
+{
+    ppapi_data *data = (ppapi_data*)user_data;
+    (void)result;
+
+    PP_AudioSampleRate rate = PP_AUDIOSAMPLERATE_44100;
+    if (data->device->Frequency == 48000)
+        rate = PP_AUDIOSAMPLERATE_48000;
+
+    data->sample_frame_count =
+        data->audio_config->RecommendSampleFrameCount(
+#ifndef PPB_AUDIO_CONFIG_INTERFACE_1_0
+                                                      gInstance,
+#endif
+                                                      rate,
+                                                      kRequestedFrameCount);
+
+    data->audio_config_resource =
+        data->audio_config->CreateStereo16Bit(gInstance,
+                                              rate,
+                                              data->sample_frame_count);
+
+    if (PP_FALSE == data->audio_config->IsAudioConfig(data->audio_config_resource)) {
+        AL_PRINT("PPAPI initialization: audio config creation failed.");
+        data->main_thread_init_status = -1;
+        return;
+    }
+
+    data->audio_resource = data->audio->Create(gInstance,
+                                               data->audio_config_resource,
+                                               PPAPI_Audio_Callback,
+                                               (void*)data);
+
+    if (PP_FALSE == data->audio->IsAudio(data->audio_resource)) {
+        AL_PRINT("PPAPI initialization: audio resource creation failed.");
+        data->main_thread_init_status = -1;
+        return;
+    }
+
+    if (PP_FALSE == data->audio->StartPlayback(data->audio_resource)) {
+        AL_PRINT("PPAPI initialization: start playback failed.");
+        data->main_thread_init_status = -1;
+        return;
+    }
+
+    data->main_thread_init_status = 1;
+}
+
+static ALCenum ppapi_open_playback(ALCdevice *device, const ALCchar *deviceName)
+{
+    ppapi_data *data;
+
+    if(!deviceName)
+        deviceName = ppapiDevice;
+    else if(strcmp(deviceName, ppapiDevice) != 0)
+        return ALC_INVALID_VALUE;
+
+    ALuint channels = ChannelsFromDevFmt(device->FmtChans);
+    ALuint bytes = BytesFromDevFmt(device->FmtType);
+
+    if (channels != 2)
+    {
+        AL_PRINT("PPAPI only supports 2 channel output\n");
+        return ALC_INVALID_VALUE;
+    }
+    if (bytes != 2)
+    {
+        AL_PRINT("PPAPI only supports 16-bit output\n");
+        return ALC_INVALID_VALUE;
+    }
+    if (device->Frequency != 44100 && device->Frequency != 48000)
+    {
+        AL_PRINT("PPAPI only supports 44100 and 48000 sample frequencies\n");
+        return ALC_INVALID_VALUE;
+    }
+
+    data = (ppapi_data*)calloc(1, sizeof(*data));
+    if (!data)
+      return ALC_OUT_OF_MEMORY;
+
+    device->szDeviceName = strdup(deviceName);
+    device->ExtraData = data;
+    data->device = device;
+
+    data->audio_config =
+        (PPB_AudioConfig*)gGetInterface(PPB_AUDIO_CONFIG_INTERFACE);
+    if (!data->audio_config)
+    {
+        free(data);
+        return ALC_INVALID_VALUE;
+    }
+
+    data->audio = (PPB_Audio*)gGetInterface(PPB_AUDIO_INTERFACE);
+    if (!data->audio)
+    {
+        free(data);
+        return ALC_INVALID_VALUE;
+    }
+
+    data->core = (PPB_Core*)gGetInterface(PPB_CORE_INTERFACE);
+    if (!data->core)
+    {
+        free(data);
+        return ALC_INVALID_VALUE;
+    }
+
+    if (data->core->IsMainThread()) {
+        ppapi_open_playback_main_thread(data, 0);
+    } else {
+        struct PP_CompletionCallback cb =
+            PP_MakeCompletionCallback(ppapi_open_playback_main_thread, data);
+        data->core->CallOnMainThread(0, cb, 0);
+
+        while (data->main_thread_init_status == 0)
+            Sleep(1);
+    }
+
+    if (data->main_thread_init_status < 0) {
+        free(data);
+        return ALC_INVALID_VALUE;
+    }
+    return ALC_NO_ERROR;
+}
+
+/* This needs to be called on the main PPAPI thread. */
+static void ppapi_close_playback_main_thread(void* user_data, int32_t result)
+{
+    ppapi_data *data = (ppapi_data*)user_data;
+    (void)result;
+
+    data->audio->StopPlayback(data->audio_resource);
+
+    data->core->ReleaseResource(data->audio_resource);
+    data->core->ReleaseResource(data->audio_config_resource);
+
+    if (data->buffer)
+      free(data->buffer);
+    free(data);
+}
+
+static void ppapi_close_playback(ALCdevice *device)
+{
+    ppapi_data *data = (ppapi_data*)device->ExtraData;
+
+    if (data->core->IsMainThread()) {
+        ppapi_close_playback_main_thread(data, 0);
+    } else {
+        struct PP_CompletionCallback cb =
+            PP_MakeCompletionCallback(ppapi_close_playback_main_thread, data);
+        data->core->CallOnMainThread(0, cb, 0);
+    }
+
+    device->ExtraData = NULL;
+}
+
+static ALCboolean ppapi_reset_playback(ALCdevice *device)
+{
+    ppapi_data *data = (ppapi_data*)device->ExtraData;
+
+    ALuint UpdateSizeInBytes = device->UpdateSize * kFrameSizeInBytes;
+    /* kBufferPadMult is added to protect against buffer underruns. */
+    data->size = UpdateSizeInBytes * kBufferPadMult;
+    /* Extra UpdateSize added so we can read off the end of the buffer in one
+     * shot from aluMixData, but treat the buffer like it's of size data->size.
+     */
+    data->buffer = calloc(1, data->size + UpdateSizeInBytes);
+    if(!data->buffer)
+    {
+        AL_PRINT("buffer malloc failed\n");
+        return ALC_FALSE;
+    }
+    SetDefaultWFXChannelOrder(device);
+
+    data->buffer_ready = 1;
+    return ALC_TRUE;
+}
+
+static ALCboolean ppapi_start_playback(ALCdevice *device)
+{
+  (void) device;
+  return ALC_TRUE;
+}
+
+static void ppapi_stop_playback(ALCdevice *device)
+{
+    ppapi_data *data = (ppapi_data*)device->ExtraData;
+
+    data->buffer_ready = 0;
+    free(data->buffer);
+    data->buffer = NULL;
+}
+
+static ALCenum ppapi_open_capture(ALCdevice *device, const ALCchar *deviceName)
+{
+    (void)device;
+    (void)deviceName;
+    return ALC_INVALID_VALUE;
+}
+
+static const BackendFuncs ppapi_funcs = {
+    ppapi_open_playback,
+    ppapi_close_playback,
+    ppapi_reset_playback,
+    ppapi_start_playback,
+    ppapi_stop_playback,
+    ppapi_open_capture,
+    NULL,
+    NULL,
+    NULL,
+    NULL,
+    NULL
+};
+
+void alc_ppapi_init(BackendFuncs *func_list)
+{
+    *func_list = ppapi_funcs;
+}
+
+void alc_ppapi_deinit(void)
+{
+}
+
+void alc_ppapi_probe(enum DevProbe type)
+{
+    if(type == ALL_DEVICE_PROBE)
+        AppendAllDeviceList(ppapiDevice);
+}
diff -Naur openal-soft-1.14/Alc/backends/wave.c openal-soft-1.14-nacl/Alc/backends/wave.c
--- openal-soft-1.14/Alc/backends/wave.c	2012-03-28 17:55:17.000000000 +0200
+++ openal-soft-1.14-nacl/Alc/backends/wave.c	2012-10-13 21:31:49.310818518 +0200
@@ -22,7 +22,7 @@
 
 #include <stdlib.h>
 #include <stdio.h>
-#include <memory.h>
+#include <string.h>
 #include "alMain.h"
 #include "AL/al.h"
 #include "AL/alc.h"
diff -Naur openal-soft-1.14/CMakeLists.txt openal-soft-1.14-nacl/CMakeLists.txt
--- openal-soft-1.14/CMakeLists.txt	2012-03-28 17:55:17.000000000 +0200
+++ openal-soft-1.14-nacl/CMakeLists.txt	2012-10-13 21:31:49.310818518 +0200
@@ -35,6 +35,7 @@
 OPTION(WINMM   "Check for Windows Multimedia backend"  ON)
 OPTION(PORTAUDIO  "Check for PortAudio backend"        ON)
 OPTION(PULSEAUDIO "Check for PulseAudio backend"       ON)
+OPTION(PPAPI      "Check for PPAPI backend"            ON)
 OPTION(COREAUDIO  "Check for CoreAudio backend"        ON)
 OPTION(OPENSL     "Check for OpenSL backend"           ON)
 OPTION(WAVE    "Enable Wave Writer backend"            ON)
@@ -440,6 +441,7 @@
 SET(HAVE_WINMM      0)
 SET(HAVE_PORTAUDIO  0)
 SET(HAVE_PULSEAUDIO 0)
+SET(HAVE_PPAPI      0)
 SET(HAVE_COREAUDIO  0)
 SET(HAVE_OPENSL     0)
 SET(HAVE_WAVE       0)
@@ -651,6 +653,16 @@
     MESSAGE(FATAL_ERROR "Failed to enabled required OpenSL backend")
 ENDIF()
 
+# Check PPAPI backend
+IF (PPAPI)
+    CHECK_INCLUDE_FILE(ppapi/c/ppb_audio.h HAVE_PPAPI_PPB_AUDIO_H)
+    IF(HAVE_PPAPI_PPB_AUDIO_H)
+      SET(HAVE_PPAPI 1)
+      SET(ALC_OBJS  ${ALC_OBJS}  Alc/backends/ppapi.c)
+      SET(BACKENDS  "${BACKENDS} PPAPI,")
+    ENDIF()
+ENDIF()
+
 # Optionally enable the Wave Writer backend
 IF(WAVE)
     SET(HAVE_WAVE 1)
diff -Naur openal-soft-1.14/config.h.in openal-soft-1.14-nacl/config.h.in
--- openal-soft-1.14/config.h.in	2012-03-28 17:55:17.000000000 +0200
+++ openal-soft-1.14-nacl/config.h.in	2012-10-13 21:31:49.310818518 +0200
@@ -32,6 +32,9 @@
 /* Define if we have the PulseAudio backend */
 #cmakedefine HAVE_PULSEAUDIO
 
+/* Define if we have the PPAPI backend */
+#cmakedefine HAVE_PPAPI
+
 /* Define if we have the CoreAudio backend */
 #cmakedefine HAVE_COREAUDIO
 
diff -Naur openal-soft-1.14/OpenAL32/Include/alMain.h openal-soft-1.14-nacl/OpenAL32/Include/alMain.h
--- openal-soft-1.14/OpenAL32/Include/alMain.h	2012-03-28 17:55:17.000000000 +0200
+++ openal-soft-1.14-nacl/OpenAL32/Include/alMain.h	2012-10-13 21:31:49.310818518 +0200
@@ -461,6 +461,9 @@
 ALCboolean alc_pulse_init(BackendFuncs *func_list);
 void alc_pulse_deinit(void);
 void alc_pulse_probe(enum DevProbe type);
+void alc_ppapi_init(BackendFuncs *func_list);
+void alc_ppapi_deinit(void);
+void alc_ppapi_probe(enum DevProbe type);
 ALCboolean alc_ca_init(BackendFuncs *func_list);
 void alc_ca_deinit(void);
 void alc_ca_probe(enum DevProbe type);
@@ -485,7 +488,7 @@
     DevFmtUInt   = ALC_UNSIGNED_INT_SOFT,
     DevFmtFloat  = ALC_FLOAT_SOFT,
 
-    DevFmtTypeDefault = DevFmtFloat
+    DevFmtTypeDefault = DevFmtShort
 };
 enum DevFmtChannels {
     DevFmtMono   = ALC_MONO_SOFT,
diff -Naur openal-soft-1.14/XCompile-nacl.txt openal-soft-1.14-nacl/XCompile-nacl.txt
--- openal-soft-1.14/XCompile-nacl.txt	1970-01-01 01:00:00.000000000 +0100
+++ openal-soft-1.14-nacl/XCompile-nacl.txt	2012-10-13 21:31:49.310818518 +0200
@@ -0,0 +1,25 @@
+# Cross-compiling requires CMake 2.6 or newer. To cross-compile, first modify
+# this file to set the proper settings and paths. Then use it from build/ like:
+# cmake .. -DCMAKE_TOOLCHAIN_FILE=../XCompile.txt \
+#          -DCMAKE_INSTALL_PREFIX=/usr/mingw32/mingw
+# If you already have a toolchain file setup, you may use that instead of this
+# file.
+
+# the name of the target operating system
+SET(CMAKE_SYSTEM_NAME Linux)
+
+# which compilers to use for C and C++
+SET(CMAKE_C_COMPILER ${NACLCC})
+SET(CMAKE_CXX_COMPILER ${NACLCXX})
+set(CMAKE_AR ${NACLAR} CACHE FILEPATH "Archiver")
+SET(_CMAKE_TOOLCHAIN_PREFIX ${NACL_CROSS_PREFIX})
+
+# here is the target environment located
+SET(CMAKE_FIND_ROOT_PATH ${NACL_TOOLCHAIN_ROOT})
+
+# adjust the default behaviour of the FIND_XXX() commands:
+# search headers and libraries in the target environment, search 
+# programs in the host environment
+set(CMAKE_FIND_ROOT_PATH_MODE_PROGRAM NEVER)
+set(CMAKE_FIND_ROOT_PATH_MODE_LIBRARY ONLY)
+set(CMAKE_FIND_ROOT_PATH_MODE_INCLUDE ONLY)
