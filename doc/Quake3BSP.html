<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
<head>
	<link rel='stylesheet' type='text/css' href='http://www.devmaster.net/devmaster_f36ce932.css' >
	<style type="text/css" id="vbulletin_css">
<!--
/* vBulletin 3 CSS For Style 'Default Style' (styleid: 2) */
body
{
	background: #E1E1E2;
	color: #000000;
	font: 10pt verdana, geneva, lucida, 'lucida grande', arial, helvetica, sans-serif;
	margin: 5px 10px 10px 10px;
	padding: 0px;
}
a:link
{
	color: #22229C;
}
a:visited
{
	color: #22229C;
}
a:hover, a:active
{
	color: #FF4400;
}
.page
{
	background: #FFFFFF;
	color: #000000;
}
td, th, p, li
{
	font-family: verdana, geneva, lucida, 'lucida grande', arial, helvetica, sans-serif;
}
.tborder
{
	background: #D1D1E1;
	color: #000000;
	border: 1px solid #0B198C;
}
.tcat
{
	background: #869BBF url(/forums/images/gradients/gradient_tcat.gif) repeat-x top left;
	color: #FFFFFF;
	font: bold 10pt verdana, geneva, lucida, 'lucida grande', arial, helvetica, sans-serif;
}
.tcat a:link
{
	color: #ffffff;
	text-decoration: none;
}
.tcat a:visited
{
	color: #ffffff;
	text-decoration: none;
}
.tcat a:hover, .tcat a:active
{
	color: #FFFF66;
	text-decoration: underline;
}
.thead
{
	background: #5C7099 url(/forums/images/gradients/gradient_thead.gif) repeat-x top left;
	color: #FFFFFF;
	font: bold 11px tahoma, verdana, geneva, lucida, 'lucida grande', arial, helvetica, sans-serif;
}
.thead a:link
{
	color: #FFFFFF;
}
.thead a:visited
{
	color: #FFFFFF;
}
.thead a:hover, .thead a:active
{
	color: #FFFF00;
}
.tfoot
{
	background: #3E5C92;
	color: #E0E0F6;
}
.tfoot a:link
{
	color: #E0E0F6;
}
.tfoot a:visited
{
	color: #E0E0F6;
}
.tfoot a:hover, .tfoot a:active
{
	color: #FFFF66;
}
.alt1, .alt1Active
{
	background: #F5F5FF;
	color: #000000;
}
.alt2, .alt2Active
{
	background: #E1E4F2;
	color: #000000;
}
td.inlinemod
{
	background: #FFFFCC;
	color: #000000;
}
.wysiwyg
{
	background: #F5F5FF;
	color: #000000;
	font: 10pt verdana, geneva, lucida, 'lucida grande', arial, helvetica, sans-serif;
}
textarea, .bginput
{
	font: 10pt verdana, geneva, lucida, 'lucida grande', arial, helvetica, sans-serif;
}
.button
{
	font: 11px verdana, geneva, lucida, 'lucida grande', arial, helvetica, sans-serif;
}
select
{
	font: 11px verdana, geneva, lucida, 'lucida grande', arial, helvetica, sans-serif;
}
option, optgroup
{
	font-size: 11px;
	font-family: verdana, geneva, lucida, 'lucida grande', arial, helvetica, sans-serif;
}
.smallfont
{
	font: 11px verdana, geneva, lucida, 'lucida grande', arial, helvetica, sans-serif;
}
.time
{
	color: #666686;
}
.navbar
{
	font: 11px verdana, geneva, lucida, 'lucida grande', arial, helvetica, sans-serif;
}
.highlight
{
	color: #FF0000;
	font-weight: bold;
}
.fjsel
{
	background: #3E5C92;
	color: #E0E0F6;
}
.fjdpth0
{
	background: #F7F7F7;
	color: #000000;
}
.panel
{
	background: #E4E7F5 url(images/gradients/gradient_panel.gif) repeat-x top left;
	color: #000000;
	padding: 10px;
	border: 2px outset;
}
.panelsurround
{
	background: #D5D8E5 url(images/gradients/gradient_panelsurround.gif) repeat-x top left;
	color: #000000;
}
legend
{
	color: #22229C;
	font: 11px tahoma, verdana, geneva, lucida, 'lucida grande', arial, helvetica, sans-serif;
}
.vbmenu_control
{
	background: #738FBF;
	color: #FFFFFF;
	font: bold 11px tahoma, verdana, geneva, lucida, 'lucida grande', arial, helvetica, sans-serif;
	padding: 3px 6px 3px 6px;
	white-space: nowrap;
}
.vbmenu_control a:link
{
	color: #FFFFFF;
	text-decoration: none;
}
.vbmenu_control a:visited
{
	color: #FFFFFF;
	text-decoration: none;
}
.vbmenu_control a:hover, .vbmenu_control a:active
{
	color: #FFFFFF;
	text-decoration: underline;
}
.vbmenu_popup
{
	background: #FFFFFF;
	color: #000000;
	border: 1px solid #0B198C;
}
.vbmenu_option
{
	background: #BBC7CE;
	color: #000000;
	font: 11px verdana, geneva, lucida, 'lucida grande', arial, helvetica, sans-serif;
	white-space: nowrap;
	cursor: pointer;
}
.vbmenu_option a:link
{
	color: #22229C;
	text-decoration: none;
}
.vbmenu_option a:visited
{
	color: #22229C;
	text-decoration: none;
}
.vbmenu_option a:hover, .vbmenu_option a:active
{
	color: #FFFFFF;
	text-decoration: none;
}
.vbmenu_hilite
{
	background: #8A949E;
	color: #FFFFFF;
	font: 11px verdana, geneva, lucida, 'lucida grande', arial, helvetica, sans-serif;
	white-space: nowrap;
	cursor: pointer;
}
.vbmenu_hilite a:link
{
	color: #FFFFFF;
	text-decoration: none;
}
.vbmenu_hilite a:visited
{
	color: #FFFFFF;
	text-decoration: none;
}
.vbmenu_hilite a:hover, .vbmenu_hilite a:active
{
	color: #FFFFFF;
	text-decoration: none;
}
.headerStyle { background: #FFFFFF; }

/* ***** styling for 'big' usernames on postbit etc. ***** */
.bigusername { font-size: 14pt; }

/* ***** small padding on 'thead' elements ***** */
td.thead, div.thead { padding: 4px; }

/* ***** basic styles for multi-page nav elements */
.pagenav a { text-decoration: none; }
.pagenav td { padding: 2px 4px 2px 4px; }

/* ***** define margin and font-size for elements inside panels ***** */
.fieldset { margin-bottom: 6px; }
.fieldset, .fieldset td, .fieldset p, .fieldset li { font-size: 11px; }

/* ***** don't change the following ***** */
form { display: inline; }
label { cursor: default; }
.normal { font-weight: normal; }
.inlineimg { vertical-align: middle; }

H1 {
	FONT-WEIGHT: bold; FONT-SIZE: 12pt; COLOR: #00006f;
}
H2 {
	FONT-WEIGHT: bold; FONT-SIZE: 11pt; MARGIN-BOTTOM: 0.2em; FONT-FAMILY: Tahoma, Sans-serif
}
H3 {
	FONT-WEIGHT: bold; FONT-SIZE: 10pt; MARGIN-BOTTOM: 0.2em; FONT-FAMILY: Tahoma, Sans-serif
}
H5 {
	FONT-WEIGHT: bold; MARGIN-BOTTOM: 0.2em; BORDER-BOTTOM: black 0.1em solid; FONT-FAMILY: Tahoma, Sans-serif
}
-->
</style>	<link rel='alternate' type='application/rss+xml' title='RSS' href='http://www.devmaster.net/rss/' />
	<meta name="Keywords" content="game development, game programming, graphics programming, OpenGL, DirectX, Direct3D, AI, artificial intelligence, game design, game, gamedev, development, programming, c++, games, program, create, design, gouraud, shading, tutorial, art, devmaster, dm, articles, forum">
	<meta name="Description" content="DevMaster.net is a game development website that provides articles, 3D engines database, tutorials, daily news updates, and an active forum!">
<title>DevMaster.net - Quake 3 BSP Collision Detection</title>
</head>

<body>
<table class="tborder" cellpadding="6" cellspacing="1" border="0" width="100%" align="center">
<tr class="thead">
	<td width="50%">DevMaster.net</td>
	<td width="50%" align='right'>&nbsp;</td>
</tr>
</table>
<div bgcolor="#F0F0F0"><table class="tborder" cellpadding="6" cellspacing="1" width="100%">
<tbody><tr>
	<td class="tcat" style="color: rgb(255, 193, 37);" colspan="2" align="center" nowrap="nowrap" width="60%">
		[[ <b><a href="/">Home</a> |
		<a href="http://www.devmaster.net/forums/">Forums</a> | 
		<a href="http://www.devmaster.net/engines/">3D Engines Database</a> | 
		<a href="http://www.devmaster.net/wiki/Main_Page">Wiki</a> |
		<a href="http://www.devmaster.net/articles.php">Articles/Tutorials</a> | 
		<a href="http://www.devmaster.net/jobs.php">Game Dev Jobs</a> | 
		<a href="http://www.devmaster.net/chat/">IRC Chat Network</a> |
		<a href="http://www.devmaster.net/forums/sendmessage.php">Contact Us</a></b> ]]
	</td>
</tr>
</tbody></table>
<div class="smallfont"></div></div>

<div align="center">
	<div class="page" style="width:100%; text-align:left">
		<div style="padding:0px 15px 0px 15px">

<br />
<div><a href="http://www.devmaster.net/articles.php?catID=3">Game Programming</a> &gt; Collision Detection</div>
<br />
<div align="center">
<script type='text/javascript' src='http://www.devmaster.net/adsrvr/www/delivery/fl.js'></script>
<div id='ox_46ba2232a3718f7a67d9d7c3aa8495ab' style='display: inline;'><img src='http://www.devmaster.net/images/1x1.gif' alt='' title='' border='0' /></div>
<script type='text/javascript'><!--// <![CDATA[
var ox_swf = new FlashObject('http://www.devmaster.net/adsrvr/www/delivery/ai.php?filename=smoke-728x90_v2_3.swf&contenttype=swf', 'Advertisement', '728', '90', '9');
    ox_swf.addVariable('clickTARGET', '_blank');
    ox_swf.addVariable('clickTAG', 'http%3A%2F%2Fwww.devmaster.net%2Fadsrvr%2Fwww%2Fdelivery%2Fck.php%3Foaparams%3D2__bannerid%3D28__zoneid%3D3__cb%3Db4eaa77c6f');

ox_swf.addParam('allowScriptAccess','always');
ox_swf.write('ox_46ba2232a3718f7a67d9d7c3aa8495ab');
// ]]> --></script><div id='beacon_28' style='position: absolute; left: 0px; top: 0px; visibility: hidden;'><img src='http://www.devmaster.net/adsrvr/www/delivery/lg.php?bannerid=28&amp;campaignid=26&amp;zoneid=3&amp;channel_ids=,&amp;loc=http%3A%2F%2Fwww.devmaster.net%2Farticles%2Fquake3collision%2F&amp;referer=http%3A%2F%2Fnathanostgard.com%2Fpages%2Fquake3_collision_detection&amp;cb=b4eaa77c6f' width='0' height='0' alt='' style='width: 0px; height: 0px;' /></div></div>
<br />
<table border="0" width="100%" cellpadding="0">
		<tr>
			<td width="80%" class="ArticleTitle">Quake 3 BSP Collision Detection</td>
			<td width="2%">&nbsp;</td>
			<td width="18%" class="smallfont" align="right" nowrap>
										<a href="http://www.devmaster.net/forums/showthread.php?t=456"> <img border="0" src="http://www.devmaster.net/icons1/community.gif" /></a>&nbsp;&nbsp;&nbsp;
						<a href="javascript:window.print()"> <img border="0" height=17 width=17 src="http://www.devmaster.net/icons1/print.gif" /></a></td>
		</tr>
		<tr>
			<td border="0" height="1" colspan="3" bgcolor="#000000"></td>
		</tr>
		<tr>
			<td width="100%" colspan="3" class="ArticleShortDesc"></td>
		</tr>
		<tr>
			<td colspan="2" width="90%">
<script type="text/javascript">
digg_title = 'Quake 3 BSP Collision Detection';
digg_bodytext = "The article goes into great detail on how to implement collision detection for Quake 3 maps (BSP46 format). It is written for people who already understand how the Quake 3 BSP structure works (and, preferrably, have written a renderer of at least a basic level for the map format).";
digg_bgcolor = '#EEEEEE';
</script>
<script src="http://digg.com/tools/diggthis.js" type="text/javascript"></script>
			</td>
			<td class="smallfont" width="10%" colspan="1" align="right" nowrap="nowrap">
				<div class="ArticleAuthor"><a href="mailto:nostgard@lvcm.com">Nathan Ostgard</a></div>
				<div>16/08/2003</div>
			</td>
		</tr>
	</table>

<table border='0' cellpadding='5' cellspacing='5' width='100%'>
<tr>
	<td width='100%'>
	
<!-- ad block -->
<table align="left" border="0" cellpadding="6" cellspacing="1" width="20%">
	<tbody>
	<tr>
		<td width="100%">
		<table class="smallfont" cellpadding="0" cellspacing="0" width="100%">
			<tbody><tr>
				<td>
					
					<script type="text/javascript"><!--
google_ad_client = "pub-4748087847388234";
google_ad_width = 300;
google_ad_height = 250;
google_ad_format = "300x250_as";
google_ad_type = "text_image";
//2007-02-08: articles
google_ad_channel = "8424799829";
google_color_border = "FFFFFF";
google_color_bg = "FFFFFF";
google_color_link = "22229C";
google_color_text = "000000";
google_color_url = "22229C";
//--></script>
<script type="text/javascript"
  src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
					
				</td>
			</tr>
		</tbody></table>
		</td>
	</tr>
</tbody></table>
<!-- /ad block -->

	<h1>1. Introduction</h1>
<p>This document is written to be a tutorial to teach how to implement collision 
detection for the BSP46 (Quake 3's) map format. It is written for people who 
already understand how the Quake 3 BSP structure works (and, preferrably, have 
written a renderer of at least a basic level for the map format).</p>
<p>All of the code in the document is written in pseudo-code. Anything you see 
referenced with <span class="codeNormal">BSP.*</span> means the properties shown of the BSP file itself, after 
it has been parsed. I don't bother worrying about specific types for structures 
or classes at this point - it would only be confusing without any frame of 
reference. When I've written the other tutorials on the map format itself, I 
will change this code to reflect the types I explain there.</p>
<p>As such, I will only be using the following types in my code:</p>
<ul>
  <li>
  <span class="codeNormal">int</span><br>
  Identical to an int variable in C/C++. </li>
  <li><span class="codeNormal">float</span><br>
  Identical to a float variable in C/C++. </li>
  <li><span class="codeNormal">boolean</span><br>
  Identical to a bool variable in C/C++. </li>
  <li><span class="codeNormal">vector</span><br>
  First of all, our vector, or point (these terms are used interchangably in 
  this document, as they represent the same thing in the Quake 3 source code), 
  type is defined as follows:<span class="codeNormal"><br>
  typedef float[3] vector</span><br>
  I use the equals operator to set this, when in reality with a type defined as 
  I have above, you would need to set each index in the array individually. I 
  only do this to make the code more readable. </li>
  <li><span class="codeNormal">object</span><br>
  This is a generic term I will use to refer to any variable which, in normal 
  code, would be represented by a structure or a class. The type that it 
  represents should be evident to you if you understand the Quake 3 map format's 
  organization already, but if you have any questions about the properties of 
  one of the object variables, feel free to ask me about it.</li>
</ul>

<h1>2. Overview</h1>
<p>In a Quake 3 BSP, each leaf in the world has a set of brushes that are 
associated with it. Each brush, in turn, has a set of brush planes which are 
associated with it. When clipped together, these brush planes form a convex 
volume which represents the brush that you are trying to perform collision 
detection against.</p>
<p>So, the way that id Software approached an interface to this collision 
detection, and the way I, too, decided to design it, was to provide a single 
trace function for the game to call which will determine if there is a collision 
with the world (among other uses). This trace function takes several arguments. 
First, it takes the starting point for a line segment. Second, it takes the 
point that you are trying to end up at. It also takes a bounding box around this 
point. Just to clarify, this box represents the bounding area for the object 
that you are trying to move through the world. It is not the bounding box for 
the line segment.</p>
<p>The trace function moves along the line between this starting and ending 
point, and checks each leaf it encounters. If it collides with something, it 
stores a value representing how far along this line it got before it ran into 
something, and then progresses on. Each time it runs into something, if the 
collision point is closer than the last collision point, it stores the new one 
instead. This will give you the closest point of collision along the line as an 
end result.</p>
<p>Now for the more technical details.</p>
<p>As you know, a BSP tree is made up of many nodes, each with a dividing plane, 
splitting and splitting until it results in a leaf with no children. To progress 
through the BSP tree, you start at the root node and check your point against 
each splitting plane, and progress down the front or back split of the node, 
depending on where you are located in relation to the plane. The knowledge of 
how this works is essential to understanding the collision detection process, so 
if you do not understand this, let me know and I will explain it in more detail.</p>
<h1>3. The Variables</h1>
<p>So, the pieces of data we have available to us are as follows:</p>
<p><u>INPUTS<br>
</u>This is the information that the game will be passing to the function: our 
parameters. </p>
<ul>
  <li><span class="codeNormal">inputStart (vector)</span><br>
  The point in the world where the trace will begin. </li>
  <li><span class="codeNormal">inputEnd (vector)</span><br>
  The position we are trying to reach in the BSP. </li>
</ul>
<p><u>OUTPUTS</u><br>
Our trace function will return (at a minimum) these values to the game. They 
represent the result of our attempt to perform a trace using the specified 
inputs.</p>
<ul>
  <li><span class="codeNormal">outputFraction (float)</span><br>
  How far along the line we got before we collided. 0.5 == 50%, 1.0 == 100%.
  </li>
  <li><span class="codeNormal">outputEnd (vector)</span><br>
  The point of collision, in world space. </li>
  <li><span class="codeNormal">outputStartsOut (boolean)</span><br>
  True if the line segment starts outside of a solid volume. </li>
  <li><span class="codeNormal">outputAllSolid (boolean)</span><br>
  True if the line segment is completely enclosed in a solid volume. </li>
</ul>
<p>We'll declare them (outputs as globals, inputs as parameters to the function) 
and the initial <span class="codeNormal">Trace</span> function, as follows:</p>

<pre class="code"><span class="codeKeyword">float</span> outputFraction;
vector outputEnd;
boolean outputStartsOut;
boolean outputAllSolid;

<span class="codeKeyword">void</span> Trace( vector inputStart, vector inputEnd )
{
    <span class="codeComment">// ...</span>
}
</pre>

<p>Don't worry about the <span class="codeNormal">Trace</span> function just yet - we'll get into that later. 
Note that I wouldn't normally lay out my code with global input and output 
variables like this, but it just makes it a lot simpler for the purposes of the 
document.</p>
<h1>4. Tracing with a Line</h1>
<p>Let's look at how we would perform a trace using this data with a single ray 
first, disregarding the bounding box data. This is a lot simpler, and will make 
the rest of it easier to comprehend.</p>
<h2>4A. Checking the Nodes</h2>
<p>In the beginning, the process is very similar to the one you would use to 
walk through a BSP tree for other purposes (such as rendering). We start at the 
root node, and we check <span class="codeNormal">start</span> and <span class="codeNormal">end</span> against the node's splitting plane using 
the plane equation, like we normally would:</p>
<pre class="code"><span class="codeKeyword">void</span> CheckNode( <span class="codeKeyword">int</span> nodeIndex,
                <span class="codeKeyword">float</span> startFraction, <span class="codeKeyword">float</span> endFraction,
                vector start, vector end )
{
    object *node = &BSP.nodes[nodeIndex];
    object *plane = &BSP.planes[node-&gt;planeIndex];

    <span class="codeKeyword">float</span> startDistance = DotProduct( start, plane-&gt;normal ) - plane-&gt;distance;
    <span class="codeKeyword">float</span> endDistance = DotProduct( end, plane-&gt;normal ) - plane-&gt;distance;
}
</pre>
<p>This gives us two floats which represent the distances of each point from the 
splitting plane. We can then use these values to determine which nodes to check. 
The text in gray is the code we've already gone over, and anything else is 
new.</p>
<pre class="code"><font color="#999999">void CheckNode( int nodeIndex,
                float startFraction, float endFraction,
                vector start, vector end )
{
    object *node = &BSP.nodes[nodeIndex];
    object *plane = &BSP.planes[node->planeIndex];

    float startDistance = DotProduct( start, plane->normal ) - plane->distance;
    float endDistance = DotProduct( end, plane->normal ) - plane->distance;</font>

    <span class="codeKeyword">if</span> (startDistance &gt;= 0 && endDistance &gt;= 0)     // <font color="#FF0000">A</font>
    {   <span class="codeComment">// both points are in front of the plane</span>
        <span class="codeComment">// so check the front child</span>
        CheckNode( node-&gt;children[0], startFraction, endFraction, start, end );
    }
    <span class="codeKeyword">else</span> <span class="codeKeyword">if</span> (startDistance &lt; 0 && endDistance &lt; 0)  // <font color="#FF0000">B</font>
    {   <span class="codeComment">// both points are behind the plane</span>
        <span class="codeComment">// so check the back child</span>
        CheckNode( node-&gt;children[1], startFraction, endFraction, start, end );
    }
    <span class="codeKeyword">else</span>                                            // <font color="#FF0000">C</font>
    {   <span class="codeComment">// the line spans the splitting plane</span>
        <span class="codeComment">/* ... (will fill in) ... */</span>
    }
<font color="#999999">}</font>
</pre>
<p>What does the code above do? Well, we have three situations in this case. 
Just like when you walk the BSP tree for rendering, our point can either be in 
front (<b>A</b>) or behind (<b>B</b>) the splitting plane (we treat points that 
are coplanar with the plane as in front of it). But, since we're dealing with a 
line segment, we have a third option: the line can span both sections of the 
node, or <i>cross the splitting plane</i> (<b>C</b>).</p>
<p>In the case of <b>A</b>, we know the entire line segment is in front of the 
splitting plane, so we only have to progress down the front child of the current 
node.</p>
<p><b>B</b> is the same, but for the back child instead.</p>
<p>For <b>C</b>, we have to check both children of the node. As you've probably 
noticed with distress, this section isn't filled in on the code listing above. 
That's because it takes a little bit more code than the other two, so I've 
expanded it below:</p>
<pre class="code"><font color="#999999">void CheckNode( int nodeIndex,
                float startFraction, float endFraction,
                vector start, vector end )
{
    object *node = &BSP.nodes[nodeIndex];
    object *plane = &BSP.planes[node->planeIndex];

    float startDistance = DotProduct( start, plane->normal ) - plane->distance;
    float endDistance = DotProduct( end, plane->normal ) - plane->distance;

    if (startDistance >= 0 && endDistance >= 0)
    {   // both points are in front of the plane
        // so check the front child
        CheckNode( node->children[0], startFraction, endFraction, start, end );
    }
    else if (startDistance < 0 && endDistance < 0)
    {   // both points are behind the plane
        // so check the back child
        CheckNode( node->children[1], startFraction, endFraction, start, end );
    }
    else
    {   // the line spans the splitting plane</font>
        <span class="codeKeyword">int</span> side;
        <span class="codeKeyword">float</span> fraction1, fraction2, middleFraction;
        vector middle;

        <span class="codeComment">// STEP 1: split the segment into two</span>
        <span class="codeKeyword">if</span> (startDistance &lt; endDistance)
        {
            side = 1; <span class="codeComment">// back</span>
            <span class="codeKeyword">float</span> inverseDistance = 1.0f / (startDistance - endDistance);
            fraction1 = (startDistance + EPSILON) * inverseDistance;
            fraction2 = (startDistance + EPSILON) * inverseDistance;
        }
        <span class="codeKeyword">else</span> <span class="codeKeyword">if</span> (endDistance &lt; startDistance)
        {
            side = 0; <span class="codeComment">// front</span>
            <span class="codeKeyword">float</span> inverseDistance = 1.0f / (startDistance - endDistance);
            fraction1 = (startDistance + EPSILON) * inverseDistance;
            fraction2 = (startDistance - EPSILON) * inverseDistance;
        }
        <span class="codeKeyword">else</span>
        {
            side = 0; <span class="codeComment">// front</span>
            fraction1 = 1.0f;
            fraction2 = 0.0f;
        }

        <span class="codeComment">// STEP 2: make sure the numbers are valid</span>
        <span class="codeKeyword">if</span> (fraction1 &lt; 0.0f) fraction1 = 0.0f;
        <span class="codeKeyword">else</span> <span class="codeKeyword">if</span> (fraction1 &gt; 1.0f) fraction1 = 1.0f;
        <span class="codeKeyword">if</span> (fraction2 &lt; 0.0f) fraction2 = 0.0f;
        <span class="codeKeyword">else</span> <span class="codeKeyword">if</span> (fraction2 &gt; 1.0f) fraction2 = 1.0f;

        <span class="codeComment">// STEP 3: calculate the middle point for the first side</span>
        middleFraction = startFraction +
                         (endFraction - startFraction) * fraction1;
        <span class="codeKeyword">for</span> (i = 0; i &lt; 3; i++)
            middle[i] = start[i] + fraction1 * (end[i] - start[i]);

        <span class="codeComment">// STEP 4: check the first side</span>
        CheckNode( node-&gt;children[side], startFraction, middleFraction,
                   start, middle );

        <span class="codeComment">// STEP 5: calculate the middle point for the second side</span>
        middleFraction = startFraction +
                        (endFraction - startFraction) * fraction2;
        <span class="codeKeyword">for</span> (i = 0; i &lt; 3; i++)
            middle[i] = start[i] + fraction2 * (end[i] - start[i]);

        <span class="codeComment">// STEP 6: check the second side</span>
        CheckNode( node-&gt;children[!side], middleFraction, endFraction,
                   middle, end );  
    <font color="#999999">}
}</font>
</pre>
<p>At this point, you're probably a little confused. I've labeled each step in 
the code with numbers, so let's go through them one by one.</p>
<ul>
  <li><b>STEP 1</b><br>
  This is probably the worst part of it. Here we are comparing each of the 
  distances we calculated earlier, and deciding which of the node's two children 
  we want to recurse down first. We choose the side that is furthest away from 
  the plane.<br>
  Once we know which side we're going to progress down, we have to split the 
  line segment into two pieces: one for each side of the node. This code splits 
  it not exactly in the middle, but <span class="codeNormal">EPSILON</span> units away from the plane on the 
  closer side. <span class="codeNormal">EPSILON</span> is our &quot;really, really ridiculously small&quot; unit value. 
  Quake 3 defines it as <span class="codeNormal">0.03125f</span>, or <span class="codeNormal">1/32</span>.<br>
  I have to tell you, I'm not really sure why they subtract instead of add 
  <span class="codeNormal">EPSILON</span> on <span class="codeNormal">fraction2</span> 
  in the second block. I figured it out once but I can't remember anymore, so if 
  any of you know the answer to that, please e-mail me and tell me. This is just 
  something that id does, so I do as well.</li>
  <li><b>STEP 2</b><br>
  Here we're just making sure that the two fractional values are in a valid 
  range.</li>
  <li dir="ltr">
  <p dir="ltr"><b>STEP 3</b><br>
  This section uses the first fraction we generated to create the middle point 
  for the first side of the node. It subtracts start from end, to find the 
  length of the current ray, and multiplies that by our fractional value, then 
  adds it to the start point. This gives us a point a percentage along the line.</li>
  <li><b>STEP 4</b><br>
  Now we have to actually recurse down to the first side of this node. We use 
  the side that we chose in step one, and pass it the values we've generated up 
  to this point. What we're actually doing is checking for a collision from the 
  start point to the new middle point we've just found.</li>
  <li><b>STEP 5</b><br>
  This is just a repeat of step 3, but for <span class="codeNormal">fraction2</span>, instead.</li>
  <li><b>STEP 6</b><br>
  This is just a repeat of step 4, but for the second side. This is checking for 
  a collision from the middle to the end point.</li>
</ul>
<p>We're almost there! Right now we have the code to walk all the way down the 
nodes to the leaves we might possibly collide with. But how do we know when 
we've reached a leaf, and what do we do when we find one?</p>
<p>Quake 3's map format actually makes this very easy to detect. As you know, 
each node has two values for its children (<span class="codeNormal">node-&gt;children[0 and 1]</span>) which are 
indexes into the node array. If the value is negative, it means that the next 
child is a leaf. So how do we use this? Let's add something to the starting of 
our function.</p>
<pre class="code"><font color="#999999">void CheckNode( int nodeIndex,
                float startFraction, float endFraction,
                vector start, vector end )
{</font>
    <span class="codeKeyword">if</span> (nodeIndex &lt; 0)
    {   <span class="codeComment">// this is a leaf</span>
        object *leaf = &BSP.leaves[-(nodeIndex + 1)];
        <span class="codeKeyword">for</span> (i = 0; i &lt; leaf-&gt;numLeafBrushes; i++)
        {
            object *brush = &BSP.brushes[BSP.leafBrushes[leaf-&gt;firstLeafBrush + i]];
            <span class="codeKeyword">if</span> (brush-&gt;numSides &gt; 0 &&
                (BSP.shaders[brush-&gt;shaderIndex].contentFlags & 1))
                CheckBrush( brush );
        }

        <span class="codeComment">// don't have to do anything else for leaves</span>
        <span class="codeKeyword">return</span>;
    }

    <span class="codeComment">// this is a node

    <font color="#999999">object *node = &BSP.nodes[nodeIndex];
    object *plane = &BSP.planes[node->planeIndex];

    float startDistance = DotProduct( start, plane->normal ) - plane->distance;
    float endDistance = DotProduct( end, plane->normal ) - plane->distance;

    ...
}</font>
</pre>
</span>
<p>The code above does one thing: if the current node is a leaf, it goes through 
each brush in that leaf, and, if needed, checks the brush for a collision. I say 
if needed because some brushes should not be checked. Those include those 
without any brush sides (or planes), and those that aren't solid. </p>
<p><b>Very Important: </b>You can see that I underlined a section of the code 
above, and it is relevant to this point. When I first implemented collision 
detection with this BSP format, I was banging my head on the wall trying to 
figure out why it wasn't working. It turns out I wasn't performing the check I 
do above, and because of this, I was checking against brushes that weren't 
supposed to be solid. This value we're doing the bitwise AND against should 
actually be specified by the game itself, as the Quake games do, but I didn't 
want to complicate it. The check here just makes sure that it is solid <span class="codeNormal">(1 == CONTENTS_SOLID</span>
in the Quake source code).</p>
<p>If the brush is supposed to be checked, we call the function <span class="codeNormal">CheckBrush</span>. 
<span class="codeNormal">CheckBrush</span> is the next part of our collision detection solution.</p>
<h2>4B. Checking the Brushes</h2>
<p>Each brush in the BSP has a number of brush sides that are associated with 
it. Each of these brush sides contains an index into the plane array for the 
plane that represents it. In order for us to check for collisions against a 
brush, we have to loop through this list of brushes, and check each 
individually.</p>
<pre class="code"><span class="codeKeyword">void</span> CheckBrush( object *brush )
{
    <span class="codeKeyword">for</span> (<span class="codeKeyword">int</span> i = 0; i &lt; brush-&gt;numSides; i++)
    {
        object *brushSide = &BSP.brushSides[brush-&gt;firstSide + i];
        object *plane = &BSP.planes[brushSide-&gt;planeIndex];
    }
}
</pre>
<p>As you can see, there isn't anything here except the loop itself, so let's 
fill it out some more. Our first few steps, again, are much the same as always 
with planes:</p>
<pre class="code"><font color="#999999">void CheckBrush( object *brush )
{</font>
    <span class="codeKeyword">float</span> startFraction = -1.0f;
    <span class="codeKeyword">float</span> endFraction = 1.0f;
    boolean startsOut = <span class="codeKeyword">false</span>;
    boolean endsOut = <span class="codeKeyword">false</span>;

    <font color="#999999">for (int i = 0; i < brush->numSides; i++)
    {
        object *brushSide = &BSP.brushSides[brush->firstSide + i];
        object *plane = &BSP.planes[brushSide->planeIndex];</font>

        <span class="codeKeyword">float</span> startDistance = DotProduct( inputStart, plane-&gt;normal ) -
                              plane-&gt;distance;
        <span class="codeKeyword">float</span> endDistance = DotProduct( inputEnd, plane-&gt;normal ) -
                            plane-&gt;distance;

        <span class="codeKeyword">if</span> (startDistance &gt; 0)
            startsOut = <span class="codeKeyword">true</span>;
        <span class="codeKeyword">if</span> (endDistance &gt; 0)
            endsOut = <span class="codeKeyword">true</span>;

        <span class="codeComment">// make sure the trace isn't completely on one side of the brush</span>
        <span class="codeKeyword">if</span> (startDistance &gt; 0 && endDistance &gt; 0)
        {   <span class="codeComment">// both are in front of the plane, its outside of this brush</span>
            <span class="codeKeyword">return</span>;
        }
        <span class="codeKeyword">if</span> (startDistance &lt;= 0 && endDistance &lt;= 0)
        {   <span class="codeComment">// both are behind this plane, it will get clipped by another one</span>
            <span class="codeKeyword">continue</span>;
        }

        <u><span class="codeComment">// MMM... BEEFY</span></u>
        <span class="codeKeyword">if</span> (startDistance &gt; endDistance)
        {   <span class="codeComment">// line is entering into the brush</span>
            <span class="codeKeyword">float</span> fraction = (startDistance - EPSILON) / (startDistance - endDistance);  // <font color="#FF0000">*</font>
            <span class="codeKeyword">if</span> (fraction &gt; startFraction)
                startFraction = fraction;
        }
        <span class="codeKeyword">else</span>
        {   <span class="codeComment">// line is leaving the brush</span>
            <span class="codeKeyword">float</span> fraction = (startDistance + EPSILON) / (startDistance - endDistance);  // <font color="#FF0000">*</font>
            <span class="codeKeyword">if</span> (fraction &lt; endFraction)
                endFraction = fraction;
        }
    <font color="#999999">}
}</font>
</pre>
<p>The first 2 lines of this addition should look familiar: it's the plane 
equation again. We use these two distances to find out if the line segment 
actually intersects with each brush plane. Ignore the <span class="codeNormal">startsOut</span> and <span class="codeNormal">endsOut</span> for 
now, we'll address that later. Look at the code below it.</p>
<p>We only want to test this line segment if it traverses one of the brush 
planes. The first check verifies that its inside the brush at all; if a line 
segment is completely in front of any of the planes in a brush, we can disregard 
that brush. The second if statement confirms that it actually crosses the plane. 
If both the points are behind the plane, we don't bother testing it - it will be 
clipped by one of the other brush sides.</p>
<p>Now we get to the third part, labelled by the underlined comment. This is the 
meat of the entire algorithm. At this point we know that the line crosses the 
plane (and collides with the brush), we just have to find out which side 
collides, and how much of it. The greater distance is the one that is in front 
of the plane. Once we know which side is in front, we calculate the fractional 
value with the code which have commented red articstik on the two lines above. If this 
fractional value is less than the appropriate variable (<span class="codeNormal">startFraction</span> or 
<span class="codeNormal">endFraction</span>), it means that its a closer collision than the last one, so we set 
the variable to it.</p>
<p>We only have one more thing to add to this function.</p>
<pre class="code"><font color="#999999">void CheckBrush( object *brush )
{
    float startFraction = -1.0f;
    float endFraction = 1.0f;
    boolean startsOut = false;
    boolean endsOut = false;

    for (int i = 0; i < brush->numSides; i++)
    {
        object *brushSide = &BSP.brushSides[brush->firstSide + i];
        object *plane = &BSP.planes[brushSide->planeIndex];

        float startDistance = DotProduct( inputStart, plane->normal ) -
                              plane->distance;
        float endDistance = DotProduct( inputEnd, plane->normal ) -
                            plane->distance;

        if (startDistance > 0)
            startsOut = true;
        if (endDistance > 0)
            endsOut = true;

        // make sure the trace isn't completely on one side of the brush
        if (startDistance > 0 && endDistance > 0)
        {   // both are in front of the plane, its outside of this brush
            return;
        }
        if (startDistance <= 0 && endDistance <= 0)
        {   // both are behind this plane, it will get clipped by another one
            continue;
        }

        if (startDistance > endDistance)
        {   // line is entering into the brush
            float fraction = (startDistance - EPSILON) / (startDistance - endDistance);
            if (fraction > startFraction)
                startFraction = fraction;
        }
        else
        {   // line is leaving the brush
            float fraction = (startDistance + EPSILON) / (startDistance - endDistance);
            if (fraction < endFraction)
                endFraction = fraction;
        }
    }</font>

    <span class="codeKeyword">if</span> (startsOut == <span class="codeKeyword">false</span>)
    {
        outputStartOut = <span class="codeKeyword">false</span>;
        <span class="codeKeyword">if</span> (endsOut == <span class="codeKeyword">false</span>)
            outputAllSolid = <span class="codeKeyword">true</span>;
        <span class="codeKeyword">return</span>;
    }

    <span class="codeKeyword">if</span> (startFraction &lt; endFraction)
    {
        <span class="codeKeyword">if</span> (startFraction &gt; -1 && startFraction &lt; outputFraction)
        {
            <span class="codeKeyword">if</span> (startFraction &lt; 0)
                startFraction = 0;
            outputFraction = startFraction;
        }
    }
<font color="#999999">}</font></pre>
<p>Now we can talk about the section I told you to ignore before. If either 
end's distance is greater than zero, it means that end starts outside of the 
brush. So, we check for this and set the <span class="CodeNormal">startsOut</span> and <span class="CodeNormal">endsOut</span> variables to true 
if this is true for any of the brush sides. If, after checking all of the brush 
sides, both of these variables are false, the trace is stuck inside of the 
brush, so we set <span class="CodeNormal">outputAllSolid</span> to false, and return.</p>
<p>The last conditional block in this function is the one that will actually 
apply the collision information to the output data. If the following conditions 
are satisfied:</p>
<ul>
  <li><span class="CodeNormal">startFraction</span> is less than <span class="CodeNormal">endFraction</span> (this will be true because of the way 
that we set them at the starting of the function)</li>
  <li><span class="CodeNormal">startFraction</span> is greater than -1 (the default value)</li>
  <li><span class="CodeNormal">startFraction</span> is less than, or closer to the beginning of the trace, than the 
current <span class="CodeNormal">outputFraction</span></li>
</ul>
<p>Then we set the <span class="CodeNormal">outputFraction</span> equal to this fraction.</p>
<h2>4C. Using the Check Functions</h2>
<p>So now that we have these two functions that we can use to check for the 
collision of a ray against the BSP, how do we actually <i>use</i> them? I've written an 
example implementation of a general <span class="CodeNormal">Trace</span> function below. Just like the other 
source listings, this is generic pseudo-code, and I'm just setting the <span class="CodeNormal">output*</span> 
variables instead of actually returning data. You'd have to adjust it for your 
own engine.</p>
<p>Refer to <a href="section4.txt">SECTION4.TXT</a> for a full source listing for this section.</p>
<pre class="code"><span class="codeKeyword">void</span> Trace( vector inputStart, vector inputEnd )
{
    outputStartsOut = <span class="codeKeyword">true</span>;
    outputAllSolid = <span class="codeKeyword">false</span>;
    outputFraction = 1.0f;

    <span class="codeComment">// walk through the BSP tree</span>
    CheckNode( 0, 0.0f, 1.0f, inputStart, inputEnd );

    <span class="codeKeyword">if</span> (outputFraction == 1.0f)
    {   <span class="codeComment">// nothing blocked the trace</span>
        outputEnd = inputEnd;
    }
    <span class="codeKeyword">else</span>
    {   <span class="codeComment">// collided with something </span>
        <span class="codeKeyword">for</span> (i = 0; i &lt; 3; i++)
        {
            outputEnd[i] = inputStart[i] +
                           outputFraction * (inputEnd[i] - inputStart[i]);
        }
    }
}
</pre>
<h1>5. Tracing with a Sphere</h1>
<p>The details in modifying our code to allow us to check against a sphere 
instead of a ray aren't that complicated - but I'm going to add a bit of code to 
provide an interface to the game for us to specify what type of trace we want to 
do. Sometimes you may only want to trace by a ray (when finding the path of a 
bullet, for example), and other times you may want to trace with a sphere, so 
we'll provide a method for the game to easily to either or.</p>
<p>First, we're going to add some variables to our code. They keep track of the 
type of trace we're performing, and what constraints we want to put on that 
trace. Here are the variables:</p>
<pre class="code"><span class="codeKeyword">#define</span> TT_RAY		0
<span class="codeKeyword">#define</span> TT_SPHERE	1

<span class="codeKeyword">int</span> traceType;
<span class="codeKeyword">float</span> traceRadius;
</pre>
<p>Our first variable is <span class="codeNormal">traceType</span>. This is set to let our tracing functions 
change how they work depending on what type of trace we want to perform. The 
possible values of this variable are <span class="codeNormal">#defined</span> above it. Like much that I do in 
this document, I'm using <span class="codeNormal">#defines</span> for simplicity - I would actually recommend 
using an enum instead.</p>
<p>The second variable, represents the radius of the bounding sphere of the 
object we are trying to trace through the world. This value should be positive.</p>
<p>Now let's create two functions for the game to call for the different types 
of traces.</p>
<pre class="code"><span class="codeKeyword">void</span> TraceRay( vector inputStart, vector inputEnd )
{
    traceType = TT_RAY;
    Trace( inputStart, inputEnd );
}

<span class="codeKeyword">void</span> TraceSphere( vector inputStart, vector inputEnd, <span class="codeKeyword">float</span> inputRadius )
{
    traceType = TT_SPHERE;
    traceRadius = inputRadius;
    Trace( inputStart, inputEnd );
}
</pre>
<p>Both of these functions just set the <span class="codeNormal">trace*</span> variables appropriately, and then 
pass off control to the <span class="codeNormal">Trace</span> function for the rest of it. I don't set 
<span class="codeNormal">traceRadius</span> in <span class="codeNormal">TraceRay</span> because it will never be used for a ray based trace... 
as you will soon see.</p>
<p>Now we must modify the <span class="codeNormal">CheckNode</span> function to account for the extra padding we 
have around our object in sphere tracing mode. The modifications are shown 
below.</p>
<pre class="code"><font color="#999999">void CheckNode( int nodeIndex,
                float startFraction, float endFraction,
                vector start, vector end )
{
    [ ... unchanged code ... ]

    // this is a node

    object *node = &BSP.nodes[nodeIndex];
    object *plane = &BSP.planes[node->planeIndex];
</font>
    <span class="codeKeyword">float</span> startDistance, endDistance, offset;
    startDistance = DotProduct( start, plane->normal ) - plane->distance;
    endDistance = DotProduct( end, plane->normal ) - plane->distance;

    <span class="codeKeyword">if</span> (traceType == TT_RAY)
    {
        offset = 0;
    }
    <span class="codeKeyword">else if</span> (traceType == TT_SPHERE)
    {
        offset = traceRadius;
    }

    <span class="codeKeyword">if</span> (startDistance >= offset && endDistance >= offset)
    <font color="#999999">{   // both points are in front of the plane
        // so check the front child
        CheckNode( node->children[0], startFraction, endFraction, start, end );
    }</font>
    <span class="codeKeyword">else if</span> (startDistance < -offset && endDistance < -offset)
    <font color="#999999">{   // both points are behind the plane
        // so check the back child
        CheckNode( node->children[1], startFraction, endFraction, start, end );
    }</font>
    <font color="#999999">else
    {   // the line spans the splitting plane
        int side;
        float fraction1, fraction2, middleFraction;
        vector middle;

        // split the segment into two
        if (startDistance < endDistance)
        {
            side = 1; // back
            float inverseDistance = 1.0f / (startDistance - endDistance);
            </font>fraction1 = (startDistance - offset + EPSILON) * inverseDistance;
            fraction2 = (startDistance + offset + EPSILON) * inverseDistance;<font color="#999999">
        }
        else if (endDistance < startDistance)
        {
            side = 0; // front
            float inverseDistance = 1.0f / (startDistance - endDistance);
           </font> fraction1 = (startDistance + offset + EPSILON) * inverseDistance;
            fraction2 = (startDistance - offset - EPSILON) * inverseDistance;<font color="#999999">
            }
        else
        {
            side = 0; // front
            fraction1 = 1.0f;
            fraction2 = 0.0f;
        }

        [ ... unchanged code ... ]
    }
}</font>
</pre>
<p>We've made a simple but essential modification to this function. In the first 
change, we've added a new variable: <span class="codeNormal">offset</span>. This variable tells us how close 
something has to be to a plane to be considered a collision. In the case of the 
ray trace, it has to be directly against something to hit it, so we set <span class="codeNormal">offset</span> 
to zero. In the case of a sphere, we set it to the radius of the sphere.</p>
<p>Our second change pads the middle point by the amount we chose for the 
<span class="codeNormal">offset</span>, so that we're that much on either side of the split.</p>
<p>Now we need to modify the <span class="codeNormal">CheckBrush</span> function.</p>
<pre class="code"><font color="#999999">void CheckBrush( object *brush )
{
    float startFraction = -1.0f;
    float endFraction = 1.0f;
    boolean startsOut = false;
    boolean endsOut = false;

    for (int i = 0; i < brush->numSides; i++)
    {
        object *brushSide = &BSP.brushSides[brush->firstSide + i];
        object *plane = &BSP.planes[brushSide->planeIndex];</font>

        <span class="codeKeyword">float</span> startDistance, endDistance;
        <span class="codeKeyword">if</span> (traceType == TT_RAY)
        {
            startDistance = DotProduct( inputStart, plane->normal ) -
                            plane->distance;
            endDistance = DotProduct( inputEnd, plane->normal ) -
                          plane->distance;
        }
        <span class="codeKeyword">else if</span> (traceType == TT_SPHERE)
        {
            startDistance = DotProduct( inputStart, plane->normal ) -
                            (plane->distance + traceRadius);
            endDistance = DotProduct( inputEnd, plane->normal ) -
                          (plane->distance + traceRadius);
        }

        <font color="#999999">if (startDistance > 0)
            startsOut = true;
        if (endDistance > 0)
            endsOut = true;

        [ ... unchanged code ... ]
}</font>
</pre>
<p>The modification we have done here is very similar to the one we made to 
<span class="codeNormal">CheckNode</span>. We're just padding the distance with the radius of the sphere.</p>
<p>And that's it! As you can see the modifications are pretty simple once you 
understand how the collision detection system works. If you call <span class="codeNormal">TraceSphere</span> 
with the parameters you want, it will keep your movement from getting right up 
against things. Check out <a href="section5.txt">SECTION5.TXT</a> for a full source listing of this 
section.</p>
<h1>6. Tracing with a Box</h1>
<p>Some situations call for the use of a bounding box instead of a bounding 
sphere. Adding this functionality to our system isn't too hard. First, let's add 
a new trace type and some trace variables:</p>
<pre class="code"><font color="#999999">#define TT_RAY 0
#define TT_SPHERE 1
</font><span class="codeKeyword">#define</span> TT_BOX 2

<font color="#999999">int traceType;
float traceRadius;
</font>vector traceMins;
vector traceMaxs;
vector traceExtents;
</pre>
<p>The first two variables represent two corners of the bounding box which 
surrounds our object. These values are in object space, like the radius. For 
example: for a box that is 20 units in size in all directions and is centered 
around the origin of the object, <span class="codeNormal">traceMins</span> would be (-10,-10,-10) and <span class="codeNormal">traceMaxs</span> 
would be (10,10,10).</p>
<p><span class="codeNormal">traceExtents</span> stores the maximum of the absolute value of each axis in the 
box. For example, if <span class="codeNormal">traceMins</span> was (-100,-3,-15) and <span class="codeNormal">traceMaxs</span> was (55,22,7), 
<span class="codeNormal">traceExtents</span> would be (100,22,15).</p>
<p>Now, let's add our new trace function:</p>
<pre class="code"><span class="codeKeyword">void</span> TraceBox( vector inputStart, vector inputEnd,
               vector inputMins, vector inputMaxs )
{
    <span class="codeKeyword">if</span> (inputMins[0] == 0 && inputMins[1] == 0 && inputMins[2] == 0 &&
        inputMaxs[0] == 0 && inputMaxs[1] == 0 && inputMaxs[2] == 0)
    {   <span class="codeComment">// the user called TraceBox, but this is actually a ray</span>
        TraceRay( inputStart, inputEnd );
    }
    <span class="codeKeyword">else</span>
    {   <span class="codeComment">// setup for a box</span>
        traceType = TT_BOX;
        traceMins = inputMins;
        traceMaxs = inputMaxs;
        traceExtents[0] = -traceMins[0] &gt; traceMaxs[0] ?
                          -traceMins[0] : traceMaxs[0];
        traceExtents[1] = -traceMins[1] &gt; traceMaxs[1] ?
                          -traceMins[1] : traceMaxs[1];
        traceExtents[2] = -traceMins[2] &gt; traceMaxs[2] ?
                          -traceMins[2] : traceMaxs[2];
        Trace( inputStart, inputEnd );
    }
}
</pre>
<p>After writing <span class="codeNormal">TraceRay</span> and <span class="codeNormal">TraceSphere</span>, this function shouldn't be too hard 
to grasp. The first if statement just verifies that they actually gave us a 
bounding box. If all of the values are zero, there is no point in using a box 
test - it is just a ray, so we pass it off.</p>
<p>If it is indeed a box, we setup all of our <span class="codeNormal">trace*</span> variables accordingly. 
<span class="codeNormal">traceMins</span> and <span class="codeNormal">traceMaxs</span> are just copied over from the input variables, and 
<span class="codeNormal">traceExtents</span> is built from those to get the values that we described above.</p>
<p>We have to make some modifications to our other functions to do a box trace. 
The modifications to the <span class="codeNormal">CheckNode</span> function are as follows:</p>
<pre class="code"><font color="#999999">void CheckNode( int nodeIndex,
                float startFraction, float endFraction,
                vector start, vector end )
{
    [ ... unchanged code ... ]

    if (traceType == TT_RAY)
    {
        offset = 0;
    }
    else if (traceType == TT_SPHERE)
    {
        offset = traceRadius;
    }</font>
    <span class="codeKeyword">else if</span> (traceType == TT_BOX)
    {
        <span class="codeComment">// this is just a dot product, but we want the absolute values</span>
        offset = (<span class="codeKeyword">float</span>)(fabs( traceExtents[0] * plane->normal[0] ) +
                         fabs( traceExtents[1] * plane->normal[1] ) +
                         fabs( traceExtents[2] * plane->normal[2] ) );
    }
<font color="#999999">
    [ ... unchanged code ... ]
}</font>
</pre>
<p>What we're doing here is taking the absolute value of the extents for each 
axis, and multiplying it by the plane normal, then adding them together to get 
our offset. How does this give us our offset? If you remember back to your dot 
product math (as this really is just a dot product, but we're using the absolute 
values of the multiplication), the dot product of a point and the normalized 
vector for a plane give us the distance of the point from the plane. By doing 
what we do above, we're basically taking the bounding box, padding it with the 
maximum size on any axis, and finding how far away that is from the plane. We 
can use the value this results in to find out if they have a possibility of 
colliding.</p>
<p>Here are the changes to the <span class="CodeNormal">CheckBrush</span> function:</p>
<pre class="code"><font color="#999999">void CheckBrush( object *brush )
{
    [ ... unchanged code ... ]

        if (traceType == TT_RAY)
        {
            startDistance = DotProduct( inputStart, plane->normal ) -
                            plane->distance;
            endDistance = DotProduct( inputEnd, plane->normal ) -
                          plane->distance;
        }
        else if (traceType == TT_SPHERE)
        {
            startDistance = DotProduct( inputStart, plane->normal ) -
                            (plane->distance + traceRadius);
            endDistance = DotProduct( inputEnd, plane->normal ) -
                          (plane->distance + traceRadius);
        }</font>
        <span class="CodeKeyword">else if</span> (traceType == TT_BOX)
        {
            vector offset;
            <span class="CodeKeyword">for</span> (<span class="CodeKeyword">int</span> j = 0; j < 3; j++)
            {
                <span class="CodeKeyword">if</span> (plane->normal[j] < 0)
                    offset[j] = traceMaxs[j];
                <span class="CodeKeyword">else</span>
                    offset[j] = traceMins[j];
            }

            startDistance = (inputStart[0] + offset[0]) * plane->normal[0] +
                            (inputStart[1] + offset[1]) * plane->normal[1] +
                            (inputStart[2] + offset[2]) * plane->normal[2] -
                            plane->distance;
            endDistance = (inputEnd[0] + offset[0]) * plane->normal[0] +
                          (inputEnd[1] + offset[1]) * plane->normal[1] +
                          (inputEnd[2] + offset[2]) * plane->normal[2] -
                          plane->distance;
        }

    <font color="#999999">[ ... unchanged code ... ]
}</font>
</pre>
<p>This works pretty much the same way that it does for the sphere tracing, 
except we have to calculate a padding vector, since we're working with a 
bounding box with the possibility of being a different size on each axis. So, we 
calculate the offset and perform a dot product, adding the offset to the two 
input points.</p>
<p>And you're all done! See the file <a href="section6.txt">SECTION6.TXT</a> for 
a full source listing.</p>
<h1>7. Conclusion</h1>
<p>After reading this tutorial, you should have a good understanding of how you 
can use the data stored in a <i>Quake 3</i> BSP file to do collision detection 
in your engine. If, for any reason, you don't and have some questions or 
comments, I urge you to e-mail me at <a href="mailto:nostgard@lvcm.com">
nostgard@lvcm.com</a>. I eagerly await your messages.</p>
<p>Some informed readers may notice that I don't take advantage of some tricks 
the Quake 3 engine uses (such as optimizations for axis aligned planes). The 
document was long enough already, and I didn't want to get into this yet. I will 
be creating a second document offering ways to optimize your code. </p>
<p>If you don't want to wait for that, you should take a look at the Quake 2 
source code. My code is heavily based on it, and you should be able to see the 
optimizations immediately. Here are some links you can look at: </p>
<ul>
  <li><a href="ftp://ftp.idsoftware.com/idstuff/source/q2source-3.21.zip">Quake 
  2</a>: id Software was nice enough to release the Quake 2 source code under 
  the GPL license. Much can be learned from it.</li>
  <li><a href="http://hkitchen.quakesrc.org/">QFusion</a>: This is an engine 
  that adds support for Quake 3 data types to the Quake 2 engine.</li>
</ul>
<p>I hope you enjoyed the tutorial, and remember to send me your comments!</p>
<p><a href="section4.txt">Download Section 4 source code listing (Tracing with a 
Line)</a><br>
<a href="section5.txt">Download Section 5 source code listing (Tracing with a 
Sphere)</a><br>
<a href="section6.txt">Download Section 6 source code listing (Tracing with a 
Box)</a></p>	</td>
</tr>
</table>

<!-- ad block -->
<table border="0" cellpadding="6" cellspacing="1" width="20%">
	<tbody>
	<tr>
		<td width="100%">
		<table class="smallfont" cellpadding="0" cellspacing="0" width="100%">
			<tbody><tr>
				<td>
					
					<script type="text/javascript"><!--
google_ad_client = "pub-4748087847388234";
google_ad_width = 300;
google_ad_height = 250;
google_ad_format = "300x250_as";
google_ad_type = "text_image";
//2007-02-08: articles
google_ad_channel = "8424799829";
google_color_border = "FFFFFF";
google_color_bg = "FFFFFF";
google_color_link = "22229C";
google_color_text = "000000";
google_color_url = "22229C";
//--></script>
<script type="text/javascript"
  src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
					
				</td>
			</tr>
		</tbody></table>
		</td>
	</tr>
</tbody></table>
<!-- /ad block -->

<script src="http://digg.com/tools/diggthis.js" type="text/javascript"></script>
<br />
<br />
<br />
	<a href="http://www.devmaster.net/forums/showthread.php?t=456"><img border="0" src="http://www.devmaster.net/icons1/community.gif" /></a> <a href="http://www.devmaster.net/forums/showthread.php?t=456" >Discuss this article in the forums</a><br>
<a href="javascript:window.print()"><img border="0" height=17 width=17 src="http://www.devmaster.net/icons1/print.gif" /></a> <a href="javascript:window.print()">Print article</a><br>
<br />

<table class="tborder" cellpadding="6" cellspacing="1" border="0" width="100%" align="center">
<tr class="thead">
	<td width="50%"><b>&copy 2003-2004 DevMaster.net. All Rights Reserved. <a href='../../legal.html'>Terms of Use &amp; Privacy Policy</a></b></td>
	<td width="50%" align='right'><b>Want to write for us? <a href="../../writeforus.php">Click here</a></b></td>
</tr>
</table>

	</div>
	</div>
</div>

</body>
</html>