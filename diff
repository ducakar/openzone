diff --git a/TODO b/TODO
index a8b9949..d7889a5 100644
--- a/TODO
+++ b/TODO
@@ -5,7 +5,6 @@ Matrix
   ? reinvent cylinder
 
 Client
-  - reimplement sounds, add to context
   - weather
   ? TTF
   - free camera
diff --git a/autogen.sh b/autogen.sh
index 6623cf8..bbcb79b 100755
--- a/autogen.sh
+++ b/autogen.sh
@@ -6,6 +6,8 @@ echo Generating src/matrix/CMakeLists.txt
 cd src/matrix  && ./CMakeLists.gen && cd ../..
 echo Generating src/nirvana/CMakeLists.txt
 cd src/nirvana && ./CMakeLists.gen && cd ../..
+echo Generating src/ui/CMakeLists.txt
+cd src/ui && ./CMakeLists.gen && cd ../..
 echo Generating src/client/CMakeLists.txt
 cd src/client  && ./CMakeLists.gen && cd ../..
 echo Generating src/server/CMakeLists.txt
diff --git a/count.sh b/count.sh
index b7a24c6..7cef570 100755
--- a/count.sh
+++ b/count.sh
@@ -2,7 +2,7 @@
 
 FILES="src/*/*.h src/*/*.cpp src/*/*.gen *.h *.sh src/CMakeLists.txt CMakeLists.txt"
 
-wc -cl $FILES
+wc -l $FILES
 
 (( nFiles = 0 ))
 for file in $FILES; do
@@ -16,5 +16,5 @@ unset nFiles
 unset FILES
 
 if [ -x /usr/bin/sloccount ]; then
-  LANG=C /usr/bin/sloccount src/base src/matrix src/nirvana src/client src/server src/test *.h *.sh
+  LANG=C /usr/bin/sloccount src/base src/matrix src/nirvana src/ui src/client src/server src/test *.h *.sh
 fi
diff --git a/src/CMakeLists.txt b/src/CMakeLists.txt
index c82a196..3df0bd3 100644
--- a/src/CMakeLists.txt
+++ b/src/CMakeLists.txt
@@ -1,4 +1,3 @@
 include_directories( . )
 
-subdirs( base matrix nirvana client server )
-# subdirs( base test )
+subdirs( base matrix nirvana ui client server test )
diff --git a/src/base/Bitset.h b/src/base/Bitset.h
index f74323f..a0710d7 100644
--- a/src/base/Bitset.h
+++ b/src/base/Bitset.h
@@ -23,9 +23,6 @@ namespace oz
       // Number of bits per unit.
       static const int ULONG_BITSIZE = sizeof( ulong ) * 8;
 
-      // 0xfff...f
-      static const ulong ULONG_ALLBITS = ~0ul;
-
       // Pointer to unit[] that holds the data.
       ulong *data;
 
@@ -183,7 +180,7 @@ namespace oz
       {
         assert( 0 <= i && i < ( size * ULONG_BITSIZE ) );
 
-        return ( data[i / ULONG_BITSIZE] & ( 1 << ( i % ULONG_BITSIZE ) ) ) != 0;
+        return ( data[i / ULONG_BITSIZE] & ( 1ul << ( i % ULONG_BITSIZE ) ) ) != 0ul;
       }
 
       /**
@@ -194,7 +191,7 @@ namespace oz
       {
         assert( 0 <= i && i < ( size * ULONG_BITSIZE ) );
 
-        data[i / ULONG_BITSIZE] |= 1 << ( i % ULONG_BITSIZE );
+        data[i / ULONG_BITSIZE] |= 1ul << ( i % ULONG_BITSIZE );
       }
 
       /**
@@ -205,7 +202,7 @@ namespace oz
       {
         assert( 0 <= i && i < ( size * ULONG_BITSIZE ) );
 
-        data[i / ULONG_BITSIZE] &= ~( 1 << ( i % ULONG_BITSIZE ) );
+        data[i / ULONG_BITSIZE] &= ~( 1ul << ( i % ULONG_BITSIZE ) );
       }
 
       /**
@@ -214,7 +211,7 @@ namespace oz
       bool isAllSet() const
       {
         for( int i = 0; i < size; i++ ) {
-          if( data[i] != ULONG_ALLBITS ) {
+          if( data[i] != ~0ul ) {
             return false;
           }
         }
@@ -227,7 +224,7 @@ namespace oz
       bool isAllClear() const
       {
         for( int i = 0; i < size; i++ ) {
-          if( data[i] != 0 ) {
+          if( data[i] != 0ul ) {
             return false;
           }
         }
@@ -249,8 +246,8 @@ namespace oz
         int endUnit     = end / ULONG_BITSIZE;
         int endOffset   = end % ULONG_BITSIZE;
 
-        ulong startMask = ULONG_ALLBITS << startOffset;
-        ulong endMask   = ~( ULONG_ALLBITS << endOffset );
+        ulong startMask = ~0ul << startOffset;
+        ulong endMask   = ~( ~0ul << endOffset );
 
         if( startUnit == endUnit ) {
           data[startUnit] |= startMask & endMask;
@@ -260,7 +257,7 @@ namespace oz
           data[endUnit]   |= endMask;
 
           for( int i = startUnit + 1; i < endUnit; i++ ) {
-            data[i] = ULONG_ALLBITS;
+            data[i] = ~0ul;
           }
         }
       }
@@ -280,8 +277,8 @@ namespace oz
         int endUnit     = end / ULONG_BITSIZE;
         int endOffset   = end % ULONG_BITSIZE;
 
-        ulong startMask = ~( ULONG_ALLBITS << startOffset );
-        ulong endMask   = ULONG_ALLBITS << endOffset;
+        ulong startMask = ~( ~0ul << startOffset );
+        ulong endMask   = ~0ul << endOffset;
 
         if( startUnit == endUnit ) {
           data[startUnit] &= startMask | endMask;
@@ -291,7 +288,7 @@ namespace oz
           data[endUnit]   &= endMask;
 
           for( int i = startUnit + 1; i < endUnit; i++ ) {
-            data[i] = 0;
+            data[i] = 0ul;
           }
         }
       }
@@ -301,7 +298,7 @@ namespace oz
        */
       void setAll()
       {
-        aSet( data, ULONG_ALLBITS, size );
+        aSet( data, ~0ul, size );
       }
 
       /**
@@ -309,7 +306,7 @@ namespace oz
        */
       void clearAll()
       {
-        aSet( data, 0, size );
+        aSet( data, 0ul, size );
       }
 
       /**
@@ -394,7 +391,7 @@ namespace oz
         Bitset r( size );
 
         for( int i = 0; i < size; i++ ) {
-          if( ( data[i] & ~b.data[i] ) != 0 ) {
+          if( ( data[i] & ~b.data[i] ) != 0ul ) {
             return false;
           }
         }
diff --git a/src/base/Config.cpp b/src/base/Config.cpp
index 3341a23..df5d1cd 100644
--- a/src/base/Config.cpp
+++ b/src/base/Config.cpp
@@ -80,15 +80,13 @@ namespace oz
     }
   }
 
-  bool Config::load( const char *file )
+  bool Config::load( const char *path )
   {
-    logFile.print( "Reading variables from '%s' ...", file );
-
-    xmlTextReader *reader = xmlReaderForFile( file, null, 0 );
+    xmlTextReader *reader = xmlReaderForFile( path, null, 0 );
 
     if( reader == null ) {
       xmlCleanupParser();
-      logFile.printEnd( " Cannot open file" );
+      logFile.printEnd( "Error reading variables from '%s' ... Cannot open file", path );
       return false;
     }
 
@@ -120,13 +118,10 @@ namespace oz
     xmlCleanupParser();
 
     if( error != 0 ) {
-      logFile.printEnd( " Parse error" );
+      logFile.printEnd( "Error reading variables from '%s' ... Parse error", path );
       return false;
     }
-    else {
-      logFile.printEnd( " OK" );
-      return true;
-    }
+    return true;
   }
 
   bool Config::save( const char *file )
diff --git a/src/base/Config.h b/src/base/Config.h
index 5bff56c..a05aec0 100644
--- a/src/base/Config.h
+++ b/src/base/Config.h
@@ -133,7 +133,7 @@ namespace oz
        * @param file file path
        * @return true if successful
        */
-      bool save( const char *file );
+      bool save( const char *path );
 
       /**
        * Clear variables.
diff --git a/src/base/HashIndex.h b/src/base/HashIndex.h
index 937b740..d8f2c73 100644
--- a/src/base/HashIndex.h
+++ b/src/base/HashIndex.h
@@ -20,9 +20,9 @@ namespace oz
 
       struct Elem : PoolAlloc<Elem, 0>
       {
-        uint  key;
-        Type  value;
-        Elem  *next[1];
+        uint key;
+        Type value;
+        Elem *next[1];
 
         explicit Elem( uint key_, const Type &value_, Elem *next_ ) : key( key_ ), value( value_ )
         {
diff --git a/src/base/Mat33.h b/src/base/Mat33.h
index b245447..5b4408b 100644
--- a/src/base/Mat33.h
+++ b/src/base/Mat33.h
@@ -282,6 +282,8 @@ namespace oz
 
     Mat33 &operator /= ( float k )
     {
+      assert( k != 0.0f );
+
       k = 1.0f / k;
       m[0] *= k;
       m[1] *= k;
@@ -319,6 +321,8 @@ namespace oz
 
     Mat33 operator / ( float k ) const
     {
+      assert( k != 0.0f );
+
       k = 1.0f / k;
       return Mat33( m[0] * k, m[1] * k, m[2] * k,
                     m[3] * k, m[4] * k, m[5] * k,
diff --git a/src/base/Mat44.h b/src/base/Mat44.h
index e52c1dc..58592c6 100644
--- a/src/base/Mat44.h
+++ b/src/base/Mat44.h
@@ -389,6 +389,8 @@ namespace oz
 
     Mat44 &operator /= ( float k )
     {
+      assert( k != 0.0f );
+
       k = 1.0f / k;
       m[ 0] *= k;
       m[ 1] *= k;
@@ -435,6 +437,8 @@ namespace oz
 
     Mat44 operator / ( float k ) const
     {
+      assert( k != 0.0f );
+
       k = 1.0f / k;
       return Mat44( m[ 0] * k, m[ 1] * k, m[ 2] * k, m[ 3] * k,
                     m[ 4] * k, m[ 5] * k, m[ 6] * k, m[ 7] * k,
diff --git a/src/base/Quat.h b/src/base/Quat.h
index bb36028..d34dfd3 100644
--- a/src/base/Quat.h
+++ b/src/base/Quat.h
@@ -196,6 +196,8 @@ namespace oz
 
     Quat &operator /= ( float k )
     {
+      assert( k != 0.0f );
+
       k = 1.0f / k;
       x *= k;
       y *= k;
@@ -234,6 +236,8 @@ namespace oz
 
     Quat operator / ( float k ) const
     {
+      assert( k != 0.0f );
+
       k = 1.0f / k;
       return Quat( x * k, y * k, z * k, w * k );
     }
@@ -305,7 +309,7 @@ namespace oz
     }
 
     // rotZ ^ rotX ^ rotY
-    static Quat rotZXY( float x, float y, float z )
+    static Quat rotZYX( float z, float y, float x )
     {
       float sx, cx, sy, cy, sz, cz;
 
diff --git a/src/base/String.h b/src/base/String.h
index 1139310..31fa63c 100644
--- a/src/base/String.h
+++ b/src/base/String.h
@@ -54,6 +54,16 @@ namespace oz
         aCopy( buffer, s, count + 1 );
       }
 
+      String( const char *s, int count_ ) : count( count_ )
+      {
+        assert( s != null );
+        assert( length( s ) >= count );
+
+        ensureCapacity();
+        aCopy( buffer, s, count );
+        buffer[count] = '\0';
+      }
+
       String( bool b ) : buffer( baseBuffer )
       {
         // some protection against too small buffers
@@ -392,6 +402,22 @@ namespace oz
         return r;
       }
 
+      String trim() const
+      {
+        char *start = buffer;
+        char *end = buffer + count;
+
+        while( start < end && ( *start == ' ' || *start == '\t' || *start == '\n' ) ) {
+          start++;
+        }
+        do {
+          end--;
+        }
+        while( start < end && ( *end == ' ' || *end == '\t' || *end == '\n' ) );
+
+        return String( start, end - start );
+      }
+
       Vector<String> split( char ch ) const
       {
         Vector<String> v;
diff --git a/src/base/Vec3.h b/src/base/Vec3.h
index 432c99d..a9764e1 100644
--- a/src/base/Vec3.h
+++ b/src/base/Vec3.h
@@ -122,7 +122,6 @@ namespace oz
       return Vec3( x * r, y * r, z * r );
     }
 
-    // normize
     Vec3 &norm()
     {
       assert( x*x + y*y + z*z > 0.0f );
@@ -178,6 +177,8 @@ namespace oz
 
     Vec3 &operator /= ( float k )
     {
+      assert( k != 0.0f );
+
       k = 1.0f / k;
       x *= k;
       y *= k;
@@ -202,6 +203,8 @@ namespace oz
 
     Vec3 operator / ( float k ) const
     {
+      assert( k != 0.0f );
+
       k = 1.0f / k;
       return Vec3( x * k, y * k, z * k );
     }
diff --git a/src/base/base.h b/src/base/base.h
index 3f8795a..a70cb03 100644
--- a/src/base/base.h
+++ b/src/base/base.h
@@ -2,8 +2,7 @@
  *  base.h
  *
  *  Common include file.
- *  It is included in "precompiled.h", so include the latter instead of this file for faster
- *  compiling.
+ *  It is included via "precompiled.h" for faster compiling.
  *
  *  Copyright (C) 2002-2009, Davorin Učakar <davorin.ucakar@gmail.com>
  */
@@ -74,11 +73,6 @@
 #include "Mat44.h"
 
 /*
- * Exception
- */
-#include "Exception.h"
-
-/*
  * Utilities
  */
 #include "Exception.h"
diff --git a/src/client/Audio.cpp b/src/client/Audio.cpp
index ac07bc4..5681770 100644
--- a/src/client/Audio.cpp
+++ b/src/client/Audio.cpp
@@ -19,12 +19,12 @@ namespace oz
 namespace client
 {
 
-  void Audio::playSoundEvent( const Object::Event *event ) const
+  void Audio::playSoundEvent( int sample ) const
   {
     ALuint srcId;
 
     alGenSources( 1, &srcId );
-    alSourcei( srcId, AL_BUFFER, context.requestSound( event->id ) );
+    alSourcei( srcId, AL_BUFFER, context.sounds[sample].id );
     alSourcef( srcId, AL_REFERENCE_DISTANCE, 2.0f );
 
     // If the object moves since source starts playing and source stands still, it's usually
@@ -34,7 +34,7 @@ namespace client
     // However, when the sound is generated by player (e.g. cries, talk) it is often annoying
     // if the sound source doesn't move with the player. That's why we position the sounds
     // generated by the player at the origin of the coordinate system relative to player.
-    if( &*object == camera.player ) {
+    if( &*object == camera.bot ) {
       alSourcei( srcId, AL_SOURCE_RELATIVE, AL_TRUE );
       alSourcefv( srcId, AL_POSITION, Vec3::zero() );
     }
@@ -46,26 +46,50 @@ namespace client
     soundManager.addSource( srcId );
   }
 
-  void Audio::playSoundEffect( const Object::Effect *effect ) const
+  void Audio::playSoundEffect( int sample, uint key ) const
   {
-    if( soundManager.updateContSource( effect ) ) {
+    if( soundManager.updateContSource( key ) ) {
       alSourcefv( soundManager.getCachedContSourceId(), AL_POSITION, object->p );
     }
     else {
       ALuint srcId;
 
       alGenSources( 1, &srcId );
-      alSourcei( srcId, AL_BUFFER, context.requestSound( effect->id ) );
+      alSourcei( srcId, AL_BUFFER, context.sounds[sample].id );
       alSourcefv( srcId, AL_POSITION, object->p );
       alSourcei( srcId, AL_LOOPING, AL_TRUE );
       alSourcePlay( srcId );
 
-      soundManager.addContSource( effect, srcId );
+      soundManager.addContSource( key, srcId );
+    }
+  }
+
+  void Audio::requestSounds() const
+  {
+    int *samples = object->type->audioSamples;
+
+    for( int i = 0; i < ObjectClass::AUDIO_SAMPLES; i++ ) {
+      if( samples[i] >= 0 ) {
+        context.requestSound( samples[i] );
+      }
+    }
+  }
+
+  inline void Audio::releaseSounds() const
+  {
+    int *samples = object->type->audioSamples;
+
+    for( int i = 0; i < ObjectClass::AUDIO_SAMPLES; i++ ) {
+      if( samples[i] >= 0 ) {
+        context.releaseSound( samples[i] );
+      }
     }
   }
 
   Audio::~Audio()
-  {}
+  {
+    releaseSounds();
+  }
 
 }
 }
diff --git a/src/client/Audio.h b/src/client/Audio.h
index 893eb26..394c78e 100644
--- a/src/client/Audio.h
+++ b/src/client/Audio.h
@@ -25,8 +25,10 @@ namespace client
 
       const Object *object;
 
-      void playSoundEvent( const Object::Event *event ) const;
-      void playSoundEffect( const Object::Effect *effect ) const;
+      void playSoundEvent( int sample ) const;
+      void playSoundEffect( int sample, uint key ) const;
+      void requestSounds() const;
+      void releaseSounds() const;
 
     public:
 
diff --git a/src/client/BSP.cpp b/src/client/BSP.cpp
index f5a53c0..1526d32 100644
--- a/src/client/BSP.cpp
+++ b/src/client/BSP.cpp
@@ -264,15 +264,17 @@ namespace client
     bool isInWater = isInWaterBrush( relPos, leaf );
 
     if( bsp->visual.bitsets != null ) {
-      // TODO: rotated BSPs
 //       int    cluster = bsp->leafs[ getLeafIndex( camera.p ) ].cluster;
 //       printf( "%d\n", getLeafIndex( camera.p ) );
 //       Bitset &bitset = bsp->visual.bitsets[cluster];
 
       for( int i = 0; i < bsp->nLeafs; i++ ) {
         oz::BSP::Leaf &leaf = bsp->leafs[i];
+        Bounds rotatedLeaf = rotateBounds( leaf, str->rot );
 
-//         if( ( cluster < 0 || bitset.get( leaf.cluster ) ) && frustum.isVisible( leaf + t.p() ) ) {
+//         if( ( cluster < 0 || bitset.get( leaf.cluster ) ) &&
+//             frustum.isVisible( rotetedLeaf + str->p ) )
+        {
           for( int j = 0; j < leaf.nFaces; j++ ) {
             int faceIndex = bsp->leafFaces[leaf.firstFace + j];
 
@@ -281,14 +283,15 @@ namespace client
               drawnFaces.set( faceIndex );
             }
           }
-//         }
+        }
       }
     }
     else {
       for( int i = 0; i < bsp->nLeafs; i++ ) {
         oz::BSP::Leaf &leaf = bsp->leafs[i];
+        Bounds rotatedLeaf = rotateBounds( leaf, str->rot );
 
-//         if( frustum.isVisible( leaf + t.p() ) ) {
+        if( frustum.isVisible( rotatedLeaf + str->p ) ) {
           for( int j = 0; j < leaf.nFaces; j++ ) {
             int faceIndex = bsp->leafFaces[leaf.firstFace + j];
 
@@ -297,7 +300,7 @@ namespace client
               drawnFaces.set( faceIndex );
             }
           }
-//         }
+        }
       }
     }
     glPopMatrix();
diff --git a/src/client/BSP.h b/src/client/BSP.h
index 91b8b01..7dd17fd 100644
--- a/src/client/BSP.h
+++ b/src/client/BSP.h
@@ -40,6 +40,50 @@ namespace client
       Bitset visibleLeafs;
       Bitset hiddenFaces;
 
+      static Bounds rotateBounds( const Bounds &bounds, Structure::Rotation rotation )
+      {
+        Bounds rotatedBounds;
+
+        switch( rotation ) {
+          case Structure::R0: {
+            rotatedBounds = bounds;
+            break;
+          }
+          case Structure::R90: {
+            rotatedBounds.mins.x = -bounds.maxs.y;
+            rotatedBounds.mins.y =  bounds.mins.x;
+            rotatedBounds.mins.z =  bounds.mins.z;
+
+            rotatedBounds.maxs.x = -bounds.mins.y;
+            rotatedBounds.maxs.y =  bounds.maxs.x;
+            rotatedBounds.maxs.z =  bounds.maxs.z;
+            break;
+          }
+          case Structure::R180: {
+            rotatedBounds.mins.x = -bounds.maxs.x;
+            rotatedBounds.mins.y = -bounds.maxs.y;
+            rotatedBounds.mins.z =  bounds.mins.z;
+
+            rotatedBounds.maxs.x = -bounds.mins.x;
+            rotatedBounds.maxs.y = -bounds.mins.y;
+            rotatedBounds.maxs.z =  bounds.maxs.z;
+            break;
+          }
+          default:
+          case Structure::R270: {
+            rotatedBounds.mins.x =  bounds.mins.y;
+            rotatedBounds.mins.y = -bounds.maxs.x;
+            rotatedBounds.mins.z =  bounds.mins.z;
+
+            rotatedBounds.maxs.x =  bounds.maxs.y;
+            rotatedBounds.maxs.y = -bounds.mins.x;
+            rotatedBounds.maxs.z =  bounds.maxs.z;
+            break;
+          }
+        }
+        return bounds;
+      }
+
       const oz::BSP::Leaf *getLeaf( const Vec3 &p ) const;
       bool isInWaterBrush( const Vec3 &p, const oz::BSP::Leaf *leaf ) const;
 
diff --git a/src/client/CMakeLists.gen b/src/client/CMakeLists.gen
index 82dd2dc..02c4673 100755
--- a/src/client/CMakeLists.gen
+++ b/src/client/CMakeLists.gen
@@ -1,7 +1,7 @@
 #!/bin/sh
 
 cat << EOF > CMakeLists.txt
-link_libraries( nirvana matrix base )
+link_libraries( ui nirvana matrix base )
 
 add_executable( openzone
 EOF
diff --git a/src/client/Camera.cpp b/src/client/Camera.cpp
index 99dc945..02b09fc 100644
--- a/src/client/Camera.cpp
+++ b/src/client/Camera.cpp
@@ -17,14 +17,20 @@ namespace client
 
   Camera camera;
 
-  Camera::Camera() : h( 0.0f ), v( 0.0f ), r( 0.0f )
+  Camera::Camera()
   {
     p.setZero();
-    at = Vec3( 0.0f, 1.0f, 0.0f );
-    up = Vec3( 0.0f, 0.0f, 1.0f );
+    h = 0.0f;
+    v = 0.0f;
 
-    rotMat.setId();
-    rotTMat.setId();
+    rot.setId();
+    relRot.setId();
+
+    rotMat = rot.rotMat44();
+    rotTMat = ~rotTMat;
+
+    at = rotTMat.y();
+    up = rotTMat.z();
   }
 
   void Camera::init()
@@ -33,29 +39,25 @@ namespace client
     smoothCoef_1 = 1.0f - smoothCoef;
   }
 
-  void Camera::update()
+  void Camera::postUpdate()
   {
-    h = player->h;
-    v = player->v;
-    p = ( player->p + player->camPos ) * smoothCoef_1 + oldP * smoothCoef;
     oldP = p;
+    relRot = Quat::rotZYX( Math::rad( h ), 0.0f, Math::rad( v ) );
 
-    float hRad = Math::rad( h );
-    float vRad = Math::rad( v );
-    float hSine, hCosine, vSine, vCosine;
-
-    Math::sincos( hRad, &hSine, &hCosine );
-    Math::sincos( vRad, &vSine, &vCosine );
-
-    at = Vec3( -hSine * vCosine,  hCosine * vCosine, vSine );
-    up = Vec3(  hSine * vSine,   -hCosine * vSine,   vCosine );
+    if( bot != null ) {
+      p = ( bot->p + bot->camPos ) * smoothCoef_1 + oldP * smoothCoef;
+      rot = Quat::rotZYX( Math::rad( bot->h + h ), 0.0f, Math::rad( bot->v + v ) );
+    }
+    else {
+      rot = relRot;
+    }
 
-    rotTMat = Mat44( hCosine, -hSine   * vCosine,  hSine   * vSine, 0.0f,
-                     hSine,    hCosine * vCosine, -hCosine * vSine, 0.0f,
-                     0.0f,     vSine,              vCosine,         0.0f,
-                     0.0f,     0.0f,               0.0f,            1.0f );
+    rotMat = rot.rotMat44();
+    rotTMat = ~rotMat;
 
-    rotMat = ~rotTMat;
+    right = rotMat.x();
+    at = rotMat.y();
+    up = rotMat.z();
   }
 
 }
diff --git a/src/client/Camera.h b/src/client/Camera.h
index 3cd8120..f8a519d 100644
--- a/src/client/Camera.h
+++ b/src/client/Camera.h
@@ -24,26 +24,40 @@ namespace client
 
     public:
 
-      Vec3   p;
-      Vec3   oldP;
-      float  h;
-      float  v;
-      float  r;
+      Vec3  p;
+      Vec3  oldP;
 
-      Vec3   at;
-      Vec3   up;
+      // relative to the object the camera is bound to
+      float h;
+      float v;
 
-      Mat44  rotMat;
-      Mat44  rotTMat;
+      Quat  relRot;
+      Quat  rot;
 
-      Bot    *player;
-      World  *world;
-      Matrix *matrix;
+      // global rotation matrix and it's inverse
+      Mat44 rotMat;
+      Mat44 rotTMat;
+
+      Vec3  right;
+      Vec3  at;
+      Vec3  up;
+
+      int   botIndex;
+      Bot   *bot;
 
       Camera();
 
       void init();
-      void update();
+
+      void preUpdate()
+      {
+        bot = botIndex == -1 ? null : (Bot*) world.objects[botIndex];
+        if( bot == null ) {
+          botIndex = -1;
+        }
+      }
+
+      void postUpdate();
   };
 
   extern Camera camera;
diff --git a/src/client/Context.cpp b/src/client/Context.cpp
index d6b2ae2..9dc8ae6 100644
--- a/src/client/Context.cpp
+++ b/src/client/Context.cpp
@@ -33,7 +33,7 @@ namespace client
   uint Context::buildTexture( const ubyte *data, int width, int height, int bytesPerPixel,
                               bool wrap, int magFilter, int minFilter )
   {
-//     assert( glGetError() == GL_NO_ERROR );
+    assert( glGetError() == GL_NO_ERROR );
 
     GLenum format = bytesPerPixel == 4 ? GL_RGBA : GL_RGB;
 
@@ -61,14 +61,14 @@ namespace client
 
     glTexEnvf( GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE );
 
-//     if( glGetError() != GL_NO_ERROR ) {
-//       glDeleteTextures( 1, &texNum );
-//       texNum = ~0;
-//
-//       do {
-//       }
-//       while( glGetError() != GL_NO_ERROR );
-//     }
+    if( glGetError() != GL_NO_ERROR ) {
+      glDeleteTextures( 1, &texNum );
+      texNum = ~0;
+
+      do {
+      }
+      while( glGetError() != GL_NO_ERROR );
+    }
     return texNum;
   }
 
@@ -132,35 +132,23 @@ namespace client
   uint Context::createTexture( const ubyte *data, int width, int height, int bytesPerPixel,
                                bool wrap, int magFilter, int minFilter )
   {
-    logFile.print( "Creating texture from buffer ..." );
-
     int texNum = buildTexture( data, width, height, bytesPerPixel, wrap, magFilter, minFilter );
 
     if( texNum == ~0 ) {
-      logFile.printEnd( " Error" );
+      logFile.println( "Error creating texture from buffer" );
     }
-    else {
-      logFile.printEnd( " OK" );
-    }
-
     return texNum;
   }
 
   uint Context::createNormalmap( ubyte *data, const Vec3 &lightNormal, int width, int height,
                                  int bytesPerPixel, bool wrap, int magFilter, int minFilter )
   {
-    logFile.print( "Creating normalmap texture from buffer ..." );
-
     int texNum = buildNormalmap( data, lightNormal, width, height, bytesPerPixel, wrap,
                                  magFilter, minFilter );
 
     if( texNum == ~0 ) {
-      logFile.printEnd( " Error" );
-    }
-    else {
-      logFile.printEnd( " OK" );
+      logFile.println( "Error creating normalmap texture from buffer" );
     }
-
     return texNum;
   }
 
@@ -170,20 +158,20 @@ namespace client
       textures[resource].nUsers++;
       return textures[resource].id;
     }
+    textures[resource].nUsers = 1;
 
-    String fileName = translator.textures[resource];
+    String &name = translator.textures[resource].name;
+    String &path = translator.textures[resource].path;
 
-    logFile.print( "Loading registered texture '%s' ...", fileName.cstr() );
+    logFile.print( "Loading registered texture '%s' ...", name.cstr() );
 
-    SDL_Surface *image = IMG_Load( fileName.cstr() );
+    SDL_Surface *image = IMG_Load( path.cstr() );
     if( image == null ) {
       logFile.printEnd( " No such file" );
       return 0;
     }
     logFile.printEnd( " OK" );
 
-    assert( image->w == image->h );
-
     int bytesPerPixel = image->format->BitsPerPixel / 8;
     int texNum = createTexture( (const ubyte*) image->pixels, image->w, image->h,
                                 bytesPerPixel, wrap, magFilter, minFilter );
@@ -191,7 +179,6 @@ namespace client
     SDL_FreeSurface( image );
 
     textures[resource].id = texNum;
-    textures[resource].nUsers = 1;
     return texNum;
   }
 
@@ -202,20 +189,20 @@ namespace client
       textures[resource].nUsers++;
       return textures[resource].id;
     }
+    textures[resource].nUsers = 1;
 
-    String fileName = translator.textures[resource];
+    String &name = translator.textures[resource].name;
+    String &path = translator.textures[resource].path;
 
-    logFile.print( "Loading registerded normalmap texture '%s' ...", fileName.cstr() );
+    logFile.print( "Loading registerded normalmap texture '%s' ...", name.cstr() );
 
-    SDL_Surface *image = IMG_Load( fileName.cstr() );
+    SDL_Surface *image = IMG_Load( path.cstr() );
     if( image == null ) {
       logFile.printEnd( " No such file" );
       return 0;
     }
     logFile.printEnd( " OK" );
 
-    assert( image->w == image->h );
-
     int bytesPerPixel = image->format->BitsPerPixel / 8;
     int texNum = createNormalmap( (ubyte*) image->pixels, lightNormal, image->w, image->h,
                                   bytesPerPixel, wrap, magFilter, minFilter );
@@ -223,7 +210,6 @@ namespace client
     SDL_FreeSurface( image );
 
     textures[resource].id = texNum;
-    textures[resource].nUsers = 1;
     return texNum;
   }
 
@@ -239,19 +225,17 @@ namespace client
     }
   }
 
-  uint Context::loadTexture( const char *fileName, bool wrap, int magFilter, int minFilter )
+  uint Context::loadTexture( const char *path, bool wrap, int magFilter, int minFilter )
   {
-    logFile.print( "Loading texture from file '%s' ...", fileName );
+    logFile.print( "Loading texture from file '%s' ...", path );
 
-    SDL_Surface *image = IMG_Load( fileName );
+    SDL_Surface *image = IMG_Load( path );
     if( image == null ) {
       logFile.printEnd( " No such file" );
       return 0;
     }
     logFile.printEnd( " OK" );
 
-//     assert( image->w == image->h );
-
     int bytesPerPixel = image->format->BitsPerPixel / 8;
     int texNum = createTexture( (const ubyte*) image->pixels, image->w, image->h,
                                 bytesPerPixel, wrap, magFilter, minFilter );
@@ -261,20 +245,18 @@ namespace client
     return texNum;
   }
 
-  uint Context::loadNormalmap( const char *fileName, const Vec3 &lightNormal,
+  uint Context::loadNormalmap( const char *path, const Vec3 &lightNormal,
                                bool wrap, int magFilter, int minFilter )
   {
-    logFile.print( "Loading normalmap texture from file '%s' ...", fileName );
+    logFile.print( "Loading normalmap texture from file '%s' ...", path );
 
-    SDL_Surface *image = IMG_Load( fileName );
+    SDL_Surface *image = IMG_Load( path );
     if( image == null ) {
       logFile.printEnd( " No such file" );
       return 0;
     }
     logFile.printEnd( " OK" );
 
-    assert( image->w == image->h );
-
     int bytesPerPixel = image->format->BitsPerPixel / 8;
     int texNum = createNormalmap( (ubyte*) image->pixels, lightNormal, image->w, image->h,
                                   bytesPerPixel, wrap, magFilter, minFilter );
@@ -295,48 +277,50 @@ namespace client
       sounds[resource].nUsers++;
       return sounds[resource].id;
     }
+    sounds[resource].nUsers = 1;
 
-    const char *file = translator.sounds[resource].cstr();
-    logFile.print( "Loading sound '%s' ...", file );
+    const String &path = translator.sounds[resource].path;
+    logFile.print( "Loading sound '%s' ...", translator.sounds[resource].name.cstr() );
 
-    const char *ext = strrchr( file, '.' );
+    int dot = path.lastIndex( '.' );
+    if( dot <= 0 ) {
+      logFile.printEnd( " Extension missing" );
+      return false;
+    }
+    String extension = path.substring( dot );
 
-    if( String::equals( ext, ".wav" ) ) {
-      sounds[resource].id = alutCreateBufferFromFile( file );
+    if( String::equals( extension, ".au" ) || String::equals( extension, ".wav" ) ) {
+      sounds[resource].id = alutCreateBufferFromFile( path );
 
       if( sounds[resource].id == AL_NONE ) {
         logFile.printEnd( " Failed" );
         return AL_NONE;
       }
-      else {
-        logFile.printEnd( " OK" );
-        return sounds[resource].id;
-      }
     }
-    else if( String::equals( ext, ".ogg" ) || String::equals( ext, ".oga" ) ) {
-      // FIXME: make this loader work
-      FILE *oggFile = fopen( file, "rb" );
+    else if( String::equals( extension, ".oga" ) || String::equals( extension, ".ogg" ) ) {
+      // FIXME make this loader work
+      FILE           *oggFile = fopen( path, "rb" );
+      OggVorbis_File oggStream;
+      vorbis_info    *vorbisInfo;
+      ALenum         format;
 
       if( oggFile == null ) {
         logFile.printEnd( " Failed to open file" );
-        return AL_NONE;
+        return false;
       }
-
-      OggVorbis_File oggStream;
       if( ov_open( oggFile, &oggStream, null, 0 ) < 0 ) {
         fclose( oggFile );
         logFile.printEnd( " Failed to open Ogg stream" );
-        return AL_NONE;
+        return false;
       }
 
-      vorbis_info *vorbisInfo = ov_info( &oggStream, -1 );
+      vorbisInfo = ov_info( &oggStream, -1 );
       if( vorbisInfo == null ) {
         ov_clear( &oggStream );
         logFile.printEnd( " Failed to read Vorbis header" );
-        return AL_NONE;
+        return false;
       }
 
-      ALenum format;
       if( vorbisInfo->channels == 1 ) {
         format = AL_FORMAT_MONO16;
       }
@@ -355,35 +339,32 @@ namespace client
       int  bytesRead = 0;
       int  result;
       do {
-        result = ov_read( &oggStream, data + bytesRead, size - bytesRead, 0, 2, 1, &section );
-        if( result <= 0 ) {
-          break;
-//           ov_clear( &oggStream );
-//           fclose( oggFile );
-//           logFile.printEnd( " Failed to decode Vorbis stream, error %d", result );
-//           return AL_NONE;
-        }
+        result = ov_read( &oggStream, &data[bytesRead], size - bytesRead, 0, 2, 1, &section );
         bytesRead += result;
+        if( result < 0 ) {
+          ov_clear( &oggStream );
+          logFile.printEnd( " Failed to decode Vorbis stream, error %d", result );
+          return AL_NONE;
+        }
       }
       while( result > 0 && bytesRead < size );
 
       ov_clear( &oggStream );
 
       alGenBuffers( 1, &sounds[resource].id );
-      alBufferData( sounds[resource].id, format, data, size, vorbisInfo->rate );
+      alBufferData( sounds[resource].id, format, data, bytesRead, vorbisInfo->rate );
       if( alGetError() != AL_NO_ERROR ) {
-        logFile.printEnd( " Failed create buffer" );
+        logFile.printEnd( " Failed to create buffer" );
         return AL_NONE;
       }
-      logFile.printEnd( " OK" );
-
-      sounds[resource].nUsers = 1;
-      return sounds[resource].id;
     }
     else {
-      logFile.printEnd( " Unknown file extension" );
+      logFile.printEnd( " Unknown file extension '%s'", extension.cstr() );
       return AL_NONE;
     }
+
+    logFile.printEnd( " OK" );
+    return sounds[resource].id;
   }
 
   void Context::releaseSound( int resource )
@@ -468,7 +449,6 @@ namespace client
   {
     assert( textures == null && sounds == null );
 
-    logFile.println( "Context created" );
     textures = new Resource<uint>[translator.textures.length()];
     sounds = new Resource<uint>[translator.sounds.length()];
 
@@ -503,6 +483,7 @@ namespace client
     objModels.clear();
 
     modelClasses.clear();
+    audioClasses.clear();
   }
 
 }
diff --git a/src/client/Context.h b/src/client/Context.h
index 48dedaf..33fa085 100644
--- a/src/client/Context.h
+++ b/src/client/Context.h
@@ -31,11 +31,17 @@ namespace client
       struct Lists
       {
         uint base;
-        int count;
-        // TODO union
-        int nextSlot;
+
+        // we can use union here, those two members are never in use at the same time
+        union
+        {
+          int count;
+          int nextSlot;
+        };
       };
 
+    public:
+
       template <class Type>
       struct Resource
       {
@@ -57,6 +63,9 @@ namespace client
 
       Resource<uint> *textures;
       Resource<uint> *sounds;
+
+    private:
+
       Sparse<Lists>  lists;
 
       HashString< Resource<MD2*>, 253 > md2Models;
@@ -105,12 +114,12 @@ namespace client
 
       void releaseTexture( int resource );
 
-      uint loadTexture( const char *file,
+      uint loadTexture( const char *path,
                         bool wrap = true,
                         int magFilter = DEFAULT_MAG_FILTER,
                         int minFilter = DEFAULT_MIN_FILTER );
 
-      uint loadNormalmap( const char *file,
+      uint loadNormalmap( const char *path,
                           const Vec3 &lightNormal,
                           bool wrap = true,
                           int magFilter = DEFAULT_MAG_FILTER,
@@ -125,11 +134,11 @@ namespace client
       uint genLists( int count );
       void freeLists( uint listId );
 
-      MD2  *loadMD2Model( const char *path );
-      uint loadMD2StaticModel( const char *path );
-      MD3  *loadMD3Model( const char *path );
-      uint loadMD3StaticModel( const char *path );
-      uint loadOBJModel( const char *path );
+      MD2  *loadMD2Model( const char *name );
+      uint loadMD2StaticModel( const char *name );
+      MD3  *loadMD3Model( const char *name );
+      uint loadMD3StaticModel( const char *name );
+      uint loadOBJModel( const char *name );
 
       Model *createModel( const Object *obj )
       {
diff --git a/src/client/Game.cpp b/src/client/Game.cpp
index 961fea7..f4859db 100644
--- a/src/client/Game.cpp
+++ b/src/client/Game.cpp
@@ -12,6 +12,7 @@
 
 #include "matrix/Timer.h"
 #include "matrix/Bot.h"
+#include "matrix/BotClass.h"
 #include "matrix/Matrix.h"
 #include "nirvana/Nirvana.h"
 #include "Network.h"
@@ -25,6 +26,9 @@ namespace client
 
   Game game;
 
+  const float Game::FREECAM_SLOW_SPEED = 0.04f;
+  const float Game::FREECAM_FAST_SPEED = 0.40f;
+
   bool Game::init()
   {
     mouseXSens = config.get( "input.mouse.xSens", 0.2f );
@@ -46,8 +50,8 @@ namespace client
     logFile.unindent();
     logFile.println( "}" );
 
-    camera.player = (Bot*) world.objects[0];
-    camera.oldP = camera.player->p;
+    camera.botIndex = -1;
+    camera.oldP = world.objects[0]->p;
 
     return true;
   }
@@ -63,64 +67,155 @@ namespace client
   {
     nirvana.requestSuspend = true;
 
-    camera.player->h -= input.mouse.x * mouseXSens;
-    camera.player->v -= input.mouse.y * mouseYSens;
-
-    if( input.keys[SDLK_UP] ) {
-      camera.player->v += keyXSens * time;
-    }
-    if( input.keys[SDLK_DOWN] ) {
-      camera.player->v -= keyXSens * time;
-    }
-    if( input.keys[SDLK_RIGHT] ) {
-      camera.player->h -= keyYSens * time;
-    }
-    if( input.keys[SDLK_LEFT] ) {
-      camera.player->h += keyYSens * time;
-    }
-
-    if( input.keys[SDLK_w] ) {
-      camera.player->keys |= Bot::KEY_FORWARD;
-    }
-    if( input.keys[SDLK_s] ) {
-      camera.player->keys |= Bot::KEY_BACKWARD;
-    }
-    if( input.keys[SDLK_d] ) {
-      camera.player->keys |= Bot::KEY_RIGHT;
-    }
-    if( input.keys[SDLK_a] ) {
-      camera.player->keys |= Bot::KEY_LEFT;
-    }
-
-    if( input.keys[SDLK_SPACE] ) {
-      camera.player->keys |= Bot::KEY_JUMP;
-    }
-    if( input.keys[SDLK_LCTRL] ) {
-      camera.player->keys |= Bot::KEY_CROUCH;
-    }
-    if( input.keys[SDLK_LALT] ) {
-      camera.player->keys |= Bot::KEY_RUN;
+    camera.preUpdate();
+
+    if( camera.bot == null ) {
+      /*
+       * Camera
+       */
+      camera.h -= input.mouse.x * mouseXSens;
+      camera.v -= input.mouse.y * mouseYSens;
+
+      if( input.keys[SDLK_UP] ) {
+        camera.v += keyXSens * time;
+      }
+      if( input.keys[SDLK_DOWN] ) {
+        camera.v -= keyXSens * time;
+      }
+      if( input.keys[SDLK_RIGHT] ) {
+        camera.h -= keyYSens * time;
+      }
+      if( input.keys[SDLK_LEFT] ) {
+        camera.h += keyYSens * time;
+      }
+
+      camera.postUpdate();
+
+      /*
+       * Movement
+       */
+      float speed = input.keys[SDLK_LSHIFT] ? FREECAM_FAST_SPEED : FREECAM_SLOW_SPEED;
+
+      if( input.keys[SDLK_w] ) {
+        camera.p += camera.at * speed;
+      }
+      if( input.keys[SDLK_s] ) {
+        camera.p -= camera.at * speed;
+      }
+      if( input.keys[SDLK_d] ) {
+        camera.p += camera.right * speed;
+      }
+      if( input.keys[SDLK_a] ) {
+        camera.p -= camera.right * speed;
+      }
+      if( input.keys[SDLK_SPACE] ) {
+        camera.p.z += speed;
+      }
+      if( input.keys[SDLK_LCTRL] ) {
+        camera.p.z -= speed;
+      }
     }
-
-    if( input.keys[SDLK_l] ) {
-      camera.player->keys |= Bot::KEY_NOCLIP;
+    else {
+      /*
+       * Camera
+       */
+      if( camera.bot->state & Bot::FREELOOK_BIT ) {
+        camera.h -= input.mouse.x * mouseXSens;
+        camera.v -= input.mouse.y * mouseYSens;
+
+        BotClass *clazz = (BotClass*) camera.bot->type;
+        camera.h = bound( camera.h, clazz->lookLimitHMin, clazz->lookLimitHMax );
+        camera.v = bound( camera.v, clazz->lookLimitVMin, clazz->lookLimitVMax );
+
+        if( input.keys[SDLK_UP] ) {
+          camera.v += keyXSens * time;
+        }
+        if( input.keys[SDLK_DOWN] ) {
+          camera.v -= keyXSens * time;
+        }
+        if( input.keys[SDLK_RIGHT] ) {
+          camera.h -= keyYSens * time;
+        }
+        if( input.keys[SDLK_LEFT] ) {
+          camera.h += keyYSens * time;
+        }
+      }
+      else {
+        camera.h = 0.0f;
+        camera.v = 0.0f;
+
+        camera.bot->h -= input.mouse.x * mouseXSens;
+        camera.bot->v -= input.mouse.y * mouseYSens;
+
+        if( input.keys[SDLK_UP] ) {
+          camera.bot->v += keyXSens * time;
+        }
+        if( input.keys[SDLK_DOWN] ) {
+          camera.bot->v -= keyXSens * time;
+        }
+        if( input.keys[SDLK_RIGHT] ) {
+          camera.bot->h -= keyYSens * time;
+        }
+        if( input.keys[SDLK_LEFT] ) {
+          camera.bot->h += keyYSens * time;
+        }
+      }
+
+      /*
+       * Movement
+       */
+      if( input.keys[SDLK_w] ) {
+        camera.bot->keys |= Bot::KEY_FORWARD;
+      }
+      if( input.keys[SDLK_s] ) {
+        camera.bot->keys |= Bot::KEY_BACKWARD;
+      }
+      if( input.keys[SDLK_d] ) {
+        camera.bot->keys |= Bot::KEY_RIGHT;
+      }
+      if( input.keys[SDLK_a] ) {
+        camera.bot->keys |= Bot::KEY_LEFT;
+      }
+
+      /*
+       * Actions
+       */
+      if( input.keys[SDLK_SPACE] ) {
+        camera.bot->keys |= Bot::KEY_JUMP;
+      }
+      if( input.keys[SDLK_LCTRL] ) {
+        camera.bot->keys |= Bot::KEY_CROUCH;
+      }
+      if( input.keys[SDLK_LSHIFT] ) {
+        camera.bot->keys |= Bot::KEY_RUN;
+      }
+      if( input.keys[SDLK_LALT] ) {
+        camera.bot->keys |= Bot::KEY_FREELOOK;
+      }
+
+      if( input.keys[SDLK_g] ) {
+        camera.bot->keys |= Bot::KEY_GESTURE0;
+      }
+      if( input.keys[SDLK_h] ) {
+        camera.bot->keys |= Bot::KEY_GESTURE1;
+      }
+      if( input.keys[SDLK_p] ) {
+        camera.bot->keys |= Bot::KEY_STEP;
+      }
+      if( input.keys[SDLK_l] ) {
+        camera.bot->keys |= Bot::KEY_NOCLIP;
+      }
+
+      if( input.mouse.b & SDL_BUTTON_LEFT ) {
+        camera.bot->keys |= Bot::KEY_FIRE;
+      }
+      if( input.keys[SDLK_f] || ( input.mouse.b == SDL_BUTTON_RIGHT ) ) {
+        camera.bot->keys |= Bot::KEY_USE;
+      }
     }
 
-    if( input.keys[SDLK_g] ) {
-      camera.player->keys |= Bot::KEY_GESTURE0;
-    }
-    if( input.keys[SDLK_h] ) {
-      camera.player->keys |= Bot::KEY_GESTURE1;
-    }
-    if( input.keys[SDLK_LSHIFT] ) {
-      camera.player->keys |= Bot::KEY_STEP;
-    }
-
-    if( ( input.mouse.b == SDL_BUTTON_LEFT ) ) {
-      camera.player->keys |= Bot::KEY_FIRE;
-    }
-    if( input.keys[SDLK_f] || ( input.mouse.b == SDL_BUTTON_RIGHT ) ) {
-      camera.player->keys |= Bot::KEY_USE;
+    if( input.mouse.b & SDL_BUTTON_LEFT ) {
+      camera.botIndex = ~camera.botIndex;
     }
 
     SDL_SemWait( matrix.semaphore );
@@ -129,9 +224,9 @@ namespace client
     network.update();
     matrix.update();
 
-    SDL_SemPost( nirvana.semaphore );
+    camera.postUpdate();
 
-    camera.update();
+    SDL_SemPost( nirvana.semaphore );
 
     return !input.keys[SDLK_ESCAPE];
   }
diff --git a/src/client/Game.h b/src/client/Game.h
index 1ec03ed..7add9c6 100644
--- a/src/client/Game.h
+++ b/src/client/Game.h
@@ -33,6 +33,9 @@ namespace client
 
     private:
 
+      static const float FREECAM_SLOW_SPEED;
+      static const float FREECAM_FAST_SPEED;
+
       float mouseXSens;
       float mouseYSens;
 
diff --git a/src/client/MD2.cpp b/src/client/MD2.cpp
index 5f8ffa2..406a824 100644
--- a/src/client/MD2.cpp
+++ b/src/client/MD2.cpp
@@ -275,7 +275,7 @@ namespace client
     free();
   }
 
-  bool MD2::load( const char *path )
+  bool MD2::load( const char *name )
   {
     FILE      *file;
     MD2Header header;
@@ -284,7 +284,7 @@ namespace client
     Vec3      *pVerts;
     int       *pNormals;
 
-    String sPath = path;
+    String sPath = String( "mdl/" ) + name;
     String modelFile = sPath + "/tris.md2";
     String skinFile = sPath + "/skin.jpg";
     String configFile = sPath + "/config.xml";
diff --git a/src/client/MD2.h b/src/client/MD2.h
index 938f73c..d077fe0 100644
--- a/src/client/MD2.h
+++ b/src/client/MD2.h
@@ -94,7 +94,7 @@ namespace client
       MD2();
       ~MD2();
 
-      bool load( const char *path );
+      bool load( const char *name );
       void free();
 
       void drawFrame( int frame );
diff --git a/src/client/MD2Model.cpp b/src/client/MD2Model.cpp
index f730f61..c2b81cd 100644
--- a/src/client/MD2Model.cpp
+++ b/src/client/MD2Model.cpp
@@ -49,6 +49,8 @@ namespace client
 
   void MD2Model::draw()
   {
+    glRotatef( bot->h, 0.0f, 0.0f, 1.0f );
+
     setAnim( bot->anim );
     md2->draw( &anim );
   }
diff --git a/src/client/Main.cpp b/src/client/Main.cpp
index 7518404..93de751 100644
--- a/src/client/Main.cpp
+++ b/src/client/Main.cpp
@@ -18,6 +18,7 @@
 # include <direct.h>
 # include <sys/types.h>
 # include <sys/stat.h>
+# define chdir _chdir
 #else
 # include <unistd.h>
 # include <sys/stat.h>
@@ -93,10 +94,10 @@ namespace client
     String home = String( homeVar == null ? OZ_RC_DIR : homeVar + String( "\\" OZ_RC_DIR ) );
 
     struct _stat homeDirStat;
-    if( _stat( home.cstr(), &homeDirStat ) ) {
+    if( _stat( home.cstr(), &homeDirStat ) != 0 ) {
       printf( "No resource dir found, creating '%s' ...", home.cstr() );
 
-      if( _mkdir( home.cstr() ) ) {
+      if( _mkdir( home.cstr() ) != 0 ) {
         printf( " Failed\n" );
         return;
       }
@@ -108,10 +109,10 @@ namespace client
     String home = String( homeVar == null ? OZ_RC_DIR "/" : homeVar + String( "/" OZ_RC_DIR "/" ) );
 
     struct stat homeDirStat;
-    if( stat( home.cstr(), &homeDirStat ) ) {
+    if( stat( home.cstr(), &homeDirStat ) != 0 ) {
       printf( "No resource dir found, creating '%s' ...", home.cstr() );
 
-      if( mkdir( home.cstr(), S_IRUSR | S_IWUSR | S_IXUSR ) ) {
+      if( mkdir( home.cstr(), S_IRUSR | S_IWUSR | S_IXUSR ) != 0 ) {
         printf( " Failed\n" );
         return;
       }
@@ -135,6 +136,11 @@ namespace client
 
     logFile.printlnETD( OZ_APP_NAME " started at" );
 
+    String configPath = home + OZ_CONFIG_FILE;
+    if( config.load( configPath ) ) {
+      logFile.printEnd( "Configuration read from '%s'", configPath.cstr() );
+    }
+
     logFile.print( "Initializing SDL ..." );
 
     // Don't mess with screensaver. In X11 it only makes effect for windowed mode, in fullscreen
@@ -157,30 +163,18 @@ namespace client
 
     initFlags |= INIT_SDL;
 
-    String configPath = home + OZ_CONFIG_FILE;
-    config.load( configPath );
-
     const char *data = config.get( "data", "/usr/share/openzone" );
 
-    logFile.print( "Going to working directory '%s' ...", data );
+    logFile.print( "Setting working directory '%s' ...", data );
 
-#ifdef WIN32
-    if( _chdir( data ) != 0 ) {
-      logFile.printEnd( " Failed" );
-      return;
-    }
-    else {
-      logFile.printEnd( " OK" );
-    }
-#else
     if( chdir( data ) != 0 ) {
       logFile.printEnd( " Failed" );
       return;
     }
     else {
+      io.initBlockSize( data );
       logFile.printEnd( " OK" );
     }
-#endif
 
     int screenX    = config.get( "screen.width", 1024 );
     int screenY    = config.get( "screen.height", 768 );
@@ -393,12 +387,10 @@ int main( int argc, char *argv[] )
   catch( const oz::Exception &e ) {
     oz::logFile.resetIndent();
     oz::logFile.println();
-    oz::logFile.println( "*** EXCEPTION: %s line %d", e.file, e.line );
-    oz::logFile.println( "*** MESSAGE: %s", e.message );
-    oz::logFile.println();
+    oz::logFile.println( "EXCEPTION: %s:%d: %s", e.file, e.line, e.message );
 
     if( oz::logFile.isFile() ) {
-      printf( "*** EXCEPTION: %s line %d\n*** MESSAGE: %s\n\n", e.file, e.line, e.message );
+      fprintf( stderr, "EXCEPTION: %s:%d: %s\n", e.file, e.line, e.message );
     }
   }
   oz::client::main.shutdown();
diff --git a/src/client/OBJ.cpp b/src/client/OBJ.cpp
index 990a232..4f5bcf7 100644
--- a/src/client/OBJ.cpp
+++ b/src/client/OBJ.cpp
@@ -248,7 +248,7 @@ namespace client
     free();
   }
 
-  bool OBJ::load( const char *path )
+  bool OBJ::load( const char *name )
   {
     FILE *file;
     char buffer[LINE_BUFFER_SIZE];
@@ -256,7 +256,7 @@ namespace client
     // default texture if none loaded
     textureId = 0;
 
-    String sPath = path;
+    String sPath = String( "mdl/" ) + name;
     String modelFile = sPath + "/data.obj";
     String configFile = sPath + "/config.xml";
 
@@ -449,11 +449,10 @@ namespace client
     }
   }
 
-  uint OBJ::genList( const char *file )
+  uint OBJ::genList( const char *name )
   {
     OBJ obj;
-
-    obj.load( file );
+    obj.load( name );
 
     uint list = context.genList();
 
diff --git a/src/client/OBJ.h b/src/client/OBJ.h
index 56dbef8..34badab 100644
--- a/src/client/OBJ.h
+++ b/src/client/OBJ.h
@@ -66,11 +66,11 @@ namespace client
       OBJ();
       ~OBJ();
 
-      bool load( const char *path );
+      bool load( const char *name );
       void free();
 
       void draw() const;
-      static uint genList( const char *file );
+      static uint genList( const char *name );
 
       void scale( float scale );
       void translate( const Vec3 &t );
diff --git a/src/client/Render.cpp b/src/client/Render.cpp
index 705514b..4e27185 100644
--- a/src/client/Render.cpp
+++ b/src/client/Render.cpp
@@ -43,9 +43,18 @@ namespace client
 
   void Render::init()
   {
+    String sExtensions = (const char*) glGetString( GL_EXTENSIONS );
+    Vector<String> extensions = sExtensions.trim().split( ' ' );
+
     logFile.println( "OpenGL vendor: %s", glGetString( GL_VENDOR ) );
     logFile.println( "OpenGL version: %s", glGetString( GL_VERSION ) );
-    logFile.println( "OpenGL extensions: %s", glGetString( GL_EXTENSIONS ) );
+    logFile.println( "OpenGL extensions {" );
+    logFile.indent();
+    foreach( extension, extensions.iterator() ) {
+      logFile.println( "%s", extension->cstr() );
+    }
+    logFile.unindent();
+    logFile.println( "}" );
 
     font.init( "base/font.png", 2.0f );
 
@@ -75,6 +84,8 @@ namespace client
     font.print( -10, 0, "LOADING ..." );
 
     SDL_GL_SwapBuffers();
+
+    assert( glGetError() == GL_NO_ERROR );
   }
 
   void Render::load()
@@ -82,20 +93,27 @@ namespace client
     glDepthFunc( GL_LEQUAL );
     glEnable( GL_CULL_FACE );
 
+    assert( glGetError() == GL_NO_ERROR );
+
     // fog
     glFogi( GL_FOG_MODE, GL_LINEAR );
     glFogf( GL_FOG_START, 0.0f );
     glFogf( GL_FOG_END, perspectiveMax );
 
+    assert( glGetError() == GL_NO_ERROR );
+
     // lighting
     glLightModeli(  GL_LIGHT_MODEL_TWO_SIDE, false );
     glLightModelfv( GL_LIGHT_MODEL_AMBIENT, GLOBAL_AMBIENT );
 
+    assert( glGetError() == GL_NO_ERROR );
+
     glEnable( GL_COLOR_MATERIAL );
     glColor4fv( WHITE );
-
     glEnable( GL_LIGHT0 );
 
+    assert( glGetError() == GL_NO_ERROR );
+
     particleRadius = config.get( "render.particleRadius", 0.5f );
     drawAABBs      = config.get( "render.drawAABBs",      false );
     showAim        = config.get( "render.showAim",        false );
@@ -104,10 +122,11 @@ namespace client
     camera.init();
     frustum.init( perspectiveAngle, perspectiveAspect, perspectiveMax );
     sky.init();
-
     terra.init();
 
-    for( int i = 0; i < world.bsps.length(); i++ ) {
+    assert( glGetError() == GL_NO_ERROR );
+
+    for( int i = 0; i < translator.bsps.length(); i++ ) {
       bsps << new BSP( world.bsps[i] );
     }
 
@@ -120,6 +139,8 @@ namespace client
     glEnable( GL_FOG );
 
     glEnable( GL_LIGHTING );
+
+    assert( glGetError() == GL_NO_ERROR );
   }
 
   void Render::drawObject( Object *obj )
@@ -127,7 +148,6 @@ namespace client
     glPushMatrix();
 
     glTranslatef( obj->p.x, obj->p.y, obj->p.z );
-    glRotatef( obj->rotZ, 0.0f, 0.0f, 1.0f );
 
     /*if( obj->flags & Object::WATER_BIT ) {
       waterObjects << obj;
@@ -144,8 +164,6 @@ namespace client
       models.cachedValue()->state = Model::UPDATED;
     }
     if( drawAABBs ) {
-      glRotatef( -obj->rotZ, 0.0f, 0.0f, 1.0f );
-
       glDisable( GL_LIGHTING );
       glDisable( GL_TEXTURE_2D );
       glEnable( GL_BLEND );
@@ -175,7 +193,7 @@ namespace client
     }
 
     foreach( obj, sector.objects.iterator() ) {
-      if( &*obj == camera.player ) {
+      if( &*obj == camera.bot ) {
         continue;
       }
       bool isVisible =
@@ -207,13 +225,19 @@ namespace client
 
   void Render::draw()
   {
+    assert( glGetError() == GL_NO_ERROR );
+
     // frustum
     frustum.update();
     frustum.getExtrems( camera.p );
 
+    assert( glGetError() == GL_NO_ERROR );
+
     sky.update();
     water.update();
 
+    assert( glGetError() == GL_NO_ERROR );
+
     bool wasUnderWater = isUnderWater;
     isUnderWater = false;
 
@@ -257,16 +281,23 @@ namespace client
     // clear buffer
     glClear( GL_DEPTH_BUFFER_BIT | GL_COLOR_BUFFER_BIT );
 
+    assert( glGetError() == GL_NO_ERROR );
+
     // camera transformation
     glMultMatrixf( camera.rotTMat );
     glTranslatef( -camera.p.x, -camera.p.y, -camera.p.z );
 
+    assert( glGetError() == GL_NO_ERROR );
+
     // lighting
     glLightfv( GL_LIGHT0, GL_POSITION, sky.lightDir );
     glLightfv( GL_LIGHT0, GL_DIFFUSE, sky.diffuseColor );
     glLightfv( GL_LIGHT0, GL_AMBIENT, sky.ambientColor );
 
+    assert( glGetError() == GL_NO_ERROR );
+
     terra.draw();
+    assert( glGetError() == GL_NO_ERROR );
 
     // draw structures
     BSP::beginRender();
@@ -276,6 +307,7 @@ namespace client
       Structure *str = structures[i];
 
       isInWaterBrush |= bsps[str->bsp]->draw( str );
+      assert( glGetError() == GL_NO_ERROR );
     }
     structures.clear();
 
@@ -284,6 +316,7 @@ namespace client
     // draw objects
     for( int i = 0; i < objects.length(); i++ ) {
       drawObject( objects[i] );
+      assert( glGetError() == GL_NO_ERROR );
     }
     objects.clear();
 
@@ -323,12 +356,14 @@ namespace client
 //     }
 //     waterObjects.clear();
 
+    assert( glGetError() == GL_NO_ERROR );
+
     glColor4fv( WHITE );
     glDisable( GL_BLEND );
 
     if( showAim ) {
-      Vec3 move = camera.at * 20.0f;
-      collider.translate( camera.p, move, camera.player );
+      Vec3 move = camera.at * 32.0f;
+      collider.translate( camera.p, move, camera.bot );
       move *= collider.hit.ratio;
 
       glDisable( GL_TEXTURE_2D );
@@ -339,6 +374,8 @@ namespace client
       glEnable( GL_TEXTURE_2D );
     }
 
+    assert( glGetError() == GL_NO_ERROR );
+
     glLoadIdentity();
     glRotatef( -90.0f, 1.0f, 0.0f, 0.0f );
 
@@ -349,27 +386,34 @@ namespace client
     glEnable( GL_BLEND );
     glBlendFunc( GL_ONE, GL_ONE );
 
-    font.print( -45, 37, "cam( %.2f %.2f %.2f ) ( %.2f %.2f )",
-                camera.p.x, camera.p.y, camera.p.z,
-                camera.player->h, camera.player->v );
-    font.print( -45, 35, "camera.player.vel ( %.2f %.2f %.2f )",
-                camera.player->velocity.x, camera.player->velocity.y, camera.player->velocity.z );
-
-    font.print( -45, 33, "d %d fl %d lw %d h %d fr %d iw %d uw %d ld %d s %d ovlp %d wb %d",
-                ( camera.player->flags & Object::DISABLED_BIT ) != 0,
-                ( camera.player->flags & Object::ON_FLOOR_BIT ) != 0,
-                camera.player->lower >= 0,
-                ( camera.player->flags & Object::HIT_BIT ) != 0,
-                ( camera.player->flags & Object::FRICTING_BIT ) != 0,
-                ( camera.player->flags & Object::IN_WATER_BIT ) != 0,
-                ( camera.player->flags & Object::UNDER_WATER_BIT ) != 0,
-                ( camera.player->flags & Object::ON_LADDER_BIT ) != 0,
-                ( camera.player->flags & Object::ON_SLICK_BIT ) != 0,
-                collider.test( *camera.player ),
-                isInWaterBrush );
+    assert( glGetError() == GL_NO_ERROR );
+
+    if( camera.bot != null ) {
+      font.print( -45, 37, "cam.p( %.2f %.2f %.2f ) bot( %.2f %.2f ) rel( %.2f %.2f )",
+                  camera.p.x, camera.p.y, camera.p.z,
+                  camera.bot->h, camera.bot->v, camera.h, camera.v );
+      font.print( -45, 35, "camera.vel ( %.2f %.2f %.2f ) camera.mom ( %.2f %.2f %.2f )",
+                  camera.bot->velocity.x, camera.bot->velocity.y, camera.bot->velocity.z,
+                  camera.bot->momentum.x, camera.bot->momentum.y, camera.bot->momentum.z);
+
+      font.print( -45, 33, "d %d fl %d lw %d h %d fr %d iw %d uw %d ld %d s %d ovlp %d wb %d",
+                  ( camera.bot->flags & Object::DISABLED_BIT ) != 0,
+                  ( camera.bot->flags & Object::ON_FLOOR_BIT ) != 0,
+                  camera.bot->lower >= 0,
+                  ( camera.bot->flags & Object::HIT_BIT ) != 0,
+                  ( camera.bot->flags & Object::FRICTING_BIT ) != 0,
+                  ( camera.bot->flags & Object::IN_WATER_BIT ) != 0,
+                  ( camera.bot->flags & Object::UNDER_WATER_BIT ) != 0,
+                  ( camera.bot->flags & Object::ON_LADDER_BIT ) != 0,
+                  ( camera.bot->flags & Object::ON_SLICK_BIT ) != 0,
+                  collider.test( *camera.bot ),
+                  isInWaterBrush );
+    }
 
     SDL_GL_SwapBuffers();
 
+    assert( glGetError() == GL_NO_ERROR );
+
     // get ready for next frame
     glEnable( GL_DEPTH_TEST );
 
@@ -380,6 +424,8 @@ namespace client
 
     glEnable( GL_LIGHTING );
 
+    assert( glGetError() == GL_NO_ERROR );
+
     // remove droped models
     foreach( model, models.iterator() ) {
       if( ( *model )->state == Model::NOT_UPDATED ) {
diff --git a/src/client/Shape.cpp b/src/client/Shape.cpp
index b15b001..058c4ea 100644
--- a/src/client/Shape.cpp
+++ b/src/client/Shape.cpp
@@ -279,8 +279,6 @@ namespace client
       glTexCoord2f( 0, 1 );
       glVertex3f( v0.x, v0.y, v0.z );
     glEnd();
-
-    glEndList();
   }
 
   void Shape::init()
diff --git a/src/client/SimpleAudio.cpp b/src/client/SimpleAudio.cpp
index 2f9f17f..90b4ed6 100644
--- a/src/client/SimpleAudio.cpp
+++ b/src/client/SimpleAudio.cpp
@@ -23,19 +23,25 @@ namespace client
     SimpleAudio *audio = new SimpleAudio();
 
     audio->object = object;
+    audio->requestSounds();
 
     return audio;
   }
 
   void SimpleAudio::update()
   {
+    int ( &samples )[ObjectClass::AUDIO_SAMPLES] = object->type->audioSamples;
+
+    if( ( object->flags & Object::HIT_BIT ) && samples[SND_HIT] >= 0 ) {
+      playSoundEvent( samples[SND_HIT] );
+    }
     // non-continous
     foreach( event, Audio::object->events.iterator() ) {
-      playSoundEvent( event );
+      playSoundEvent( samples[event->id] );
     }
     // continous
     foreach( effect, object->effects.iterator() ) {
-      playSoundEffect( effect );
+      playSoundEffect( samples[effect->id], (uint) &*effect );
     }
   }
 
diff --git a/src/client/SoundManager.cpp b/src/client/SoundManager.cpp
index de9c847..bac47cb 100644
--- a/src/client/SoundManager.cpp
+++ b/src/client/SoundManager.cpp
@@ -25,10 +25,19 @@ namespace client
 
   void SoundManager::init()
   {
+    String sExtensions = (const char*) alGetString( AL_EXTENSIONS );
+    Vector<String> extensions = sExtensions.trim().split( ' ' );
+
     logFile.println( "OpenAL vendor: %s", alGetString( AL_VENDOR ) );
     logFile.println( "OpenAL version: %s", alGetString( AL_VERSION ) );
     logFile.println( "OpenAL renderer: %s", alGetString( AL_RENDERER ) );
-    logFile.println( "OpenAL extensions: %s", alGetString( AL_EXTENSIONS ) );
+    logFile.println( "OpenAL extensions {" );
+    logFile.indent();
+    foreach( extension, extensions.iterator() ) {
+      logFile.println( "%s", extension->cstr() );
+    }
+    logFile.unindent();
+    logFile.println( "}" );
 
     logFile.println( "ALUT version: %d.%d", alutGetMajorVersion(), alutGetMinorVersion() );
     logFile.println( "ALUT suppored formats: %s", alutGetMIMETypes( ALUT_LOADER_BUFFER ) );
@@ -45,7 +54,6 @@ namespace client
 
   void SoundManager::free()
   {
-    // FIXME: pool deallocation issues, crashes because of assertions on exit
     foreach( src, sources.iterator() ) {
       alSourceStop( src->source );
       alDeleteSources( 1, &src->source );
@@ -59,10 +67,7 @@ namespace client
       alDeleteSources( 1, &src.source );
     }
     contSources.clear();
-    contSources.deallocate();
-
-    audios.clear();
-    audios.deallocate();
+    audios.free();
 
     freeMusic();
   }
@@ -72,7 +77,6 @@ namespace client
     Sector &sector = world.sectors[sectorX][sectorY];
 
     foreach( obj, sector.objects.iterator() ) {
-      // TODO sound player
       if( ( camera.p - obj->p ).sqL() < DMAX_SQ ) {
         if( !audios.contains( (uint) &*obj ) ) {
           audios.add( (uint) &*obj, context.createAudio( &*obj ) );
@@ -139,26 +143,43 @@ namespace client
     updateMusic();
   }
 
-  bool SoundManager::loadMusic( const char *file )
+  bool SoundManager::loadMusic( const char *path )
   {
-    logFile.print( "Loading music '%s' ...", file );
+    logFile.print( "Loading music '%s' ...", path );
 
-    FILE *oggFile = fopen( file, "rb" );
+    FILE *oggFile = fopen( path, "rb" );
 
     if( oggFile == null ) {
-      logFile.printEnd( " Failed" );
+      logFile.printEnd( " Failed to open file" );
       return false;
     }
     if( ov_open( oggFile, &oggStream, null, 0 ) < 0 ) {
       fclose( oggFile );
-      logFile.printEnd( " Failed" );
+      logFile.printEnd( " Failed to open Ogg stream" );
       return false;
     }
 
     isMusicLoaded = true;
 
     vorbisInfo = ov_info( &oggStream, -1 );
-    musicFormat = vorbisInfo->channels == 1 ? AL_FORMAT_MONO16 : AL_FORMAT_STEREO16;
+    if( vorbisInfo == null ) {
+      ov_clear( &oggStream );
+      logFile.printEnd( " Failed to read Vorbis header" );
+      return false;
+    }
+
+    if( vorbisInfo->channels == 1 ) {
+      musicFormat = AL_FORMAT_MONO16;
+    }
+    else if( vorbisInfo->channels == 2 ) {
+      musicFormat = AL_FORMAT_STEREO16;
+    }
+    else {
+      ov_clear( &oggStream );
+      logFile.printEnd( " Invalid number of channels, should be 1 or 2" );
+      return AL_NONE;
+    }
+
     isMusicPlaying = true;
 
     alGenBuffers( 2, musicBuffers );
@@ -188,20 +209,21 @@ namespace client
   {
     char data[MUSIC_BUFFER_SIZE];
     int  section;
-    int  size = 0;
+    int  bytesRead = 0;
     int  result;
 
     do {
-      result = ov_read( &oggStream, &data[size], MUSIC_BUFFER_SIZE - size, 0, 2, 1, &section );
-      size += result;
+      result = ov_read( &oggStream, &data[bytesRead], MUSIC_BUFFER_SIZE - bytesRead, 0, 2, 1,
+                        &section );
+      bytesRead += result;
       if( result < 0 ) {
         isMusicPlaying = false;
         return;
       }
     }
-    while( result > 0 && size < MUSIC_BUFFER_SIZE );
+    while( result > 0 && bytesRead < MUSIC_BUFFER_SIZE );
 
-    alBufferData( buffer, musicFormat, data, size, vorbisInfo->rate );
+    alBufferData( buffer, musicFormat, data, bytesRead, vorbisInfo->rate );
   }
 
   void SoundManager::updateMusic()
diff --git a/src/client/SoundManager.h b/src/client/SoundManager.h
index 73be78b..d7cf3bd 100644
--- a/src/client/SoundManager.h
+++ b/src/client/SoundManager.h
@@ -95,7 +95,7 @@ namespace client
       void init();
       void free();
 
-      bool loadMusic( const char *file );
+      bool loadMusic( const char *path );
       void update();
 
       void setVolume( float volume );
@@ -106,14 +106,14 @@ namespace client
         sources << new Source( sourceId );
       }
 
-      void addContSource( const Object::Effect *effect, ALuint sourceId  )
+      void addContSource( uint key, ALuint sourceId  )
       {
-        contSources.add( (uint) effect, sourceId );
+        contSources.add( key, sourceId );
       }
 
-      bool updateContSource( const Object::Effect *effect )
+      bool updateContSource( uint key )
       {
-        if( contSources.contains( (uint) effect ) ) {
+        if( contSources.contains( key ) ) {
           contSources.cachedValue().state = ContSource::UPDATED;
           return true;
         }
diff --git a/src/matrix/BSP.cpp b/src/matrix/BSP.cpp
index bf23a26..01ad857 100644
--- a/src/matrix/BSP.cpp
+++ b/src/matrix/BSP.cpp
@@ -12,8 +12,8 @@
 
 #include "Translator.h"
 
-#define fourC( a, b, c, d ) \
-  ( ( a ) | ( ( b ) << 8 ) | ( ( c ) <<16 ) | ( ( d ) << 24 ) )
+#define fourCC( a, b, c, d ) \
+  ( ( a ) | ( ( b ) << 8 ) | ( ( c ) << 16 ) | ( ( d ) << 24 ) )
 
 namespace oz
 {
@@ -138,9 +138,6 @@ namespace oz
     int  size[2];
   };
 
-  const float BSP::BSP_SCALE = 0.01f;
-  const float BSP::QBSP_SCALE = 0.025f;
-
   BSP::BSP() : textures( null ), planes( null ), nodes( null ), leafs( null ), leafFaces( null ),
     brushes( null ), brushSides( null ), vertices( null ), indices( null ), faces( null ),
     lightmaps( null )
@@ -151,24 +148,22 @@ namespace oz
     free();
   }
 
-  void BSP::loadQBSP( const char *fileName, float maxDim_, float scale )
+  bool BSP::loadQBSP( const char *path, float scale, float maxDim_ )
   {
     maxDim = maxDim_;
 
-    logFile.print( "Loading Quake 3 BSP structure '%s' ...", fileName );
-
-    FILE *f = fopen( fileName, "rb" );
+    FILE *f = fopen( path, "rb" );
     if( f == null ) {
       logFile.printEnd( " Not found" );
-      return;
+      return false;
     }
 
     Header header;
     fread( &header, sizeof( Header ), 1, f );
 
-    if( header.id != fourC( 'I', 'B', 'S', 'P' ) || header.version != 46 ) {
+    if( header.id != fourCC( 'I', 'B', 'S', 'P' ) || header.version != 46 ) {
       logFile.printEnd( " Wrong format" );
-      return;
+      return false;
     }
 
     Lump lumps[QBSP_LUMPS_NUM];
@@ -188,12 +183,14 @@ namespace oz
       texFlags[i] = texture.flags;
       texTypes[i] = texture.type;
 
-      if( name.length() <= 9 || name == "textures/NULL" ) {
+      // String::length( "textures/oz/" ) == 12
+      if( name.length() <= 12 || name == "textures/NULL" ) {
         textures[i] = -1;
       }
       else {
-        textures[i] = translator.textureIndex( name + ".jpg" );
-        logFile.println( "%s 0x%x 0x%x", name.cstr(), texture.flags, texture.type );
+        name = name.substring( 12 );
+        textures[i] = translator.textureIndex( name );
+//         logFile.println( "%s 0x%x 0x%x", name.cstr(), texture.flags, texture.type );
       }
     }
 
@@ -382,10 +379,35 @@ namespace oz
     }
 
     fclose( f );
-
     delete[] texFlags;
 
     logFile.printEnd( " OK" );
+    return true;
+  }
+
+  bool BSP::load( const char *name )
+  {
+    Config bspConfig;
+    if( !bspConfig.load( String( "bsp/" ) + name + String( ".xml" ) ) ) {
+      return false;
+    }
+
+    logFile.print( "Loading Quake 3 BSP structure '%s' ...", name );
+
+    float scale  = bspConfig.get( "scale", 0.01f );
+    float maxDim = bspConfig.get( "maxDim", Math::INF );
+    bspConfig.clear();
+
+    if( scale == Math::NaN || maxDim == Math::NaN ) {
+      logFile.printEnd( " Invalid config" );
+      return false;
+    }
+
+    if( !loadQBSP( String( "bsp/" ) + name + String( ".bsp" ), scale, maxDim ) ) {
+      free();
+      return false;
+    }
+    return true;
   }
 
   void BSP::free()
diff --git a/src/matrix/BSP.h b/src/matrix/BSP.h
index 2657ec5..38616cf 100644
--- a/src/matrix/BSP.h
+++ b/src/matrix/BSP.h
@@ -20,11 +20,6 @@ namespace oz
     static const int LIGHTMAP_BPP = 3;
     static const int LIGHTMAP_SIZE = LIGHTMAP_DIM * LIGHTMAP_DIM * LIGHTMAP_BPP;
 
-    // 1 unit in BSP map = 1 cm (for BSPs made for this engine)
-    static const float BSP_SCALE;
-    // 1 unit in BSP map = 1 inch (for BSPs made for quake)
-    static const float QBSP_SCALE;
-
     static const int SOLID_BIT  = 0x01;
     static const int SLICK_BIT  = 0x02;
     static const int WATER_BIT  = 0x04;
@@ -134,7 +129,8 @@ namespace oz
     explicit BSP();
     ~BSP();
 
-    void loadQBSP( const char *fileName, float maxDim = Math::INF, float scale = QBSP_SCALE );
+    bool loadQBSP( const char *fileName, float scale, float maxDim );
+    bool load( const char *name );
     void free();
   };
 
diff --git a/src/matrix/Bot.cpp b/src/matrix/Bot.cpp
index 1588790..cbdaf3b 100644
--- a/src/matrix/Bot.cpp
+++ b/src/matrix/Bot.cpp
@@ -16,9 +16,6 @@
 namespace oz
 {
 
-  Bot::Bot() : anim( ANIM_STAND ), keys( 0 ), oldKeys( 0 ), h( 0.0f ), v( 0.0f ), bob( 0.0f )
-  {}
-
   void Bot::onUpdate()
   {
     BotClass &clazz = *(BotClass*) type;
@@ -26,8 +23,6 @@ namespace oz
     h = Math::mod( h + 360.0f, 360.0f );
     v = bound( v, -90.0f, 90.0f );
 
-    rotZ = h;
-
     // { hsine, hcosine, vsine, vcosine, vcosine * hsine, vcosine * hcosine }
     float hvsc[6];
 
@@ -41,6 +36,10 @@ namespace oz
     bool isClimbing = flags & ON_LADDER_BIT;
     bool isGrounded = ( lower >= 0 || ( flags & ON_FLOOR_BIT ) ) && !isSwimming;
 
+    if( ( keys & KEY_FREELOOK ) && !( oldKeys & KEY_FREELOOK ) ) {
+      state ^= FREELOOK_BIT;
+    }
+
     if( ( keys & KEY_RUN ) && !( oldKeys & KEY_RUN ) ) {
       state ^= RUNNING_BIT;
     }
@@ -89,13 +88,12 @@ namespace oz
       }
       else {
         flags &= ~DISABLED_BIT;
+        flags &= ~Object::ON_FLOOR_BIT;
+        lower =  -1;
 
         p.z    += dim.z - clazz.dimCrouch.z;
         dim.z  = clazz.dimCrouch.z;
         camPos = clazz.camPosCrouch;
-
-        lower =  -1;
-        flags &= ~Object::ON_FLOOR_BIT;
         state |= CROUCHING_BIT;
       }
     }
@@ -169,18 +167,21 @@ namespace oz
       }
     }
 
-    Vec3 desiredVelocity = velocity * move;
+    if( !move.isZero() ) {
+      Vec3 desiredVelocity = velocity * ~move;
 
-    if( ( flags & Object::ON_FLOOR_BIT ) && floor.z != 1.0f ) {
-      float dot = desiredVelocity * floor;
+      if( ( flags & Object::ON_FLOOR_BIT ) && floor.z != 1.0f ) {
+        float dot = desiredVelocity * floor;
 
-      if( dot > 0.0f ) {
-        desiredVelocity -= dot * floor;
+        if( dot > 0.0f ) {
+          desiredVelocity -= dot * floor;
+        }
       }
+      momentum += desiredVelocity;
     }
 
-    momentum += desiredVelocity;
-
+    // TODO: better stepping algoriths (stepping per time unit limit + vertial surface should not
+    // be required. Should try step up-forward-down. Should hit a floor surface then.)
     if( ( state & STEPPING_BIT ) && !isClimbing ) {
       Vec3 desiredMove = momentum * timer.frameTime;
 
@@ -232,7 +233,7 @@ namespace oz
       damage += hitVelocity;
     }
 
-    if( hit->normal.z >= Physics::FLOOR_NORMAL_Z && hitVelocity > 8.0f ) {
+    if( hit->normal.z >= Physics::FLOOR_NORMAL_Z && hitVelocity < 8.0f ) {
       addEvent( SND_LAND );
     }
   }
@@ -240,4 +241,103 @@ namespace oz
   void Bot::onDestroy()
   {}
 
+  Bot::Bot() : anim( ANIM_STAND ), keys( 0 ), oldKeys( 0 ), h( 0.0f ), v( 0.0f ), bob( 0.0f )
+  {}
+
+  void Bot::readUpdates( InputStream *istream )
+  {
+    p         = istream->readVec3();
+    flags     = istream->readInt();
+    oldFlags  = istream->readInt();
+    damage    = istream->readFloat();
+
+    velocity  = istream->readVec3();
+    momentum  = istream->readVec3();
+
+    state     = istream->readInt();
+    anim      = (AnimEnum) istream->readByte();
+    h         = istream->readFloat();
+
+    int nEvents = istream->readByte();
+    for( int i = 0; i < nEvents; i++ ) {
+      addEvent( istream->readInt() );
+    }
+    int nEffects = istream->readByte();
+    for( int i = 0; i < nEffects; i++ ) {
+      addEffect( istream->readInt() );
+    }
+  }
+
+  void Bot::writeUpdates( OutputStream *ostream )
+  {
+    ostream->writeVec3( p );
+    ostream->writeInt( flags );
+    ostream->writeInt( oldFlags );
+    ostream->writeFloat( damage );
+
+    ostream->writeVec3( velocity );
+    ostream->writeVec3( momentum );
+
+    ostream->writeInt( state );
+    ostream->writeByte( anim );
+    ostream->writeFloat( h );
+
+    ostream->writeByte( events.length() );
+    foreach( event, events.iterator() ) {
+      ostream->writeInt( event->id );
+    }
+    ostream->writeByte( effects.length() );
+    foreach( effect, effects.iterator() ) {
+      ostream->writeInt( effect->id );
+    }
+  }
+
+  void Bot::readFull( InputStream *istream )
+  {
+    p         = istream->readVec3();
+    flags     = istream->readInt();
+    oldFlags  = istream->readInt();
+    damage    = istream->readFloat();
+
+    velocity  = istream->readVec3();
+    momentum  = istream->readVec3();
+
+    state     = istream->readInt();
+    anim      = (AnimEnum) istream->readByte();
+    h         = istream->readFloat();
+
+    int nEvents = istream->readByte();
+    for( int i = 0; i < nEvents; i++ ) {
+      addEvent( istream->readInt() );
+    }
+    int nEffects = istream->readByte();
+    for( int i = 0; i < nEffects; i++ ) {
+      addEffect( istream->readInt() );
+    }
+  }
+
+  void Bot::writeFull( OutputStream *ostream )
+  {
+    ostream->writeVec3( p );
+    ostream->writeInt( flags );
+    ostream->writeInt( oldFlags );
+    ostream->writeFloat( damage );
+
+    ostream->writeVec3( velocity );
+    ostream->writeVec3( momentum );
+
+    ostream->writeInt( state );
+    ostream->writeByte( anim );
+    ostream->writeFloat( h );
+
+    ostream->writeByte( events.length() );
+    foreach( event, events.iterator() ) {
+      ostream->writeInt( event->id );
+    }
+    ostream->writeByte( effects.length() );
+    foreach( effect, effects.iterator() ) {
+      ostream->writeInt( effect->id );
+    }
+  }
+
 }
diff --git a/src/matrix/Bot.h b/src/matrix/Bot.h
index b48994b..fc53770 100644
--- a/src/matrix/Bot.h
+++ b/src/matrix/Bot.h
@@ -36,9 +36,11 @@ namespace oz
       static const int KEY_GESTURE1    = 0x00000800;
       static const int KEY_USE         = 0x00001000;
       static const int KEY_STEP        = 0x00002000;
+      static const int KEY_FREELOOK    = 0x00004000;
 
       static const int STEPPING_BIT    = 0x00000001;
       static const int CROUCHING_BIT   = 0x00000002;
+      static const int FREELOOK_BIT    = 0x00000004;
       static const int RUNNING_BIT     = 0x00000010;
       static const int SHOOTING_BIT    = 0x00000020;
       static const int GROUNDED_BIT    = 0x00000040;
@@ -47,10 +49,6 @@ namespace oz
       static const int GESTURE1_BIT    = 0x00000200;
       static const int DEATH_BIT       = 0x00000400;
 
-      // effects
-      static const int SND_LAND        = 8;
-      static const int SND_JUMP        = 9;
-
       enum AnimEnum
       {
         ANIM_STAND,
@@ -84,23 +82,33 @@ namespace oz
 
     public:
 
-      Mind    *mind;
+      Mind     *mind;
 
-      int     state;
-      int     anim;
+      int      state;
+      AnimEnum anim;
 
-      int     keys, oldKeys;
+      int      keys, oldKeys;
 
-      float   h, v;
-      float   bob;
-      Vec3    camPos;
+      float    h, v;
+      float    bob;
+      Vec3     camPos;
 
-      float   deathTime;
-      Weapon  *weapon;
+      float    deathTime;
+      Weapon   *weapon;
 
       Vector<Object*> items;
 
       explicit Bot();
+
+      Quat getRot() const
+      {
+        return Quat::rotZYX( Math::rad( h ), 0.0f, Math::rad( v ) );
+      }
+
+      virtual void readFull( InputStream *istream );
+      virtual void writeFull( OutputStream *ostream );
+      virtual void readUpdates( InputStream *istream );
+      virtual void writeUpdates( OutputStream *ostream );
   };
 
 }
diff --git a/src/matrix/BotClass.cpp b/src/matrix/BotClass.cpp
index e9fb6ff..73831fa 100644
--- a/src/matrix/BotClass.cpp
+++ b/src/matrix/BotClass.cpp
@@ -42,10 +42,11 @@ namespace oz
     for( int i = 0; i < AUDIO_SAMPLES; i++ ) {
       assert( 0 <= i && i < 100 );
 
-      buffer[ sizeof( buffer ) - 2 ] = i / 10;
-      buffer[ sizeof( buffer ) - 1 ] = i % 10;
+      buffer[ sizeof( buffer ) - 3 ] = '0' + ( i / 10 );
+      buffer[ sizeof( buffer ) - 2 ] = '0' + ( i % 10 );
 
-      clazz->audioSamples[i] = translator.soundIndex( config->get( buffer, "" ) );
+      String sampleName = config->get( buffer, "" );
+      clazz->audioSamples[i] = sampleName.length() > 0 ? translator.soundIndex( sampleName ) : -1;
     }
 
     clazz->dimCrouch.x    = config->get( "dimCrouch.x", 0.5f );
@@ -75,6 +76,11 @@ namespace oz
     clazz->grabDistance   = config->get( "grabDistance", 1.0f );
     clazz->state          = config->get( "state", 0 );
 
+    clazz->lookLimitHMin  = config->get( "lookLimit.h.min", -90.0f );
+    clazz->lookLimitHMax  = config->get( "lookLimit.h.max", +90.0f );
+    clazz->lookLimitVMin  = config->get( "lookLimit.v.min", -45.0f );
+    clazz->lookLimitVMax  = config->get( "lookLimit.v.max", +45.0f );
+
     return clazz;
   }
 
@@ -82,20 +88,39 @@ namespace oz
   {
     Bot *obj = new Bot();
 
-    obj->p = pos;
-    obj->dim = dim;
+    obj->p        = pos;
+    obj->dim      = dim;
 
-    obj->flags = flags;
+    obj->flags    = flags;
     obj->oldFlags = flags;
-    obj->type = this;
-    obj->damage = damage;
+    obj->type     = this;
+    obj->damage   = damage;
+
+    obj->mass     = mass;
+    obj->lift     = lift;
+
+    obj->camPos   = camPos;
+    obj->state    = state;
+    obj->mind     = null;
+
+    return obj;
+  }
+
+  Object *BotClass::create( InputStream *istream )
+  {
+    Bot *obj = new Bot();
+
+    obj->dim    = dim;
+    obj->sector = null;
+    obj->type   = this;
+
+    obj->mass   = mass;
+    obj->lift   = lift;
 
-    obj->mass = mass;
-    obj->lift = lift;
+    obj->readFull( istream );
 
-    obj->camPos = camPos;
-    obj->state = state | Bot::STEPPING_BIT;
-    obj->mind = null;
+    obj->bob    = 0.0f;
+    obj->camPos = ( obj->state & Bot::CROUCHING_BIT ) ? camPosCrouch : camPos;
 
     return obj;
   }
diff --git a/src/matrix/BotClass.h b/src/matrix/BotClass.h
index 46400a3..f856cbd 100644
--- a/src/matrix/BotClass.h
+++ b/src/matrix/BotClass.h
@@ -15,7 +15,6 @@
 namespace oz
 {
 
-  // TODO BotClass
   struct BotClass : DynObjectClass
   {
     static const int BASE_FLAGS = Object::DYNAMIC_BIT | Object::UPDATE_FUNC_BIT |
@@ -43,8 +42,14 @@ namespace oz
 
     int   state;
 
+    float lookLimitHMin;
+    float lookLimitHMax;
+    float lookLimitVMin;
+    float lookLimitVMax;
+
     static ObjectClass *init( const String &name, Config *config );
     virtual Object *create( const Vec3 &pos );
+    virtual Object *create( InputStream *istream );
   };
 
 }
diff --git a/src/matrix/DynObject.cpp b/src/matrix/DynObject.cpp
index 76d4e85..dc56438 100644
--- a/src/matrix/DynObject.cpp
+++ b/src/matrix/DynObject.cpp
@@ -13,32 +13,78 @@
 namespace oz
 {
 
-  void DynObject::load( Net::Packet *packet )
+  void DynObject::readFull( InputStream *istream )
   {
-//     Object::load( stream );
-//
-//     fread( &velocity, sizeof( velocity ), 1, stream );
-//     fread( &newVelocity, sizeof( newVelocity ), 1, stream );
-//     fread( &mass, sizeof( mass ), 1, stream );
-//     fread( &lower, sizeof( lower ), 1, stream );
-//     fread( &floor, sizeof( floor ), 1, stream );
-//
-//     lower = SDL_SwapBE32( lower );
+    p        = istream->readVec3();
+    flags    = istream->readInt();
+    oldFlags = istream->readInt();
+    damage   = istream->readFloat();
+
+    velocity = istream->readVec3();
+    momentum = istream->readVec3();
+
+    int nEvents = istream->readInt();
+    for( int i = 0; i < nEvents; i++ ) {
+      addEvent( istream->readInt() );
+    }
+    int nEffects = istream->readInt();
+    for( int i = 0; i < nEffects; i++ ) {
+      addEffect( istream->readInt() );
+    }
+  }
+
+  void DynObject::writeFull( OutputStream *ostream )
+  {
+    ostream->writeVec3( p );
+    ostream->writeInt( flags );
+    ostream->writeInt( oldFlags );
+    ostream->writeFloat( damage );
+
+    ostream->writeVec3( velocity );
+    ostream->writeVec3( momentum );
+
+    ostream->writeInt( events.length() );
+    foreach( event, events.iterator() ) {
+      ostream->writeInt( event->id );
+    }
+    ostream->writeInt( effects.length() );
+    foreach( effect, effects.iterator() ) {
+      ostream->writeInt( effect->id );
+    }
+  }
+
+  void DynObject::readUpdate( InputStream *istream )
+  {
+    p        = istream->readVec3();
+    damage   = istream->readFloat();
+    velocity = istream->readVec3();
+    momentum = istream->readVec3();
+
+    int nEvents = istream->readInt();
+    for( int i = 0; i < nEvents; i++ ) {
+      addEvent( istream->readInt() );
+    }
+    int nEffects = istream->readInt();
+    for( int i = 0; i < nEffects; i++ ) {
+      addEffect( istream->readInt() );
+    }
   }
 
-  void DynObject::save( Net::Packet *packet)
+  void DynObject::writeUpdate( OutputStream *ostream )
   {
-//     Object::load( stream );
-//
-//     lower = SDL_SwapBE32( lower );
-//
-//     fwrite( &velocity, sizeof( velocity ), 1, stream );
-//     fwrite( &newVelocity, sizeof( newVelocity ), 1, stream );
-//     fwrite( &mass, sizeof( mass ), 1, stream );
-//     fwrite( &lower, sizeof( lower ), 1, stream );
-//     fwrite( &floor, sizeof( floor ), 1, stream );
-//
-//     lower = SDL_SwapBE32( lower );
+    ostream->writeVec3( p );
+    ostream->writeFloat( damage );
+    ostream->writeVec3( velocity );
+    ostream->writeVec3( momentum );
+
+    ostream->writeInt( events.length() );
+    foreach( event, events.iterator() ) {
+      ostream->writeInt( event->id );
+    }
+    ostream->writeInt( effects.length() );
+    foreach( effect, effects.iterator() ) {
+      ostream->writeInt( effect->id );
+    }
   }
 
 }
diff --git a/src/matrix/DynObject.h b/src/matrix/DynObject.h
index e9d0e0a..5061174 100644
--- a/src/matrix/DynObject.h
+++ b/src/matrix/DynObject.h
@@ -34,8 +34,10 @@ namespace oz
       explicit DynObject() : velocity( Vec3::zero() ), momentum( Vec3::zero() ), lower( -1 )
       {}
 
-      virtual void load( Net::Packet *stream );
-      virtual void save( Net::Packet *stream );
+      virtual void readFull( InputStream *istream );
+      virtual void writeFull( OutputStream *ostream );
+      virtual void readUpdate( InputStream *istream );
+      virtual void writeUpdate( OutputStream *ostream );
   };
 
 }
diff --git a/src/matrix/DynObjectClass.cpp b/src/matrix/DynObjectClass.cpp
index edc8be6..35477d4 100644
--- a/src/matrix/DynObjectClass.cpp
+++ b/src/matrix/DynObjectClass.cpp
@@ -18,35 +18,36 @@ namespace oz
 
   ObjectClass *DynObjectClass::init( const String &name, Config *config )
   {
-    // TODO add class name
     DynObjectClass *clazz = new DynObjectClass();
 
-    clazz->name = name;
+    clazz->name        = name;
     clazz->description = config->get( "description", "" );
 
-    clazz->dim.x = config->get( "dim.x", 0.5f );
-    clazz->dim.y = config->get( "dim.y", 0.5f );
-    clazz->dim.z = config->get( "dim.z", 0.5f );
+    clazz->dim.x       = config->get( "dim.x", 0.5f );
+    clazz->dim.y       = config->get( "dim.y", 0.5f );
+    clazz->dim.z       = config->get( "dim.z", 0.5f );
 
-    clazz->flags = config->get( "flags", Object::CLIP_BIT ) | Object::DYNAMIC_BIT;
-    clazz->damage = config->get( "damage", 1.0f );
+    clazz->flags       = ( config->get( "flags", Object::CLIP_BIT ) & Object::CONFIG_BITS_MASK ) |
+        Object::DYNAMIC_BIT;
+    clazz->damage      = config->get( "damage", 1.0f );
 
-    clazz->mass = config->get( "mass", 100.0f );
-    clazz->lift = config->get( "lift", 0.10f );
+    clazz->mass        = config->get( "mass", 100.0f );
+    clazz->lift        = config->get( "lift", 0.10f );
 
-    clazz->modelType = config->get( "model.type", "MD2" );
-    clazz->modelPath = config->get( "model.path", "mdl/goblin.md2" );
+    clazz->modelType   = config->get( "model.type", "MD2" );
+    clazz->modelPath   = config->get( "model.path", "mdl/goblin.md2" );
 
-    clazz->audioType = config->get( "audio.type", "Simple" );
+    clazz->audioType   = config->get( "audio.type", "Simple" );
 
     char buffer[] = "audio.sample  ";
     for( int i = 0; i < AUDIO_SAMPLES; i++ ) {
       assert( 0 <= i && i < 100 );
 
-      buffer[ sizeof( buffer ) - 2 ] = i / 10;
-      buffer[ sizeof( buffer ) - 1 ] = i % 10;
+      buffer[ sizeof( buffer ) - 3 ] = '0' + ( i / 10 );
+      buffer[ sizeof( buffer ) - 2 ] = '0' + ( i % 10 );
 
-      clazz->audioSamples[i] = translator.soundIndex( config->get( buffer, "" ) );
+      String sampleName = config->get( buffer, "" );
+      clazz->audioSamples[i] = sampleName.length() > 0 ? translator.soundIndex( sampleName ) : -1;
     }
     return clazz;
   }
@@ -55,16 +56,32 @@ namespace oz
   {
     DynObject *obj = new DynObject();
 
-    obj->p = pos;
-    obj->dim = dim;
+    obj->p        = pos;
+    obj->dim      = dim;
 
-    obj->flags = flags;
+    obj->flags    = flags;
     obj->oldFlags = flags;
-    obj->type = this;
-    obj->damage = damage;
+    obj->type     = this;
+    obj->damage   = damage;
 
-    obj->mass = mass;
-    obj->lift = lift;
+    obj->mass     = mass;
+    obj->lift     = lift;
+
+    return obj;
+  }
+
+  Object *DynObjectClass::create( InputStream *istream )
+  {
+    DynObject *obj = new DynObject();
+
+    obj->dim    = dim;
+    obj->sector = null;
+    obj->type   = this;
+
+    obj->mass   = mass;
+    obj->lift   = lift;
+
+    obj->readFull( istream );
 
     return obj;
   }
diff --git a/src/matrix/DynObjectClass.h b/src/matrix/DynObjectClass.h
index 8303d58..0cf280c 100644
--- a/src/matrix/DynObjectClass.h
+++ b/src/matrix/DynObjectClass.h
@@ -20,14 +20,9 @@ namespace oz
     float mass;
     float lift;
 
-    int   sndFriction;
-    int   sndHit;
-    int   sndHitFloor;
-    int   sndSplash;
-    int   sndBigSplash;
-
     static ObjectClass *init( const String &name, Config *config );
     virtual Object *create( const Vec3 &pos );
+    virtual Object *create( InputStream *istream );
   };
 
 }
diff --git a/src/matrix/Matrix.cpp b/src/matrix/Matrix.cpp
index 277cd8e..c824727 100644
--- a/src/matrix/Matrix.cpp
+++ b/src/matrix/Matrix.cpp
@@ -25,79 +25,66 @@ namespace oz
     semaphore = SDL_CreateSemaphore( 0 );
 
     translator.init();
-
+    world.init();
     physics.init( G_ACCEL );
 
     world.sky.init( 70.0f, 600.0f );
     world.sky.time = 200.0f;
     world.terrain.loadIMG( "terra/heightmap.png" );
 
-    world.add( new BSP() );
-    world.add( new BSP() );
-    world.add( new BSP() );
-    world.add( new BSP() );
-//     world.add( new BSP() );
-
-    world.bsps[0]->loadQBSP( "bsp/castle.bsp", 24.0f, BSP::BSP_SCALE );
-    world.bsps[1]->loadQBSP( "bsp/house.bsp", 4.0f, BSP::BSP_SCALE );
-    world.bsps[2]->loadQBSP( "bsp/temple.bsp", 4.0f, BSP::BSP_SCALE );
-    world.bsps[3]->loadQBSP( "bsp/pool.bsp", 4.0f, BSP::BSP_SCALE );
-//     world.bsps[4]->loadQBSP( "bsp/test.bsp", 4.0f, BSP::BSP_SCALE );
-
-    Mat33 t = Mat33( Vec3( -1.0f,  0.0f,  0.0f ),
-                     Vec3(  0.0f, -1.0f,  0.0f ),
-                     Vec3(  0.0f,  0.0f,  1.0f ) );
-
-    world.add( new Structure( Vec3( 47.0f, -33.0f, 82.5f ), Structure::R0, 0 ) );
-//     world.add( new Structure( Vec3( 33.0f, -34.0f, 75.5f ), Mat44::id(), 1 ) );
-//     world.add( new Structure( Vec3( 40.0f, -40.0f, 75.8f ), Mat44::id(), 2 ) );
-
-    world.add( translator.classes["Goblin"]->create( Vec3( 40, -50, 90 ) ) );
-    //world.add( new B_Spirit( Vec3( 40, -70, 90 ), 0.0f, 0.0f ) );
-
-    world.add( translator.classes["Goblin"]->create( Vec3( 40, -35, 85 ) ) );
-    world.add( translator.classes["Goblin"]->create( Vec3( 41, -35, 85 ) ) );
-
-//     world.genParticles( 1000, Vec3( 40, -42, 74 ), Vec3( 0, 0, 10 ), 15.0f, 1.95f, 0.1f, 5.0f,
-//                        0.1f, Vec3( 0.4f, 0.4f, 0.4f ), 0.2f );
-//     world.add( new D_MetalBarrel( Vec3( 51.0f, -42.0f, 80.0f ) ) );
-//     world.add( new D_MetalBarrel( Vec3( 51.0f, -42.0f, 82.0f ) ) );
-//     world.add( new D_MetalBarrel( Vec3( 51.0f, -42.0f, 84.0f ) ) );
+//     world.add( new Structure( Vec3( 47.0f, -33.0f, 82.5f ), translator.bspIndex( "castle" ), Structure::R0 ) );
 //
-//     world.add( new D_WoodBarrel( Vec3( 51.0f, -38.0f, 80.0f ) ) );
-//     world.add( new D_WoodBarrel( Vec3( 51.0f, -38.0f, 82.0f ) ) );
-//     world.add( new D_WoodBarrel( Vec3( 51.0f, -38.0f, 84.0f ) ) );
+//     world.add( translator.createObject( "Goblin", Vec3( 40, -50, 90 ) ) );
+//     //world.add( new B_Spirit( Vec3( 40, -70, 90 ), 0.0f, 0.0f ) );
 //
-//     world.add( new O_Tree1( 0.0f, -30.0f ) );
-//     world.add( new O_Tree2( 0.0f, -42.0f ) );
+//     world.add( translator.createObject( "Goblin", Vec3( 40, -35, 85 ) ) );
+//     world.add( translator.createObject( "Goblin", Vec3( 41, -35, 85 ) ) );
 //
-    world.add( translator.createObject( "SmallCrate", Vec3( 41.0f, -42.0f, 80.0f ) ) );
-    world.add( translator.createObject( "SmallCrate", Vec3( 41.0f, -42.0f, 81.0f ) ) );
-    world.add( translator.createObject( "SmallCrate", Vec3( 41.0f, -42.0f, 82.0f ) ) );
-
-    world.add( translator.createObject( "SmallCrate", Vec3( 41.0f, -41.0f, 80.0f ) ) );
-    world.add( translator.createObject( "SmallCrate", Vec3( 41.0f, -41.0f, 81.0f ) ) );
-    world.add( translator.createObject( "SmallCrate", Vec3( 41.0f, -41.0f, 82.0f ) ) );
-
-    world.add( translator.createObject( "SmallCrate", Vec3( 42.0f, -42.0f, 80.0f ) ) );
-    world.add( translator.createObject( "SmallCrate", Vec3( 42.0f, -42.0f, 81.0f ) ) );
-    world.add( translator.createObject( "SmallCrate", Vec3( 42.0f, -42.0f, 82.0f ) ) );
-
-    world.add( translator.createObject( "SmallCrate", Vec3( 42.0f, -41.0f, 80.0f ) ) );
-    world.add( translator.createObject( "SmallCrate", Vec3( 42.0f, -41.0f, 81.0f ) ) );
-    world.add( translator.createObject( "SmallCrate", Vec3( 42.0f, -41.0f, 82.0f ) ) );
-
-    world.add( translator.createObject( "BigCrate", Vec3( 40.0f, -55.0f, 80.0f ) ) );
-    world.add( translator.createObject( "BigCrate", Vec3( 40.0f, -55.0f, 82.0f ) ) );
-    world.add( translator.createObject( "BigCrate", Vec3( 40.0f, -55.0f, 84.0f ) ) );
-
-//     world.add( new Structure( Vec3( 40.0f, -60.0f, 75.0f ), Structure::R0, 3 ) );
+// //     world.genParticles( 1000, Vec3( 40, -42, 74 ), Vec3( 0, 0, 10 ), 15.0f, 1.95f, 0.1f, 5.0f,
+// //                        0.1f, Vec3( 0.4f, 0.4f, 0.4f ), 0.2f );
+// //     world.add( new D_MetalBarrel( Vec3( 51.0f, -42.0f, 80.0f ) ) );
+// //     world.add( new D_MetalBarrel( Vec3( 51.0f, -42.0f, 82.0f ) ) );
+// //     world.add( new D_MetalBarrel( Vec3( 51.0f, -42.0f, 84.0f ) ) );
+// //
+// //     world.add( new D_WoodBarrel( Vec3( 51.0f, -38.0f, 80.0f ) ) );
+// //     world.add( new D_WoodBarrel( Vec3( 51.0f, -38.0f, 82.0f ) ) );
+// //     world.add( new D_WoodBarrel( Vec3( 51.0f, -38.0f, 84.0f ) ) );
+// //
+// //     world.add( new O_Tree1( 0.0f, -30.0f ) );
+// //     world.add( new O_Tree2( 0.0f, -42.0f ) );
+//
+//     world.add( translator.createObject( "SmallCrate", Vec3( 41.0f, -42.0f, 80.0f ) ) );
+//     world.add( translator.createObject( "SmallCrate", Vec3( 41.0f, -42.0f, 81.0f ) ) );
+//     world.add( translator.createObject( "SmallCrate", Vec3( 41.0f, -42.0f, 82.0f ) ) );
 //
-//     world.add( new Structure( Vec3( 50.0f, -60.0f, 77.0f ), Structure::R0, 4 ) );
+//     world.add( translator.createObject( "SmallCrate", Vec3( 41.0f, -41.0f, 80.0f ) ) );
+//     world.add( translator.createObject( "SmallCrate", Vec3( 41.0f, -41.0f, 81.0f ) ) );
+//     world.add( translator.createObject( "SmallCrate", Vec3( 41.0f, -41.0f, 82.0f ) ) );
+//
+//     world.add( translator.createObject( "SmallCrate", Vec3( 42.0f, -42.0f, 80.0f ) ) );
+//     world.add( translator.createObject( "SmallCrate", Vec3( 42.0f, -42.0f, 81.0f ) ) );
+//     world.add( translator.createObject( "SmallCrate", Vec3( 42.0f, -42.0f, 82.0f ) ) );
+//
+//     world.add( translator.createObject( "SmallCrate", Vec3( 42.0f, -41.0f, 80.0f ) ) );
+//     world.add( translator.createObject( "SmallCrate", Vec3( 42.0f, -41.0f, 81.0f ) ) );
+//     world.add( translator.createObject( "SmallCrate", Vec3( 42.0f, -41.0f, 82.0f ) ) );
+//
+//     world.add( translator.createObject( "BigCrate", Vec3( 40.0f, -55.0f, 80.0f ) ) );
+//     world.add( translator.createObject( "BigCrate", Vec3( 40.0f, -55.0f, 82.0f ) ) );
+//     world.add( translator.createObject( "BigCrate", Vec3( 40.0f, -55.0f, 84.0f ) ) );
+//
+//     world.add( new Structure( Vec3( 40.0f, -60.0f, 75.0f ), translator.bspIndex( "pool" ), Structure::R0 ) );
+//     world.add( new Structure( Vec3( 50.0f, -60.0f, 77.0f ), translator.bspIndex( "test" ), Structure::R0 ) );
 //
 //     world.add( translator.createObject( "SmallCrate", Vec3( 42.0f, -61.0f, 80.0f ) ) );
 //     world.add( translator.createObject( "SmallCrate", Vec3( 42.0f, -61.0f, 81.0f ) ) );
 //     world.add( translator.createObject( "SmallCrate", Vec3( 42.0f, -61.0f, 82.0f ) ) );
+
+    Buffer buffer;
+    buffer.load( "saved.world" );
+    InputStream istream = buffer.inputStream();
+    world.read( &istream );
+    buffer.free();
   }
 
   void Matrix::update()
@@ -149,6 +136,11 @@ namespace oz
 
   void Matrix::free()
   {
+//     Buffer buffer( 1024 * 1024 );
+//     OutputStream ostream = buffer.outputStream();
+//     world.write( &ostream );
+//     buffer.write( "saved.world" );
+
     world.free();
     translator.free();
 
diff --git a/src/matrix/Net.h b/src/matrix/Net.h
index a00152e..a65b227 100644
--- a/src/matrix/Net.h
+++ b/src/matrix/Net.h
@@ -8,6 +8,8 @@
 
 #pragma once
 
+#include "io.h"
+
 namespace oz
 {
 
@@ -28,6 +30,7 @@ namespace oz
       enum ActionType
       {
         ADD,
+        ADD_NOPUT,
         REMOVE,
         PUT,
         CUT,
@@ -51,86 +54,17 @@ namespace oz
         {}
       };
 
-      struct Packet
-      {
-        char *pos;
-        char data[BUFFER_SIZE];
-
-        bool readBool()
-        {
-          void *p = pos;
-          pos += sizeof( bool );
-          return *(bool*) p;
-        }
-
-        void writeBool( bool b )
-        {
-          *(bool*) pos = b;
-          pos += sizeof( bool );
-        }
-
-        int readInt()
-        {
-          void *p = pos;
-          pos += sizeof( int );
-          return SDL_SwapBE32( *(int*) p );
-        }
-
-        void writeInt( int i )
-        {
-          *(int*) pos = SDL_SwapBE32( i );
-          pos += sizeof( int );
-        }
-
-        float readFloat()
-        {
-          pos += sizeof( float );
-          return *(float*) ( pos - sizeof( float ) );
-        }
-
-        void writeFloat( float f )
-        {
-          *(float*) pos = f;
-          pos += sizeof( float );
-        }
-
-        String readString()
-        {
-          // check for buffer overruns
-          char *p = pos;
-          char *end = data + BUFFER_SIZE;
-          while( p < end && *p != '\0' ) {
-            p++;
-          }
-          if( p < end ) {
-            return String( pos );
-          }
-          else {
-            return String( "" );
-          }
-        }
-
-        void writeString( const String &s )
-        {
-          //TODO read/write-String
-          strcpy( pos, s );
-        }
-
-        Vec3 readVec3()
-        {
-          pos += sizeof( Vec3 );
-          return Vec3( (float*) ( pos - sizeof( Vec3 ) ) );
-        }
-
-        void writeVec3( const Vec3 &v )
-        {
-          *(Vec3*) pos = v;
-          pos += sizeof( Vec3 );
-        }
-      };
-
     public:
 
+      // isSingle XOR isServer XOR isClient
+
+      // Singleplayer. No need to worry about object creation, deletion, synchronization etc.
+      bool isSingle;
+      // If server, create notification about every object creation/deletion/put/cut/etc. That can
+      // be later serialized and sent to clients.
+      bool isServer;
+      // If client, do not create or delete any objects by yourself. Every creation/deletion must be
+      // ordered by server.
       bool isClient;
 
       Vector<Action> particles;
diff --git a/src/matrix/Object.cpp b/src/matrix/Object.cpp
index c9d7dc6..3f26512 100644
--- a/src/matrix/Object.cpp
+++ b/src/matrix/Object.cpp
@@ -40,33 +40,26 @@ namespace oz
   void Object::onCut()
   {}
 
-  void Object::readUpdate( Net::Packet *packet )
+  void Object::readFull( InputStream *istream )
   {
-
-//     fread( &p, sizeof( p ), 1, stream );
-//     fread( &dim, sizeof( dim ), 1, stream );
-//     fread( &index, sizeof( index ), 1, stream );
-//     fread( &flags, sizeof( flags ), 1, stream );
-//     fread( &rotZ, sizeof( rotZ ), 1, stream );
-//
-//     index = SDL_SwapBE32( index );
-//     flags = SDL_SwapBE32( flags );
+    p        = istream->readVec3();
+    flags    = istream->readInt();
+    oldFlags = istream->readInt();
+    damage   = istream->readFloat();
   }
 
-  void Object::writeUpdate( Net::Packet *packet )
+  void Object::writeFull( OutputStream *ostream )
   {
-//     index = SDL_SwapBE32( index );
-//     flags = SDL_SwapBE32( flags );
-//
-//     fwrite( &p, sizeof( p ), 1, stream );
-//     fwrite( &dim, sizeof( dim ), 1, stream );
-//     fwrite( &index, sizeof( index ), 1, stream );
-//     fwrite( &flags, sizeof( flags ), 1, stream );
-//     fwrite( &type, sizeof( type ), 1, stream );
-//     fwrite( &rotZ, sizeof( rotZ ), 1, stream );
-//
-//     index = SDL_SwapBE32( index );
-//     flags = SDL_SwapBE32( flags );
+    ostream->writeVec3( p );
+    ostream->writeInt( flags );
+    ostream->writeInt( oldFlags );
+    ostream->writeFloat( damage );
   }
 
+  void Object::readUpdate( InputStream* )
+  {}
+
+  void Object::writeUpdate( OutputStream* )
+  {}
+
 }
diff --git a/src/matrix/Object.h b/src/matrix/Object.h
index 9e87942..6c29a1f 100644
--- a/src/matrix/Object.h
+++ b/src/matrix/Object.h
@@ -14,6 +14,13 @@
 namespace oz
 {
 
+  static const int SND_HIT         = 0;
+  static const int SND_LAND        = 1;
+  static const int SND_FRICT       = 2;
+  static const int SND_SPLASH_SOFT = 3;
+  static const int SND_SPLASH_HARD = 4;
+  static const int SND_JUMP        = 5;
+
   struct Sector;
   struct ObjectClass;
   struct Hit;
@@ -30,8 +37,10 @@ namespace oz
 
     public:
 
-      // which bits are treated as "lower bits", all other are "higher bits"
+      // which bits are can be set in configuration files, other bits are fixed for the given type
       static const int CONFIG_BITS_MASK = 0x000000ff;
+      // which bits are fixed for a type or temporary (~CONFIG_BITS_MASK)
+      static const int TYPE_BITS_MASK = 0xffffff00;
 
       /*
        * FUNCTION FLAGS
@@ -56,6 +65,13 @@ namespace oz
       static const int CUT_FUNC_BIT = 0x04000000;
 
       /*
+       * NETWORK FLAGS
+       */
+
+      // if the object doesn't need to be updated over network
+      static const int NOSYNC_BIT = 0x02000000;
+
+      /*
        * DYNAMIC OBJECTS' BITS
        */
 
@@ -149,31 +165,28 @@ namespace oz
        * FIELDS
        */
 
-      int    index;        // position in world.objects vector
-      Sector *sector;      // parent sector, null if not positioned in the world
+      int             index;        // position in world.objects vector
+      Sector          *sector;      // parent sector, null if not positioned in the world
 
-      Object *prev[1];     // previous object in sector.objects list
-      Object *next[1];     // next object in sector.objects list
+      Object          *prev[1];     // previous object in sector.objects list
+      Object          *next[1];     // next object in sector.objects list
 
-      int    flags;
-      int    oldFlags;
+      int             flags;
+      int             oldFlags;
 
-      ObjectClass *type;
+      ObjectClass     *type;
 
       // damage
-      float   damage;
-
-      // rotation around z axis
-      float   rotZ;
+      float           damage;
 
       // events are cleared at the beginning of next update (used for non-continuous sounds)
-      List<Event, 0> events;
+      List<Event, 0>  events;
       // effects are similar to events, but must be manually cleared (used for continuous sounds)
       List<Effect, 0> effects;
 
     public:
 
-      explicit Object() : index( -1 ), sector( null ), rotZ( 0.0f )
+      explicit Object() : index( -1 ), sector( null )
       {}
 
       virtual ~Object();
@@ -248,8 +261,10 @@ namespace oz
        * SERIALIZATION
        */
 
-      virtual void readUpdate( Net::Packet *packet );
-      virtual void writeUpdate( Net::Packet *packet );
+      virtual void readFull( InputStream *istream );
+      virtual void writeFull( OutputStream *ostream );
+      virtual void readUpdate( InputStream *istream );
+      virtual void writeUpdate( OutputStream *ostream );
 
   };
 
diff --git a/src/matrix/ObjectClass.cpp b/src/matrix/ObjectClass.cpp
index bb34e65..f90af18 100644
--- a/src/matrix/ObjectClass.cpp
+++ b/src/matrix/ObjectClass.cpp
@@ -22,29 +22,30 @@ namespace oz
   {
     ObjectClass *clazz = new ObjectClass();
 
-    clazz->name = name;
+    clazz->name        = name;
     clazz->description = config->get( "description", "" );
 
-    clazz->dim.x = config->get( "dim.x", 0.5f );
-    clazz->dim.y = config->get( "dim.y", 0.5f );
-    clazz->dim.z = config->get( "dim.z", 0.5f );
+    clazz->dim.x       = config->get( "dim.x", 0.5f );
+    clazz->dim.y       = config->get( "dim.y", 0.5f );
+    clazz->dim.z       = config->get( "dim.z", 0.5f );
 
-    clazz->flags = config->get( "flags", Object::CLIP_BIT );
-    clazz->damage = config->get( "damage", 1.0f );
+    clazz->flags       = config->get( "flags", Object::CLIP_BIT ) & Object::CONFIG_BITS_MASK;
+    clazz->damage      = config->get( "damage", 1.0f );
 
-    clazz->modelType = config->get( "model.type", "MD2" );
-    clazz->modelPath = config->get( "model.path", "mdl/goblin.md2" );
+    clazz->modelType   = config->get( "model.type", "MD2" );
+    clazz->modelPath   = config->get( "model.path", "mdl/goblin.md2" );
 
-    clazz->audioType = config->get( "audio.type", "Simple" );
+    clazz->audioType   = config->get( "audio.type", "Simple" );
 
     char buffer[] = "audio.sample  ";
     for( int i = 0; i < AUDIO_SAMPLES; i++ ) {
       assert( 0 <= i && i < 100 );
 
-      buffer[ sizeof( buffer ) - 2 ] = i / 10;
-      buffer[ sizeof( buffer ) - 1 ] = i % 10;
+      buffer[ sizeof( buffer ) - 3 ] = '0' + ( i / 10 );
+      buffer[ sizeof( buffer ) - 2 ] = '0' + ( i % 10 );
 
-      clazz->audioSamples[i] = translator.soundIndex( config->get( buffer, "" ) );
+      String sampleName = config->get( buffer, "" );
+      clazz->audioSamples[i] = sampleName.length() > 0 ? translator.soundIndex( sampleName ) : -1;
     }
     return clazz;
   }
@@ -53,13 +54,26 @@ namespace oz
   {
     Object *obj = new Object();
 
-    obj->p = pos;
-    obj->dim = dim;
+    obj->p        = pos;
+    obj->dim      = dim;
 
-    obj->flags = flags;
+    obj->flags    = flags;
     obj->oldFlags = flags;
-    obj->type =this;
-    obj->damage = damage;
+    obj->type     = this;
+    obj->damage   = damage;
+
+    return obj;
+  }
+
+  Object *ObjectClass::create( InputStream *istream )
+  {
+    Object *obj = new Object();
+
+    obj->dim    = dim;
+    obj->sector = null;
+    obj->type   = this;
+
+    obj->readFull( istream );
 
     return obj;
   }
diff --git a/src/matrix/ObjectClass.h b/src/matrix/ObjectClass.h
index afc02d3..df51386 100644
--- a/src/matrix/ObjectClass.h
+++ b/src/matrix/ObjectClass.h
@@ -40,6 +40,7 @@ namespace oz
 
     static ObjectClass *init( const String &name, Config *config );
     virtual Object *create( const Vec3 &pos );
+    virtual Object *create( InputStream *istream );
   };
 
 }
diff --git a/src/matrix/Particle.cpp b/src/matrix/Particle.cpp
index 0dfb167..c85f2b4 100644
--- a/src/matrix/Particle.cpp
+++ b/src/matrix/Particle.cpp
@@ -15,19 +15,46 @@ namespace oz
 
   const float Particle::MAX_ROTVELOCITY = 1000.0f;
 
-  Particle::~Particle()
-  {}
-
-  // serialize whole object
-  void Particle::serialize( char* ) const
-  {}
-
-      // serialize only information necessary for network synchronizing
-  void Particle::updateSerialize( char* ) const
-  {}
-
-      // update object with recieved synchronization information from network
-  void Particle::updateDeserialize( const char* )
-  {}
+  void Particle::readFull( InputStream *istream )
+  {
+    p           = istream->readVec3();
+    velocity    = istream->readVec3();
+
+    rejection   = istream->readFloat();
+    mass        = istream->readFloat();
+    lifeTime    = istream->readFloat();
+
+    size        = istream->readFloat();
+    color       = istream->readVec3();
+    rot         = istream->readVec3();
+    rotVelocity = istream->readVec3();
+  }
+
+  void Particle::writeFull( OutputStream *ostream )
+  {
+    ostream->writeVec3( p );
+    ostream->writeVec3( velocity );
+
+    ostream->writeFloat( rejection );
+    ostream->writeFloat( mass );
+    ostream->writeFloat( lifeTime );
+
+    ostream->writeFloat( size );
+    ostream->writeVec3( color );
+    ostream->writeVec3( rot );
+    ostream->writeVec3( rotVelocity );
+  }
+
+  void Particle::readUpdate( InputStream *istream )
+  {
+    p        = istream->readVec3();
+    velocity = istream->readVec3();
+  }
+
+  void Particle::writeUpdate( OutputStream *ostream )
+  {
+    ostream->writeVec3( p );
+    ostream->writeVec3( velocity );
+  }
 
 }
diff --git a/src/matrix/Particle.h b/src/matrix/Particle.h
index a1cbb83..a39e80a 100644
--- a/src/matrix/Particle.h
+++ b/src/matrix/Particle.h
@@ -8,6 +8,7 @@
 
 #pragma once
 
+#include "io.h"
 #include "Timer.h"
 
 namespace oz
@@ -15,8 +16,6 @@ namespace oz
 
   struct Sector;
 
-  // should NOT be virtual (offset of .p must be 0 otherwise a hack in Matrix::Collider.test(L)Ray
-  // won't work)
   class Particle
   {
     public:
@@ -37,7 +36,7 @@ namespace oz
 
       Vec3      velocity;
 
-      float     rejection;    // 1.0 < reject < 2.0
+      float     rejection;    // 1.0 < rejection < 2.0
       float     mass;
       float     lifeTime;
 
@@ -62,8 +61,6 @@ namespace oz
                              Math::frand() * MAX_ROTVELOCITY ) )
       {}
 
-      virtual ~Particle();
-
       void update()
       {
         rot += rotVelocity * timer.frameTime;
@@ -73,14 +70,11 @@ namespace oz
        *  SERIALIZATION
        */
 
-      // serialize whole object
-      virtual void serialize( char* ) const;
-
-      // serialize only information necessary for network synchronizing
-      virtual void updateSerialize( char* ) const;
+      void readFull( InputStream *istream );
+      void writeFull( OutputStream *ostream );
+      void readUpdate( InputStream *istream );
+      void writeUpdate( OutputStream *ostream );
 
-      // update object with recieved synchronization information from network
-      virtual void updateDeserialize( const char* );
   };
 
 }
diff --git a/src/matrix/Physics.cpp b/src/matrix/Physics.cpp
index d7fa7f0..44ef0e1 100644
--- a/src/matrix/Physics.cpp
+++ b/src/matrix/Physics.cpp
@@ -78,9 +78,9 @@ namespace oz
     Sector *newSector = world.getSector( part->p );
 
     if( oldSector != newSector ) {
+      part->sector = newSector;
       oldSector->particles.remove( part );
       newSector->particles << part;
-      part->sector = newSector;
     }
   }
 
@@ -203,7 +203,6 @@ namespace oz
   void Physics::handleObjHit()
   {
     Object *sObj = collider.hit.obj;
-    Vec3 oldVelocity = obj->momentum;
 
     if( collider.hit.obj != null && ( collider.hit.obj->flags & Object::DYNAMIC_BIT ) ) {
       DynObject *sDynObj = (DynObject*) sObj;
@@ -360,9 +359,9 @@ namespace oz
     Sector *newSector = world.getSector( obj->p );
 
     if( oldSector != newSector ) {
+      obj->sector = newSector;
       oldSector->objects.remove( obj );
       newSector->objects << obj;
-      obj->sector = newSector;
     }
   }
 
@@ -407,6 +406,7 @@ namespace oz
           ( (DynObject*) world.objects[obj->lower] )->momentum.isZero() ) ) )
       {
         obj->flags |= Object::DISABLED_BIT;
+        obj->velocity.setZero();
       }
       // handle physics
       if( !( obj->flags & Object::DISABLED_BIT ) ) {
diff --git a/src/matrix/Structure.h b/src/matrix/Structure.h
index a38d100..7e35680 100644
--- a/src/matrix/Structure.h
+++ b/src/matrix/Structure.h
@@ -9,6 +9,7 @@
 #pragma once
 
 #include "bv.h"
+#include "io.h"
 
 namespace oz
 {
@@ -24,16 +25,19 @@ namespace oz
     };
 
     Vec3     p;
-    Rotation rot;
     int      index;
     int      bsp;
+    Rotation rot;
     float    damage;
 
     explicit Structure() {}
 
-    explicit Structure( const Vec3 &p_, Rotation rot_, int bsp_ ) :
-        p( p_ ), rot( rot_ ), bsp( bsp_ )
+    explicit Structure( const Vec3 &p_, int bsp_, Rotation rot_ ) :
+        p( p_ ), bsp( bsp_ ), rot( rot_ )
     {}
+
+    void readFull( InputStream *istream );
+    void writeFull( OutputStream *ostream );
   };
 
 }
diff --git a/src/matrix/Translator.cpp b/src/matrix/Translator.cpp
index 7702aaf..4e0faef 100644
--- a/src/matrix/Translator.cpp
+++ b/src/matrix/Translator.cpp
@@ -40,87 +40,153 @@ namespace oz
     DIR *dir;
     struct dirent *file;
 
+    logFile.println( "textures (*.png, *.jpg in 'textures/oz') {" );
+    logFile.indent();
+
     dir = opendir( "textures/oz" );
     if( dir == null ) {
       free();
 
-      logFile.println( "Cannot open textures/oz" );
+      logFile.println( "Cannot open directory 'textures/oz'" );
       logFile.unindent();
       logFile.println( "}" );
       return false;
     }
     while( ( file = readdir( dir ) ) != null ) {
       String name = file->d_name;
-      String fileName = "textures/oz/" + name;
+      int dot = name.lastIndex( '.' );
 
-      if( name.length() <= 4  ) {
+      if( dot <= 0 ) {
         continue;
       }
-
-      String extension = name.substring( name.length() - 4 );
-      if( extension != ".jpg" && extension != ".png" ) {
+      String extension = name.substring( dot );
+      if( extension != ".png" && extension != ".jpg" ) {
         continue;
       }
 
-      textureIndices.add( fileName, textures.length() );
-      textures << fileName;
+      String fileName = "textures/oz/" + name;
+      String baseName = name.substring( 0, dot );
+      if( textureIndices.contains( baseName ) ) {
+        logFile.println( "duplicated texture: %s", baseName.cstr() );
+        return false;
+      }
+      textureIndices.add( baseName, textures.length() );
+      textures << Resource( baseName, fileName );
 
-      logFile.println( "texture: %s", fileName.cstr() );
+      logFile.println( "%s", baseName.cstr() );
     }
     closedir( dir );
 
+    logFile.unindent();
+    logFile.println( "}" );
+    logFile.println( "sounds (*.au, *.wav, *.oga in 'snd') {" );
+    logFile.indent();
+
     dir = opendir( "snd" );
     if( dir == null ) {
       free();
 
-      logFile.println( "Cannot open snd/" );
+      logFile.println( "Cannot open directory 'snd'" );
       logFile.unindent();
       logFile.println( "}" );
       return false;
     }
     while( ( file = readdir( dir ) ) != null ) {
       String name = file->d_name;
-      String fileName = "snd/" + name;
+      int dot = name.lastIndex( '.' );
+
+      if( dot <= 0 ) {
+        continue;
+      }
+      String extension = name.substring( dot );
+      if( extension != ".au" &&
+          extension != ".wav" &&
+          extension != ".oga" &&
+          extension != ".ogg" )
+      {
+        continue;
+      }
 
-      if( name.length() <= 4  ) {
+      String fileName = "snd/" + name;
+      String baseName = name.substring( 0, dot );
+      if( soundIndices.contains( baseName ) ) {
+        logFile.println( "duplicated sound: %s", baseName.cstr() );
         continue;
       }
+      soundIndices.add( baseName, sounds.length() );
+      sounds << Resource( baseName, fileName );;
+
+      logFile.println( "%s", baseName.cstr() );
+    }
+    closedir( dir );
+
+    logFile.unindent();
+    logFile.println( "}" );
+    logFile.println( "BSP structures (*.xml in 'bsp') {" );
+    logFile.indent();
+
+    dir = opendir( "bsp" );
+    if( dir == null ) {
+      free();
+
+      logFile.println( "Cannot open directory 'bsp'" );
+      logFile.unindent();
+      logFile.println( "}" );
+      return false;
+    }
+    while( ( file = readdir( dir ) ) != null ) {
+      String name = file->d_name;
+      int dot = name.lastIndex( '.' );
 
-      String extension = name.substring( name.length() - 4 );
-      if( extension != ".wav" && extension != ".ogg" && extension != ".oga" ) {
+      if( dot <= 0 ) {
+        continue;
+      }
+      String extension = name.substring( dot );
+      if( extension != ".xml" ) {
         continue;
       }
 
-      soundIndices.add( fileName, sounds.length() );
-      sounds << fileName;
+      String fileName = "bsp/" + name;
+      String baseName = name.substring( 0, dot );
+      if( bspIndices.contains( baseName ) ) {
+        logFile.println( "duplicated bsp: %s", baseName.cstr() );
+        return false;
+      }
+      bspIndices.add( baseName, bsps.length() );
+      bsps << Resource( baseName, "" );;
 
-      logFile.println( "sound: %s", fileName.cstr() );
+      logFile.println( "%s", baseName.cstr() );
     }
     closedir( dir );
 
+    logFile.unindent();
+    logFile.println( "}" );
+    logFile.println( "object classes (*.xml in 'class') {" );
+    logFile.indent();
+
     dir = opendir( "class" );
     if( dir == null ) {
       free();
 
-      logFile.println( "Cannot open class/" );
+      logFile.println( "Cannot open directory 'class'" );
       logFile.unindent();
       logFile.println( "}" );
       return false;
     }
     while( ( file = readdir( dir ) ) != null ) {
       String name = file->d_name;
-      String fileName = "class/" + name;
+      int dot = name.lastIndex( '.' );
 
-      if( name.length() <= 4 ) {
+      if( dot <= 0 ) {
         continue;
       }
-
-      String extension = name.substring( name.length() - 4 );
+      String extension = name.substring( dot );
       if( extension != ".xml" ) {
         continue;
       }
 
-      name = name.substring( 0, name.length() - 4 );
+      String fileName = "class/" + name;
+      String baseName = name.substring( 0, dot );
 
       if( !classConfig.load( fileName ) ) {
         logFile.println( "invalid config file %s", fileName.cstr() );
@@ -138,14 +204,22 @@ namespace oz
         continue;
       }
 
-      classConfig.add( "name", name );
-      classes.add( name, baseClasses.cachedValue()( name, &classConfig ) );
+      if( classes.contains( baseName ) ) {
+        logFile.println( "duplicated class: %s", baseName.cstr() );
+        return false;
+      }
+      classConfig.add( "name", baseName );
+      classes.add( baseName, baseClasses.cachedValue()( baseName, &classConfig ) );
       classConfig.clear();
+
+      logFile.println( "%s", baseName.cstr() );
     }
     closedir( dir );
 
     logFile.unindent();
     logFile.println( "}" );
+    logFile.unindent();
+    logFile.println( "}" );
 
     return true;
   }
@@ -172,10 +246,22 @@ namespace oz
     }
   }
 
+  int Translator::bspIndex( const char *file )
+  {
+    if( bspIndices.contains( file ) ) {
+      return bspIndices.cachedValue();
+    }
+    else {
+      logFile.println( "W: invalid bsp file index requested: %s", file );
+      return -1;
+    }
+  }
+
   void Translator::free()
   {
     textureIndices.clear();
     soundIndices.clear();
+    bspIndices.clear();
 
     baseClasses.clear();
     classes.free();
diff --git a/src/matrix/Translator.h b/src/matrix/Translator.h
index 267ed79..bdc3e40 100644
--- a/src/matrix/Translator.h
+++ b/src/matrix/Translator.h
@@ -40,27 +40,46 @@ namespace oz
 
   class Translator
   {
+    public:
+
+      struct Resource
+      {
+        String name;
+        String path;
+
+        Resource() {}
+        Resource( const String &name_, const String &path_ ) : name( name_ ), path( path_ ) {}
+      };
+
     private:
 
       HashString<int, 1021> textureIndices;
       HashString<int, 1021> soundIndices;
+      HashString<int, 1021> bspIndices;
 
     public:
 
-      Vector<String> textures;
-      Vector<String> sounds;
+      Vector<Resource> textures;
+      Vector<Resource> sounds;
+      Vector<Resource> bsps;
 
       HashString<ObjectClass::InitFunc, 31> baseClasses;
       HashString<ObjectClass*, 251> classes;
 
       int textureIndex( const char *file );
       int soundIndex( const char *file );
+      int bspIndex( const char *file );
 
       Object *createObject( const char *name, const Vec3 &p )
       {
         return classes[name]->create( p );
       }
 
+      Object *createObject( const char *name, InputStream *istream )
+      {
+        return classes[name]->create( istream );
+      }
+
       bool init();
       void free();
   };
diff --git a/src/matrix/VehicleClass.cpp b/src/matrix/VehicleClass.cpp
index 019c460..1fb93b3 100644
--- a/src/matrix/VehicleClass.cpp
+++ b/src/matrix/VehicleClass.cpp
@@ -27,4 +27,10 @@ namespace oz
     return null;
   }
 
+  Object *VehicleClass::create( InputStream* )
+  {
+    assert( false );
+    return null;
+  }
+
 }
diff --git a/src/matrix/VehicleClass.h b/src/matrix/VehicleClass.h
index 3a9a9e2..dbbb79a 100644
--- a/src/matrix/VehicleClass.h
+++ b/src/matrix/VehicleClass.h
@@ -20,6 +20,7 @@ namespace oz
   {
     static ObjectClass *init( const String &name, Config *config );
     virtual Object *create( const Vec3 &pos );
+    virtual Object *create( InputStream *istream );
   };
 
 }
diff --git a/src/matrix/World.cpp b/src/matrix/World.cpp
index 537f80d..81df33d 100644
--- a/src/matrix/World.cpp
+++ b/src/matrix/World.cpp
@@ -26,43 +26,64 @@ namespace oz
       addingQueue( 0 ), standbyQueue( 1 ), freedQueue( 2 )
   {}
 
-  void World::put( Object *obj )
+  void World::init()
   {
-    if( net.isClient ) {
-      return;
+    foreach( bsp, translator.bsps.iterator() ) {
+      bsps << new BSP();
+      if( !bsps.last()->load( bsp->name ) ) {
+        throw Exception( 0, "BSP loading failed" );
+      }
     }
+  }
 
-    assert( obj->sector == null );
-
-    Sector *sector = getSector( obj->p );
+  void World::free()
+  {
+    for( int i = 0; i < World::MAX; i++ ) {
+      for( int j = 0; j < World::MAX; j++ ) {
+        sectors[i][j].structures.clear();
+        sectors[i][j].objects.clear();
+        sectors[i][j].particles.clear();
+      }
+    }
 
-    obj->sector = sector;
-    sector->objects << obj;
+    foreach( str, structures.iterator() ) {
+      if( *str != null ) {
+        delete *str;
+      }
+    }
+    structures.clear();
 
-    net.objects << Net::Action( Net::PUT, obj->index );
-  }
+    foreach( obj, objects.iterator() ) {
+      if( *obj != null ) {
+        delete *obj;
+      }
+    }
+    objects.clear();
 
-  void World::cut( Object *obj )
-  {
-    if( net.isClient ) {
-      return;
+    foreach( part, particles.iterator() ) {
+      if( *part != null ) {
+        delete *part;
+      }
     }
+    particles.clear();
 
-    assert( obj->sector != null );
+    foreach( bsp, bsps.iterator() ) {
+      (*bsp)->free();
+      delete *bsp;
+    }
+    bsps.clear();
 
-    obj->sector->objects.remove( obj );
-    obj->sector = null;
+    PoolAlloc<Object::Event, 0>::pool.free();
+    PoolAlloc<Object::Effect, 0>::pool.free();
 
-    net.objects << Net::Action( Net::CUT, obj->index );
+    if( net.isServer ) {
+      net.world << Net::Action( Net::CLEAR );
+    }
   }
 
-  void World::add( Structure *str )
+  void World::position( Structure *str )
   {
-    if( net.isClient ) {
-      return;
-    }
-
-    Bounds &bsp = *bsps[str->bsp];
+    const Bounds &bsp = *bsps[str->bsp];
 
     switch( str->rot ) {
       case Structure::R0: {
@@ -91,6 +112,108 @@ namespace oz
       }
     }
 
+    getInters( *str, EPSILON );
+
+    for( int x = minSectX; x <= maxSectX; x++ ) {
+      for( int y = minSectY; y <= maxSectY; y++ ) {
+        sectors[x][y].structures << str->index;
+      }
+    }
+  }
+
+  void World::unposition( Structure *str )
+  {
+    getInters( *str, EPSILON );
+
+    for( int x = minSectX; x <= maxSectX; x++ ) {
+      for( int y = minSectY; y <= maxSectY; y++ ) {
+        sectors[x][y].structures.exclude( str->index );
+      }
+    }
+  }
+
+  inline void World::position( Object *obj )
+  {
+    obj->sector = world.getSector( obj->p );
+    obj->sector->objects << obj;
+  }
+
+  inline void World::unposition( Object *obj )
+  {
+    obj->sector->objects.remove( obj );
+    obj->sector = null;
+  }
+
+  inline void World::reposition( Object *obj )
+  {
+    Sector *oldSector = obj->sector;
+    Sector *newSector = world.getSector( obj->p );
+
+    if( newSector != oldSector ) {
+      oldSector->objects.remove( obj );
+      newSector->objects << obj;
+      obj->sector = newSector;
+    }
+  }
+
+  inline void World::position( Particle *part )
+  {
+    part->sector = world.getSector( part->p );
+    part->sector->particles << part;
+  }
+
+  inline void World::unposition( Particle *part )
+  {
+    part->sector = null;
+    part->sector->particles.remove( part );
+  }
+
+  inline void World::reposition( Particle *part )
+  {
+    Sector *oldSector = part->sector;
+    Sector *newSector = world.getSector( part->p );
+
+    if( newSector != oldSector ) {
+      oldSector->particles.remove( part );
+      newSector->particles << part;
+      part->sector = newSector;
+    }
+  }
+
+  inline void World::put( Object *obj )
+  {
+    if( net.isClient ) {
+      return;
+    }
+
+    assert( obj->sector == null );
+    position( obj );
+
+    if( net.isServer ) {
+      net.objects << Net::Action( Net::PUT, obj->index );
+    }
+  }
+
+  inline void World::cut( Object *obj )
+  {
+    if( net.isClient ) {
+      return;
+    }
+
+    assert( obj->sector != null );
+    unposition( obj );
+
+    if( net.isServer ) {
+      net.objects << Net::Action( Net::CUT, obj->index );
+    }
+  }
+
+  void World::add( Structure *str )
+  {
+    if( net.isClient ) {
+      return;
+    }
+
     if( strFreeQueue[freedQueue].isEmpty() ) {
       str->index = structures.length();
       structures << str;
@@ -100,15 +223,11 @@ namespace oz
       structures[str->index] = str;
     }
 
-    getInters( *str, EPSILON );
+    position( str );
 
-    for( int x = minSectX; x <= maxSectX; x++ ) {
-      for( int y = minSectY; y <= maxSectY; y++ ) {
-        sectors[x][y].structures << str->index;
-      }
+    if( net.isServer ) {
+      net.structs << Net::Action( Net::ADD, str->index );
     }
-
-    net.structs << Net::Action( Net::ADD, str->index );
   }
 
   void World::add( Object *obj, bool doPut )
@@ -133,10 +252,8 @@ namespace oz
       obj->sector = null;
     }
 
-    net.objects << Net::Action( Net::ADD, obj->index );
-
-    if( !doPut ) {
-      net.objects << Net::Action( Net::CUT, obj->index );
+    if( net.isServer ) {
+      net.objects << Net::Action( doPut ? Net::ADD : Net::ADD_NOPUT, obj->index );
     }
   }
 
@@ -145,7 +262,6 @@ namespace oz
     if( net.isClient ) {
       return;
     }
-
     if( partFreeQueue[freedQueue].isEmpty() ) {
       part->index = particles.length();
       particles << part;
@@ -155,12 +271,11 @@ namespace oz
       particles[part->index] = part;
     }
 
-    Sector *sector = getSector( part->p );
+    position( part );
 
-    part->sector = sector;
-    sector->particles << part;
-
-    net.particles << Net::Action( Net::ADD, part->index );
+    if( net.isServer ) {
+      net.particles << Net::Action( Net::ADD, part->index );
+    }
   }
 
   void World::remove( Structure *str )
@@ -168,16 +283,12 @@ namespace oz
     if( net.isClient ) {
       return;
     }
-    net.structs << Net::Action( Net::REMOVE, str->index );
-
-    getInters( *str, EPSILON );
-
-    for( int x = minSectX; x <= maxSectX; x++ ) {
-      for( int y = minSectY; y <= maxSectY; y++ ) {
-        sectors[x][y].structures.exclude( str->index );
-      }
+    else if( net.isServer ) {
+      net.structs << Net::Action( Net::REMOVE, str->index );
     }
 
+    unposition( str );
+
     strFreeQueue[addingQueue] << str->index;
 
     structures[str->index] = null;
@@ -189,10 +300,12 @@ namespace oz
     if( net.isClient ) {
       return;
     }
-    net.objects << Net::Action( Net::REMOVE, obj->index );
+    else if( net.isServer ) {
+      net.objects << Net::Action( Net::REMOVE, obj->index );
+    }
 
     if( obj->sector != null ) {
-      obj->sector->objects.remove( obj );
+      unposition( obj );
     }
 
     objFreeQueue[addingQueue] << obj->index;
@@ -206,9 +319,11 @@ namespace oz
     if( net.isClient ) {
       return;
     }
-    net.particles << Net::Action( Net::REMOVE, part->index );
+    else if( net.isServer ) {
+      net.particles << Net::Action( Net::REMOVE, part->index );
+    }
 
-    part->sector->particles.remove( part );
+    unposition( part );
 
     partFreeQueue[addingQueue] << part->index;
 
@@ -276,64 +391,126 @@ namespace oz
       --particles;
     }
     particles.trim( 128 );
-
-    bsps.trim( 1 );
   }
 
-  void World::add( BSP *bsp )
+  bool World::read( InputStream *istream )
   {
-    if( net.isClient ) {
-      return;
+    assert( structures.length() == 0 && objects.length() == 0 && particles.length() == 0 );
+
+    try {
+      int nStructures = istream->readInt();
+      int nObjects    = istream->readInt();
+      int nParticles  = istream->readInt();
+
+      String    bspFile;
+      Structure *str;
+      Object    *obj;
+      String    typeName;
+      Particle  *part;
+
+      for( int i = 0; i < nStructures; i++ ) {
+        istream->readString( bspFile );
+
+        if( bspFile.length() == 0 ) {
+          structures.add( null );
+        }
+        else {
+          int bspIndex = translator.bspIndex( bspFile );
+          if( bspIndex == -1 ) {
+            throw Exception( 0, "BSP not loaded" );
+          }
+          str = new Structure();
+          str->readFull( istream );
+          str->index = i;
+          str->bsp = bspIndex;
+          position( str );
+          structures << str;
+        }
+      }
+      for( int i = 0; i < nObjects; i++ ) {
+        istream->readString( typeName );
+
+        if( typeName.length() == 0 ) {
+          objects.add( null );
+        }
+        else {
+          obj = translator.createObject( typeName.cstr(), istream );
+          obj->index = i;
+          position( obj );
+          objects << obj;
+        }
+      }
+      for( int i = 0; i < nParticles; i++ ) {
+        bool exists = istream->readBool();
+
+        if( !exists ) {
+          particles.add( null );
+        }
+        else {
+          part = new Particle();
+          part->readFull( istream );
+          part->index = i;
+          position( part );
+          particles << part;
+        }
+      }
     }
-    net.bsps << Net::Action( Net::ADD, bsps.length() );
-
-    bsps << bsp;
+    catch( Exception ) {
+      return false;
+    }
+    return true;
   }
 
-  void World::free()
+  bool World::write( OutputStream *ostream )
   {
-    for( int i = 0; i < World::MAX; i++ ) {
-      for( int j = 0; j < World::MAX; j++ ) {
-        sectors[i][j].structures.clear();
-        sectors[i][j].objects.clear();
-        sectors[i][j].particles.clear();
+    try {
+      ostream->writeInt( structures.length() );
+      ostream->writeInt( objects.length() );
+      ostream->writeInt( particles.length() );
+
+      String    typeName;
+      Structure *str;
+      Object    *obj;
+      Particle  *part;
+
+      for( int i = 0; i < structures.length(); i++ ) {
+        str = structures[i];
+
+        if( str == null ) {
+          ostream->writeString( "" );
+        }
+        else {
+          ostream->writeString( translator.bsps[str->bsp].name );
+          str->writeFull( ostream );
+        }
       }
-    }
-
-    int iMax = structures.length();
-    for( int i = 0; i < iMax; i++ ) {
-      if( structures[i] != null ) {
-        delete structures[i];
-        structures[i] = null;
+      for( int i = 0; i < objects.length(); i++ ) {
+        obj = objects[i];
+
+        if( obj == null ) {
+          ostream->writeString( "" );
+        }
+        else {
+          ostream->writeString( obj->type->name );
+          obj->writeFull( ostream );
+        }
       }
-    }
-    structures.clear();
-
-    int jMax = objects.length();
-    for( int j = 0; j < jMax; j++ ) {
-      if( objects[j] != null && objects[j]->sector != null ) {
-        delete objects[j];
-        objects[j] = null;
+      for( int i = 0; i < particles.length(); i++ ) {
+        part = particles[i];
+
+        if( part == null ) {
+          ostream->writeBool( false );
+        }
+        else {
+          ostream->writeBool( true );
+          part->writeFull( ostream );
+        }
       }
     }
-    objects.clear();
-
-    int kMax = particles.length();
-    for( int k = 0; k < kMax; k++ ) {
-      if( particles[k] != null ) {
-        delete particles[k];
-        particles[k] = null;
-      }
+    catch( Exception ) {
+      return false;
     }
-    particles.clear();
-
-    PoolAlloc<Object::Event, 0>::pool.free();
-    PoolAlloc<Object::Effect, 0>::pool.free();
-
-    bsps.free();
-    bsps.clear();
-
-    net.world << Net::Action( Net::CLEAR );
+    return true;
   }
 
 }
diff --git a/src/matrix/World.h b/src/matrix/World.h
index 1748768..fb0234c 100644
--- a/src/matrix/World.h
+++ b/src/matrix/World.h
@@ -8,8 +8,6 @@
 
 #pragma once
 
-#include "Net.h"
-
 #include "Sky.h"
 #include "Terrain.h"
 #include "BSP.h"
@@ -18,6 +16,8 @@
 #include "DynObject.h"
 #include "Particle.h"
 
+#include "Translator.h"
+
 namespace oz
 {
 
@@ -34,41 +34,45 @@ namespace oz
 
   class World : public Bounds
   {
-    private:
-
-      // List of free indices. Indices can be reused after one full world update pass, so that all
-      // references to those indices are removed (object update functions should remove all invalid
-      // references).
-      Vector<int> strFreeQueue[3];
-      Vector<int> objFreeQueue[3];
-      Vector<int> partFreeQueue[3];
-
-      int addingQueue;
-      int standbyQueue;
-      int freedQueue;
-
     public:
 
       // # of sectors on each (x, y) axis
       static const int MAX = 128;
       static const float DIM;
 
-      Sky     sky;
-      Terrain terrain;
-      Sector  sectors[World::MAX][World::MAX];
+      int                 minSectX;
+      int                 minSectY;
+      int                 maxSectX;
+      int                 maxSectY;
 
+      Sky                 sky;
+      Terrain             terrain;
+      Sector              sectors[World::MAX][World::MAX];
+      Vector<BSP*>        bsps;
       Vector<Structure*>  structures;
       Vector<Object*>     objects;
       Vector<Particle*>   particles;
 
-      // bsp list (should not change during world existance)
-      Vector<BSP*>        bsps;
+    private:
 
-      int minSectX, minSectY;
-      int maxSectX, maxSectY;
+      // List of free indices. Indices can be reused after one full world update pass, so that all
+      // references to those indices are removed (object update functions should remove all invalid
+      // references).
+      Vector<int>         strFreeQueue[3];
+      Vector<int>         objFreeQueue[3];
+      Vector<int>         partFreeQueue[3];
+
+      int                 addingQueue;
+      int                 standbyQueue;
+      int                 freedQueue;
+
+    public:
 
       World();
 
+      void init();
+      void free();
+
       // get pointer to the sector the point is in
       Sector* getSector( float x, float y );
       Sector* getSector( const Vec3 &p );
@@ -83,6 +87,21 @@ namespace oz
       // get indices of min and max sectors which the bounds intersects
       void getInters( const Bounds &bounds, float epsilon = 0.0f );
 
+    private:
+
+      void position( Structure *str );
+      void unposition( Structure *str );
+
+      void position( Object *obj );
+      void unposition( Object *obj );
+      void reposition( Object *obj );
+
+      void position( Particle *part );
+      void unposition( Particle *part );
+      void reposition( Particle *part );
+
+    public:
+
       /**
        * Put the object into the world hashspace
        */
@@ -107,9 +126,11 @@ namespace oz
       // trim vectors to optimize memory usage
       void trim();
 
-      void add( BSP *bsp );
+      void ensureBSPLoaded( int id );
+
+      bool read( InputStream *istream );
+      bool write( OutputStream *ostream );
 
-      void free();
   };
 
   extern World world;
diff --git a/src/test/CMakeLists.txt b/src/test/CMakeLists.txt
index db5fcd8..9edc9a0 100644
--- a/src/test/CMakeLists.txt
+++ b/src/test/CMakeLists.txt
@@ -1,6 +1,6 @@
 link_libraries( base )
 
 add_executable( test
-  test.cpp )
+  io.cpp )
 
 add_dependencies( test precompile )
